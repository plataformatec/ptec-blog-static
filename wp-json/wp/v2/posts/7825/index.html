{"id":7825,"date":"2018-10-05T15:06:28","date_gmt":"2018-10-05T18:06:28","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=7825"},"modified":"2018-10-22T19:23:59","modified_gmt":"2018-10-22T21:23:59","slug":"a-sneak-peek-at-ecto-3-0-query-improvements-part-1","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-1\/","title":{"rendered":"A sneak peek at Ecto 3.0: query improvements (part 1)"},"content":{"rendered":"<p>Welcome to the &#8220;A sneak peek at Ecto 3.0&#8221; series:<\/p>\n<ol>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-breaking-changes\/\">Breaking changes<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-1\/\">Query improvements part 1<\/a> (you are here!)<\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-2\/\">Query improvements part 2<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-performance-migrations-and-more\/\">Performance, migrations and more<\/a><\/li>\n<\/ol>\n<p>Let&#8217;s get started with the improvements to Ecto.Query APIs. The <code>Ecto.Query<\/code> API is the area that saw most improvements in Ecto 3.0, to the point we won&#8217;t be able to cover all improvement in a single article. Instead, we broke it in part 1 and part 2.<\/p>\n<p>Let&#8217;s get started.<\/p>\n<h2>Better join composition with named bindings<\/h2>\n<p>Ecto has always supported joining over multiple schemas and tables using joins:<\/p>\n<pre><code>query =\n  from p in Post,\n    join: c in Comment,\n    where: p.id == c.post_id,\n    select: c\n<\/code><\/pre>\n<p>Now imagine we want to modify the query above to only return comments that are public. We could compose on the query above as follows:<\/p>\n<pre><code>from [_, c] in query, where: c.public\n<\/code><\/pre>\n<p>As you can see in the example above, we can extract all existing bindings in a query (<code>p<\/code> and <code>c<\/code>) and then apply filters to them. In the example above, the bindings are positional and they depend on the order they appear in the list on the left side of <code>in<\/code>. The names <code>p<\/code> and <code>c<\/code> are temporary and they are not relevant to the overall query. In other words, the query below would be equivalent to the one above:<\/p>\n<pre><code>from [_, comment] in query, where: comment.public\n<\/code><\/pre>\n<p>The problem with positional bindings is that sometimes it makes query composition quite challenging. When building complex search functionality, you may join over multiple tables, in a different order, and tracking where each positional binding is would be quite brittle and complex.<\/p>\n<p>Ecto 3.0 changes this by allowing each <code>from<\/code> and <code>join<\/code> to have a name. Our initial query could be rewritten as:<\/p>\n<pre><code>query =\n  from p in Post,\n    join: c in Comment,\n    as: :comments,\n    where: p.id == c.post_id,\n    select: c\n<\/code><\/pre>\n<p>Note we have added the <code>as<\/code> option after the join. Now to filter the existing <code>:comments<\/code>, regardless of the order it appears on the query, we can write:<\/p>\n<pre><code>from [comments: c] in query, where: c.public\n<\/code><\/pre>\n<p>We replace the positional binding by a keyword list, where the key is the binding name and the value is a variable we will assign the join to. Once again, the <code>c<\/code> variable here does not matter and it could have any name. The important bit is that we are binding it to the existing <code>:comments<\/code>.<\/p>\n<p>Note Ecto 3.0 chose to introduce an explicit naming mechanism via the <code>:as<\/code> option, instead of relying on the variable names, as the variable names could lead to accidental clashing, especially as developers may shortcut the variable names to single letters in queries. Furthermore, if there is an attempt to bind to the same name more than once, an error will be raised.<\/p>\n<p>Finally, keep in mind that the <code>as<\/code> option can also be given to <code>from<\/code>, for instance:<\/p>\n<pre><code>query =\n  from p in Post,\n    as: :posts,\n    join: c in Comment,\n    as: :comments,\n    where: p.id == c.post_id,\n    select: c\n<\/code><\/pre>\n<p>Named bindings will make Ecto much more flexible for building dynamic queries, as usually seen in complex search forms, search APIs and more. The bulk of the work was done by <a href=\"https:\/\/github.com\/zoldar\">Adrian Gruntkowski<\/a>. You can read <a href=\"https:\/\/github.com\/elixir-ecto\/ecto\/issues\/2389\">on the proposal and the following discussion<\/a> in the issues tracker.<\/p>\n<h2>Database prefixes and index hints<\/h2>\n<p>We have two new functionalities on top of the foundation we created to add named bindings to Ecto: per from\/join prefixes and index hints.<\/p>\n<p>Ecto v2.0 introduced the idea of prefixes. What the prefix means depends on the database engine. For Postgres, the prefix translates to a Postgres Schema. A database in Postgres has multiple schemas and the default schema is called &#8220;public&#8221;. MySQL does not support schemas, therefore the prefix functionality in MySQL simply translates to different databases.<\/p>\n<p>When Ecto v2.0 introduced prefixes, the goal was to make it straightforward to select, insert, update and delete data from different prefixes. The goal was to support multi-tenant applications. However, Ecto v2.0 was limited to only work on a single prefix at a time. For example, it was not possible to write a query that would join data across two different prefixes.<\/p>\n<p>Ecto v3.0 lifts this restriction by allowing the <code>prefix<\/code> option to be given to <code>from<\/code>\/<code>join<\/code>, in the same way we could pass the <code>as<\/code> option. For example, imagine that you have a system where all of the posts are public but the comments are specific to each client using the system. Therefore, you have multiple prefixes in the system, one for each client, and each prefix has its own &#8220;comments&#8221; table. You can now query across those prefixes as follows:<\/p>\n<pre><code>from p in Post,\n  prefix: \"public\",\n  join: c in Comment,\n  prefix: \"client1\",\n  where: p.id == c.post_id,\n  select: c\n<\/code><\/pre>\n<p>Similarly, Ecto 3.0 relies on a similar API to support the use of index hints, as found in <a href=\"https:\/\/dev.mysql.com\/doc\/refman\/8.0\/en\/index-hints.html\">MySQL<\/a> and <a href=\"https:\/\/docs.microsoft.com\/en-us\/sql\/t-sql\/queries\/hints-transact-sql-table?view=sql-server-2017\">MSSQL<\/a> databases:<\/p>\n<pre><code>from p in Post,\n  join: c in Comment,\n  hints: [\"USE INDEX FOO\", \"USE INDEX BAR\"],\n  where: p.id == c.post_id,\n  select: c\n<\/code><\/pre>\n<p>Keep in mind you want to use hints rarely, so don&#8217;t forget to read the database disclaimers about such functionality.<\/p>\n<p>The prefix and hints options brings more flexibility to developers to structure and optimize their queries, allowing them to leverage Ecto.Query as much as possible, without having to fallback to SQL.<\/p>\n<h2>Other changes<\/h2>\n<p>Ecto.Query now supports tuples in <code>where<\/code> and <code>having<\/code>, allowing queries such as <code>where: {p.foo, p.bar} &gt; {^foo, ^bar}<\/code> which can be used for <a href=\"https:\/\/www.sitepoint.com\/paginating-real-time-data-cursor-based-pagination\/\">cursor-based pagination<\/a>.<\/p>\n<p>We have also added support for arithmetic operators, such as <code>+<\/code>, <code>-<\/code>, <code>*<\/code>, <code>\/<\/code>. Note those operators just delegate to the underlying database engine, so remember to check your database to see what are the possible types of the operands.<\/p>\n<p>Finally, it is now possible to invoke database functions that expect the whole table\/source as argument, by using fragments: <code>fragment(\"some_function(?)\", p)<\/code>.<\/p>\n<p>This is it for now! If you have any questions about the features above, feel free to use the comments section below or search for the relevant discussion in Ecto&#8217;s issues tracker. Next week we will be back with further improvements and features added to Ecto.Query in Ecto 3.0.<\/p>\n<p><a href=\"https:\/\/pages.plataformatec.com.br\/elixir-development-subscription\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-large wp-image-7816\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png\" alt=\"banner-elixir development subscription\" width=\"1024\" height=\"213\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png 1024w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-300x63.png 300w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-768x160.png 768w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1.png 1200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Welcome to the &#8220;A sneak peek at Ecto 3.0&#8221; series: Breaking changes Query improvements part 1 (you are here!) Query improvements part 2 Performance, migrations and more Let&#8217;s get started with the improvements to Ecto.Query APIs. The Ecto.Query API is the area that saw most improvements in Ecto 3.0, to the point we won&#8217;t be &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-1\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7825"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=7825"}],"version-history":[{"count":11,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7825\/revisions"}],"predecessor-version":[{"id":7881,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7825\/revisions\/7881"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=7825"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=7825"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=7825"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}