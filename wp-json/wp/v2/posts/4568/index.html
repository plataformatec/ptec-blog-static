{"id":4568,"date":"2015-05-11T09:00:05","date_gmt":"2015-05-11T12:00:05","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=4568"},"modified":"2015-06-01T12:22:12","modified_gmt":"2015-06-01T15:22:12","slug":"nobody-told-me-minitest-was-this-fun","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2015\/05\/nobody-told-me-minitest-was-this-fun\/","title":{"rendered":"Nobody told me Minitest was this fun"},"content":{"rendered":"<p>Ever since I started working with Ruby I have been using RSpec to test my apps and gems without giving minitest much thought. Recently I started a new non-Rails project and decided to give Minitest a try just for the fun of it. Migrating from one tool to another was refreshingly fun due to the fact that that Minitest and RSpec aren&#8217;t so different from each other &#8211; they both have the basic features that we need in a testing library to get things running, and if you are used to testing your code moving from one to the other might not be so scary as you might expect.<\/p>\n<h2>Translating testing idioms<\/h2>\n<p>One of the first things that I looked into was how some of common RSpec idioms should be implemented when using Minitest.<\/p>\n<p>The classic ones are fairly simple: the <code>before<\/code> and <code>after<\/code> lifecycle hooks should be equivalent as implementing the <code>setup<\/code> and <code>teardown<\/code> methods in your test class, and you have control over the inheritance chain by selecting when\/where to call <code>super<\/code>. <code>let<\/code> and <code>subject<\/code> can be achieved with methods that use memoization to cache their values.<\/p>\n<pre><code class=\"ruby\"># A classic RSpec subject\/before usage.\nrequire 'spec_helper'\n\ndescribe Post do\n  subject(:post) { Post.new }\n  before { post.publish! }\nend\n\n# The equivalent with Minitest &amp; Ruby.\nrequire 'test_helper'\n\nclass PostTest &lt; Minitest::Test\n  def post\n    @post ||= Post.new\n  end\n\n  def setup\n    post.publish!\n  end\nend\n<\/code><\/pre>\n<p>RSpec shared examples, where you can reuse a set of examples across your test suite, can be replicated by simply writing your tests in modules and depend on accessor methods to inject any objects your tests might depend on<\/p>\n<pre><code class=\"ruby\"># What used to be a shared_examples 'Serialization' can be a module...\nmodule SerializationTests\n  def serializer\n    raise NotImplementedError\n  end\nend\n\n# And your test cases can include that module to copy the tests\nclass JSONSerializationTest &lt; Minitest::Test\n  include SerializationTests\n\n  def serializer\n    JSON\n  end\nend\n\nclass MarshalSerializationTest &lt; Minitest::Test\n  include SerializationTests\n\n  def serializer\n    Marshal\n  end\nend\n<\/code><\/pre>\n<p>Mocks and stubs, which are incredibly flexible when using RSpec, are available in Minitest without any third party gem:<\/p>\n<pre><code class=\"ruby\">class PostTest &lt; Minitest::Test\n  def test_notifies_on_publish\n    notifier = Minitest::Mock.new\n    notifier.expect :notify!, true\n\n    post.publish!(notifier: notifier)\n    notifier.verify\n  end\n\n  def test_does_not_notifies_on_republish\n    notifier = Minitest::Mock.new\n\n    post.stub :published?, true do\n      post.publish!(notifier: notifier)\n      notifier.verify\n    end\n  end\nend\n<\/code><\/pre>\n<p>If you want a different or more fluent API, you can use something like <a href=\"https:\/\/github.com\/freerange\/mocha\"><code>mocha<\/code><\/a> to improve your mocks, or even bring RSpec API into the mix &#8211; with some manual setup you can pick the <a href=\"https:\/\/github.com\/rspec\/rspec-mocks\"><code>rspec-mocks<\/code><\/a> gem and define your mocks and stubs just like when using the complete RSpec tooling:<\/p>\n<pre><code class=\"ruby\">require 'rspec\/mocks'\n\nclass PostTest &lt; Minitest::Test\n  include ::RSpec::Mocks::ExampleMethods\n\n  def before_setup\n    ::RSpec::Mocks.setup\n    super\n  end\n\n  def after_teardown\n    super\n    ::RSpec::Mocks.verify\n  ensure\n    ::RSpec::Mocks.teardown\n  end\n\n  def test_notifies_on_publish\n    notifier = double('A notifier')\n    expect(notifier).to receive(:notify!)\n\n    post.publish!(notifier: notifier)\n  end\nend\n<\/code><\/pre>\n<h2>Know your assertions<\/h2>\n<p>One of my favorite parts of RSpec is how expressive the assertions can be &#8211; from the Ruby code that we have to write to the errors that the test runner will emit when something is broken. One might think that we can have something similar when working with Minitest, but that is not exactly true.<\/p>\n<p>Let&#8217;s say we want to test a method like <code>Post#active?<\/code>. Using a dynamic matcher from RSpec like <code>expect(post).to be_active<\/code> will produce a very straightforward message when that assertion fails: <code>expected #&lt;Post: \u2026&gt;.active? to return false, got true<\/code>.<\/p>\n<p>With Minitest, we might be tempted to write an assertion like <code>assert !post.active?<\/code>, but then the failure message wouldn&#8217;t be much useful for us: <code>Failed assertion, no message given<\/code>. But fear not, because for something like this we have the <code>assert_predicate<\/code> and <code>refute_predicate<\/code> assertions, and they can produce very straightforward failure messages like <code>Expected #&lt;Post:\u2026&gt; to not be active?.<\/code>, which clearly explains what went wrong with our tests.<\/p>\n<p>Besides the predicate assertions, we have a few other assertion methods that can useful instead of playing with the plain <code>assert<\/code> method: <code>assert_includes<\/code>, <code>assert_same<\/code>, <code>assert_operator<\/code> and so on &#8211; and every one of those has a <code>refute_<\/code> counterpart for negative assertions.<\/p>\n<p>It&#8217;s always a matter of checking the documentation &#8211; The <a href=\"http:\/\/docs.seattlerb.org\/minitest\/Minitest\/Assertions.html\"><code>Minitest::Assertions<\/code> module<\/a> explains all the default assertions that you use with Minitest.<\/p>\n<p>And in the case where you want to write a new assertion, you can always mimic how the built-in assertions are written to write your own:<\/p>\n<pre><code class=\"ruby\">module ActiveModelAssertions\n  def assert_valid(model, msg = nil)\n    msg = message(msg) { \"Expected #{model} to be valid, but got errors: #{errors}.\" }\n    valid = model.valid?\n    errors = model.errors.full_messages.join(', ')\n    assert valid, msg\n  end\nend\n\nclass PostTest &lt; Minitest::Test\n  include ActiveModelAssertions\n\n  def test_post_validations\n    post = Post.new(title: 'The Post')\n    assert_valid post\n  end\nend\n<\/code><\/pre>\n<h2>Active Support goodies<\/h2>\n<p>If you want some extra sugar in your tests, you can bring some of extensions that Active Support has for Minitest that are available when working with Rails &#8211; a more declarative API, some extra assertions, time traveling and anything else that Rails might bring to the table.<\/p>\n<pre><code class=\"ruby\">require 'active_support'\nrequire 'active_support\/test_case'\nrequire 'minitest\/autorun'\n\nActiveSupport.test_order = :random\n\nclass PostTest &lt; ActiveSupport::TestCase\n  # setup' and teardown' can be blocks,\n  # like RSpec before' and after'.\n  setup do\n    @post = Post.new\n  end\n\n  # 'test' is a declarative way to define\n  # test methods.\n  test 'deactivating a post' do\n    @post.deactivate!\n    refute_predicate @post, :active?\n  end\nend\n<\/code><\/pre>\n<h2>Tweaking the toolchain<\/h2>\n<p>Minitest simplicity might not be so great when it comes to the default spec runner and reporter, which lack some of my favorite parts of RSpec &#8211; the verbose and colored output, the handful of command line flags or the report on failures that get the command to run a single failure test. But on the good side, even though Minitest does not ship with some of those features by default, there are a great number of gems that can help our test suite to be more verbose and friendly whenever we need to fix a failing test.<\/p>\n<p>For instance, with the <a href=\"https:\/\/rubygems.org\/gems\/minitest-reporters\">minitest-reporters<\/a> gem you can bring some color to your tests output or make it compatible with RubyMine and TeamCity. You can use reporters that are compatible with JUnit or RubyMine if that&#8217;s your thing. You can use <a href=\"https:\/\/rubygems.org\/gems\/minitest-fail-fast\">minitest-fail-fast<\/a> to bring the <code>--fail-fast<\/code> flag from RSpec and exit your test suite as soon as a test fails. Or you can track down object allocations in your tests using <a href=\"https:\/\/rubygems.org\/gems\/minitest-gcstats\">minitest-gcstats<\/a>.<\/p>\n<p>If any of those gems aren&#8217;t exactly the setup you want it, you can always mix it up a bit and <a href=\"https:\/\/rubygems.org\/gems\/minitest-utils\">roll your own gem<\/a> with reporters, helpers and improvements that are suitable for the way you write your tests.<\/p>\n<p>Thanks to this extensibility, Rails 5 will bring some improvements to how you run the tests in your app to improve the overall testing experience with Rails (be sure to check <a href=\"https:\/\/github.com\/rails\/rails\/pull\/19216\">this Pull Request<\/a> and the improvements from other Pull Requests).<\/p>\n<div style=\"padding:40px 0 20px;\">\n<a href=\"http:\/\/blog.plataformatec.com.br\/subscribe\/\"><img decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2014\/11\/subscribe-to-our-blog.png\" alt=\"Subscribe to our blog\" style=\"border:none;\" \/><\/a>\n<\/div>\n","protected":false},"excerpt":{"rendered":"<p>Ever since I started working with Ruby I have been using RSpec to test my apps and gems without giving minitest much thought. Recently I started a new non-Rails project and decided to give Minitest a try just for the fun of it. Migrating from one tool to another was refreshingly fun due to the &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2015\/05\/nobody-told-me-minitest-was-this-fun\/\">\u00bb<\/a><\/p>\n","protected":false},"author":17,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[237,60,96],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4568"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/17"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=4568"}],"version-history":[{"count":13,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4568\/revisions"}],"predecessor-version":[{"id":4578,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4568\/revisions\/4578"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=4568"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=4568"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=4568"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}