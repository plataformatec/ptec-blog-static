{"id":426,"date":"2009-11-17T14:40:09","date_gmt":"2009-11-17T17:40:09","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=426"},"modified":"2010-04-22T14:57:19","modified_gmt":"2010-04-22T17:57:19","slug":"understanding-devise-roles","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2009\/11\/understanding-devise-roles\/","title":{"rendered":"Understanding Devise roles"},"content":{"rendered":"<p>After <a href=\"http:\/\/blog.plataformatec.com.br\/2009\/10\/devise-flexible-authentication-solution-for-rails\/\">Devise was released<\/a>, there were some misunderstandings about <a href=\"http:\/\/github.com\/plataformatec\/devise\">Devise<\/a> roles and how to use it. And the best way to understand it is explaining which problem we wanted to solve when we designing Devise.<\/p>\n<p>In most applications developed at <a href=\"http:\/\/plataformatec.com.br\/en\/\">Plataforma<\/a>, we usually have two actors: one which represents the client who hired us and another which is the end-user, the audience of the developed app.<\/p>\n<p>Before Devise, we used Authlogic or Clearance as authentication solutions. Authlogic does not say anything about controllers, so we usually had two models (Admin and User) and some controllers to handle sign in, password reset and so forth for each model, which required expressive effort to handle and maintain.<\/p>\n<p>On the other hand, we had Clearance. Clearance deals completely with the User model, but we needed to work on the Admin model almost from scratch.<\/p>\n<p>With Devise, we can have a full stack solution for both User and Admin. But that only works if User and Admin does not need to share a lot of responsibilities.<\/p>\n<p>For instance, if you are working on a blogging system with different roles as &#8220;editor&#8221;, &#8220;author&#8221; and &#8220;contributor&#8221;, but they all share a lot of activities in common, as writing a post, handling such roles with Devise can add a great of complexity to your code, mainly because you will need to use Single Table Inheritance (STI) and\/or polymorphic relationships very frequently.<\/p>\n<p>To handle such cases, you can use <a href=\"http:\/\/www.ruby-toolbox.com\/categories\/rails_authorization.html\">any of the authorization libraries out there for Rails<\/a> (remember that Devise is mainly an <strong>authentication<\/strong> tool).<\/p>\n<h3>Scoped authentication<\/h3>\n<p>On the same line, there were some requests to provide authentication by username, instead of e-mail, or providing a subdomain as scope for the authentication. You can now do that using <a href=\"http:\/\/github.com\/plataformatec\/devise\">Devise 0.5.1 or higher<\/a> by just setting the authentication keys in your model:<\/p>\n<pre lang=\"ruby\">\r\nclass User < ActiveRecord::Base\r\n devise :all, :authentication_keys => [ :username, :subdomain ]\r\nend\r\n<\/pre>\n<p>Now you user needs an username and subdomain to authenticate and their respective value should be sent as parameters when signing in. Such values are converted to conditions when retrieving the user from the database for authentication. For example, the following path with query string:<\/p>\n<pre>\r\n\/users\/sign_in?user[username]=josevalim&user[subdomain]=plataformatec\r\n<\/pre>\n<p>Is converted to the following query with ActiveRecord:<\/p>\n<pre lang=\"ruby\">\r\nUser.first(:conditions => { :username => \"josevalim\", :subdomain => \"plataformatec\" })\r\n<\/pre>\n<p>And only after retrieving the user we check for password validity. However, keep in mind that those conditions are used only when signing in. If an user is already authenticated, it will be retrieved from session, where such conditions are not used. In other words, you still need a filter in your controllers to verify that the user accessing a given subdomain, is really allowed to access that subdomain.<\/p>\n<p>Such configuration should handle most of the cases, but if you still need more customization, you can overwrite three class methods exposed for exactly this purpose: <a href=\"http:\/\/github.com\/plataformatec\/devise\/blob\/05fc5712e35407366c08b1adafad7f6547f1e381\/lib\/devise\/models\/authenticatable.rb#L71\">User.authenticate<\/a>, <a href=\"http:\/\/github.com\/plataformatec\/devise\/blob\/05fc5712e35407366c08b1adafad7f6547f1e381\/lib\/devise\/models\/authenticatable.rb#L89\">User.serialize_into_session<\/a> and <a href=\"http:\/\/github.com\/plataformatec\/devise\/blob\/05fc5712e35407366c08b1adafad7f6547f1e381\/lib\/devise\/models\/authenticatable.rb#L94\">User.serialize_from_session<\/a>.<\/p>\n<p>Enjoy!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>After Devise was released, there were some misunderstandings about Devise roles and how to use it. And the best way to understand it is explaining which problem we wanted to solve when we designing Devise. In most applications developed at Plataforma, we usually have two actors: one which represents the client who hired us and &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2009\/11\/understanding-devise-roles\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[37,47,36,23,7,48],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/426"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=426"}],"version-history":[{"count":10,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/426\/revisions"}],"predecessor-version":[{"id":911,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/426\/revisions\/911"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=426"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=426"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=426"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}