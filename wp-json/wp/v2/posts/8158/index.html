{"id":8158,"date":"2018-12-21T14:36:56","date_gmt":"2018-12-21T16:36:56","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=8158"},"modified":"2019-01-04T18:08:06","modified_gmt":"2019-01-04T20:08:06","slug":"building-a-new-mysql-adapter-for-ecto-part-iii-dbconnection-integration","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-iii-dbconnection-integration\/","title":{"rendered":"Building a new MySQL adapter for Ecto, Part III: DBConnection Integration"},"content":{"rendered":"<p>Welcome to the &#8220;Building a new MySQL adapter for Ecto&#8221; series:<\/p>\n<ul>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/11\/building-a-new-mysql-adapter-for-ecto-part-i-hello-world\/\" target=\"_blank\" rel=\"noopener\">Part I: Hello World<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-ii-encoding-decoding\/\" target=\"_blank\" rel=\"noopener\">Part II: Encoding\/Decoding<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-iii-dbconnection-integration\/\">Part III: DBConnection Integration<\/a> (you&#8217;re here!)<\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2019\/01\/building-a-new-mysql-adapter-for-ecto-part-iv-ecto-integration\/\" target=\"_blank\" rel=\"noopener\">Part IV: Ecto Integration<\/a><\/li>\n<\/ul>\n<p>In the first two articles of the series we have learned the basic building blocks for interacting with a MySQL server using its binary protocol over TCP.<\/p>\n<p>To have a production-quality driver, however, there&#8217;s more work to do. Namely, we need to think about:<\/p>\n<ul>\n<li>maintaining a connection pool to talk to the DB efficiently from multiple processes<\/li>\n<li>not overloading the DB<\/li>\n<li>attempting to re-connect to the DB if connection is lost<\/li>\n<li>supporting common DB features like prepared statements, transactions, and streaming<\/li>\n<\/ul>\n<p>In short, we need: reliability, performance, and first-class support for common DB features. This is where <a href=\"https:\/\/github.com\/elixir-ecto\/db_connection\" target=\"_blank\" rel=\"noopener\">DBConnection<\/a>&nbsp;comes in.<\/p>\n<h2>DBConnection<\/h2>\n<p>DBConnection is a behaviour module for implementing efficient database connection client processes, pools and transactions. It has been created by Elixir and Ecto Core Team member James Fish and has been introduced in Ecto v2.0.<\/p>\n<p>Per <a href=\"https:\/\/hexdocs.pm\/db_connection\/DBConnection.html\" target=\"_blank\" rel=\"noopener\">DBConnection documentation<\/a>&nbsp;we can see how it addresses concerns mentioned above:<\/p>\n<blockquote><p>\n  DBConnection handles callbacks differently to most behaviours. Some callbacks will be called in the calling process, with the state copied to and from the calling process. This is useful when the data for a request is large and means that a calling process can interact with a socket directly.<\/p>\n<p>A side effect of this is that query handling can be written in a simple blocking fashion, while the connection process itself will remain responsive to OTP messages and can enqueue and cancel queued requests.<\/p>\n<p>If a request or series of requests takes too long to handle in the client process a timeout will trigger and the socket can be cleanly disconnected by the connection process.<\/p>\n<p>If a calling process waits too long to start its request it will timeout and its request will be cancelled. This prevents requests building up when the database cannot keep up.<\/p>\n<p>If no requests are received for a period of time the connection will trigger an idle timeout and the database can be pinged to keep the connection alive.<\/p>\n<p>Should the connection be lost, attempts will be made to reconnect with (configurable) exponential random backoff to reconnect. All state is lost when a connection disconnects but the process is reused.<\/p>\n<p>The <code>DBConnection.Query<\/code> protocol provide utility functions so that queries can be prepared or encoded and results decoding without blocking the connection or pool.<\/p><\/blockquote>\n<p>Let&#8217;s see how we can use it!<\/p>\n<h2>DBConnection Integration<\/h2>\n<p>We will first create a module responsible for implementing DBConnection callbacks:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.Protocol do\n  use DBConnection\nend\n<\/code><\/pre>\n<p>When we compile it, we&#8217;ll get a bunch of warnings about callbacks that we haven&#8217;t implemented yet.<\/p>\n<p>Let&#8217;s start with the <a href=\"https:\/\/hexdocs.pm\/db_connection\/DBConnection.html#c:connect\/1\" target=\"_blank\" rel=\"noopener\"><code>connect\/1<\/code><\/a>&nbsp;callback and while at it, add some supporting code:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.Error do\n  defexception [:message]\nend\n\ndefmodule MyXQL.Protocol do\n  @moduledoc false\n  use DBConnection\n  import MyXQL.Messages\n  defstruct [:sock]\n\n  @impl true\n  def connect(opts) do\n    hostname = Keyword.get(opts, :hostname, \"localhost\")\n    port = Keyword.get(opts, :port, 3306)\n    timeout = Keyword.get(opts, :timeout, 5000)\n    username = Keyword.get(opts, :username, System.get_env(\"USER\")) || raise \"username is missing\"\n    sock_opts = [:binary, active: false]\n\n    case :gen_tcp.connect(String.to_charlist(hostname), port, sock_opts) do\n      {:ok, sock} -&gt;\n        handshake(username, timeout, %__MODULE__{sock: sock})\n\n      {:error, reason} -&gt;\n        {:error, %MyXQL.Error{message: \"error when connecting: #{inspect(reason)}\"}}\n\n      err_packet(message: message) -&gt;\n        {:error, %MyXQL.Error{message: \"error when performing handshake: #{message}\"}}\n    end\n  end\n\n  @impl true\n  def checkin(state) do\n    {:ok, state}\n  end\n\n  @impl true\n  def checkout(state) do\n    {:ok, state}\n  end\n\n  @impl true\n  def ping(state) do\n    {:ok, state}\n  end\n\n  defp handshake(username, timeout, state) do\n    with {:ok, data} &lt;- :gen_tcp.recv(state.sock, 0, timeout),\n         initial_handshake_packet() = decode_initial_handshake_packet(data),\n         data = encode_handshake_response_packet(username),\n         :ok &lt;- :gen_tcp.send(state.sock, data),\n         {:ok, data} &lt;- :gen_tcp.recv(state.sock, 0, timeout),\n         ok_packet() &lt;- decode_handshake_response_packet(data) do \n      {:ok, sock}\n    end\n  end\nend\n\ndefmodule MyXQL do\n  @moduledoc \"...\"\n\n  @doc \"...\"\n  def start_link(opts) do \n    DBConnection.start_link(MyXQL.Protocol, opts)\n  end\nend\n<\/code><\/pre>\n<p>That&#8217;s a lot to unpack so let&#8217;s break this down:<\/p>\n<ul>\n<li>per documentation, <code>connect\/1<\/code> must return <code>{:ok, state}<\/code> on success and <code>{:error, exception}<\/code> on failure. Our connection state for now will be just the socket. (In a complete driver we&#8217;d use the state to manage prepared transaction references, status of transaction etc.) On error, we return an exception.<\/li>\n<li>we extract configuration from keyword list <code>opts<\/code> and provide sane defaults * we try to connect to the TCP server and if successful, perform the handshake.<\/li>\n<li>as we&#8217;ve learned in part I, the handshake goes like this: after connecting to the socket, we receive the &#8220;Initial Handshake Packet&#8221;. Then, we send &#8220;Handshake Response&#8221; packet. At the end, we receive the response and decode the result which can be an &#8220;OK Pacet&#8221; or an &#8220;ERR Packet&#8221;. If we receive any socket errors, we ignore them for now. We&#8217;ll talk about handling them better later on.<\/li>\n<li>finally, we introduce a public <code>MyXQL.start_link\/1<\/code> that is an entry point to the driver<\/li>\n<li>we also provide minimal implementations for <code>checkin\/1<\/code>, <code>checkout\/1<\/code> and <code>ping\/1<\/code> callbacks<\/li>\n<\/ul>\n<p>It&#8217;s worth taking a step back at looking at our overall design:<\/p>\n<ul>\n<li><code>MyXQL<\/code> module exposes a small public API and calls into an internal module<\/li>\n<li><code>MyXQL.Protocol<\/code> implements <code>DBConnection<\/code> behaviour and is the place where all side-effects are being handled<\/li>\n<li><code>MyXQL.Messages<\/code> implements pure functions for encoding and decoding packets This separation is really important. By keeping protocol <em>data<\/em> separate from protocol <em>interactions<\/em> code we have a codebase that&#8217;s much easier to understand and maintain.<\/li>\n<\/ul>\n<h2>Prepared Statements<\/h2>\n<p>Let&#8217;s take a look at <code>handle_prepare\/3<\/code> and <code>handle_execute\/4<\/code> callbacks that are used to<br \/>\nhandle prepared statements:<\/p>\n<pre><code>iex&gt; b DBConnection.handle_prepare\n@callback handle_prepare(query(), opts :: Keyword.t(), state :: any()) ::\n            {:ok, query(), new_state :: any()}\n            | {:error | :disconnect, Exception.t(), new_state :: any()}\n\nPrepare a query with the database. Return {:ok, query, state} where query is a\nquery to pass to execute\/4 or close\/3, {:error, exception, state} to return an\nerror and continue or {:disconnect, exception, state} to return an error and\ndisconnect.\n\nThis callback is intended for cases where the state of a connection is needed\nto prepare a query and\/or the query can be saved in the database to call later.\n\nThis callback is called in the client process.\n<\/code><\/pre>\n<pre><code>iex&gt; b DBConnection.handle_execute\n@callback handle_execute(query(), params(), opts :: Keyword.t(), state :: any()) ::\n            {:ok, query(), result(), new_state :: any()}\n            | {:error | :disconnect, Exception.t(), new_state :: any()}\n\nExecute a query prepared by c:handle_prepare\/3. Return {:ok, query, result,\nstate} to return altered query query and result result and continue, {:error,\nexception, state} to return an error and continue or {:disconnect, exception,\nstate} to return an error and disconnect.\n\nThis callback is called in the client process.\n<\/code><\/pre>\n<p>Notice the callbacks reference types like: <code>query()<\/code>, <code>result()<\/code> and <code>params()<\/code>.<br \/>\nLet&#8217;s take a look at them too:<\/p>\n<pre><code>iex&gt; t DBConnection.result\n@type result() :: any()\n\niex&gt; t DBConnection.params\n@type params() :: any()\n\niex&gt; t DBConnection.query\n@type query() :: DBConnection.Query.t()\n<\/code><\/pre>\n<p>As far as DBConnection is concerned, <code>result()<\/code> and <code>params()<\/code> can be any term (it&#8217;s up to us to define these) and the <code>query()<\/code> must implement the <a href=\"https:\/\/hexdocs.pm\/db_connection\/DBConnection.Query.html\"><code>DBConnection.Query<\/code><\/a> protocol.<\/p>\n<p><code>DBConnection.Query<\/code> is used for preparing queries, encoding their params, and decoding their<br \/>\nresults. Let&#8217;s define query and result structs as well as minimal protocol implementation.<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.Result do\n  defstruct [:columns, :rows]\nend\n\ndefmodule MyXQL.Query do\n  defstruct [:statement, :statement_id]\n\n  defimpl DBConnection.Query do\n    def parse(query, _opts), do: query\n\n    def describe(query, _opts), do: query\n\n    def encode(_query, params, _opts), do: params\n\n    def decode(_query, result, _opts), do: result\n  end\nend\n<\/code><\/pre>\n<p>Let&#8217;s define the first callback, <code>handle_prepare\/3<\/code>:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.Protocol do\n  # ...\n\n  @impl true\n  def handle_prepare(%MyXQL.Query{statement: statement}, _opts, state) do\n    data = encode_com_stmt_prepare(query.statement)\n\n    with :ok &lt;- sock_send(data, state),\n         {:ok, data} &lt;- sock_recv(state),\n         com_stmt_prepare_ok(statement_id: statement_id) &lt;- decode_com_stmt_prepare_response(data) do\n      query = %{query | statement_id: statement_id}\n      {:ok, query, state}\n    else\n      err_packet(message: message) -&gt;\n        {:error, %MyXQL.Error{message: \"error when preparing query: #{message}\"}, state}\n\n      {:error, reason} -&gt;\n        {:disconnect, %MyXQL.Error{message: \"error when preparing query: #{inspect(reason)}\"}, state}\n    end\n  end\n\n  defp sock_send(data, state), do: :gen_tcp.recv(state.sock, data, :infinity)\n\n  defp sock_recv(state), do: :gen_tcp.recv(state.sock, :infinity)\nend\n<\/code><\/pre>\n<p>The callback receives <code>query<\/code>, <code>opts<\/code> (which we ignore), and <code>state<\/code>. We encode the query statement into <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/com-stmt-prepare.html\"><code>COM_STMT_PREPARE<\/code><\/a> packet, send it, receive response, decode the <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/com-stmt-prepare-response.html\"><code>COM_STMT_PREPARE Response<\/code><\/a>, and put the retrieved <code>statement_id<\/code> into our query struct.<\/p>\n<p>If we receive an <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/packet-ERR_Packet.html\"><code>ERR Packet<\/code><\/a>, we put the error message into our <code>MyXQL.Error<\/code> exception and return that.<\/p>\n<p>The only places that we could get <code>{:error, reason}<\/code> tuple is we could get it from are the <code>gen_tcp.send,recv<\/code> calls &#8211; if we get an error there it means there might be something wrong with the socket. By returning <code>{:disconnect, _, _}<\/code>, DBConnection will take care of closing the socket and will attempt to re-connect with a new one.<\/p>\n<p>Note, we set <code>timeout<\/code> to <code>:infinity<\/code> on our send\/recv calls. That&#8217;s because DBConnection is managing the process these calls will be executed in and it maintains it&#8217;s own timeouts. (And if we hit these timeouts, it cleans up the socket automatically.)<\/p>\n<p>Let&#8217;s now define the <code>handle_execute\/4<\/code> callback:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.Protocol do\n  # ...\n\n  @impl true\n  def handle_execute(%{statement_id: statement_id} = query, params, _opts, state)\n      when is_integer(statement_id) do\n    data = encode_com_stmt_execute(statement_id, params)\n\n    with :ok &lt;- sock_send(state, data),\n         {:ok, data} &lt;- sock_recv(state),\n         resultset(columns: columns, rows: rows) = decode_com_stmt_execute_response() do\n      columns = Enum.map(columns, &amp;column_definition(&amp;1, :name))\n      result = %MyXQL.Result{columns: columns, rows: rows}\n      {:ok, query, result, state}\n    else\n      err_packet(message: message) -&gt;\n        {:error, %MyXQL.Error{message: \"error when preparing query: #{message}\"}, state}\n\n      {:error, reason} -&gt;\n        {:disconnect, %MyXQL.Error{message: \"error when preparing query: #{inspect(reason)}\"}, state}\n    end\n  end\nend\n\ndefmodule MyXQL.Messages do\n  # ...\n\n  # https:\/\/dev.mysql.com\/doc\/internals\/en\/com-query-response.html#packet-ProtocolText::Resultset\n  defrecord :resultset, [:column_count, :columns, :row_count, :rows, :warning_count, :status_flags]\n\n  def decode_com_stmt_prepare_response(data) do\n    # ...\n    resultset(...)\n  end\n\n  # https:\/\/dev.mysql.com\/doc\/internals\/en\/com-query-response.html#packet-Protocol::ColumnDefinition41\n  defrecord :column_definition, [:name, :type]\nend\n<\/code><\/pre>\n<p>Let&#8217;s break this down.<\/p>\n<p><code>handle_execute\/4<\/code> receives an already prepared query, <code>params<\/code> to encode, opts, and the state.<\/p>\n<p>Similarly to <code>handle_prepare\/3<\/code>, we encode the <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/com-stmt-execute.html\" target=\"_blank\" rel=\"noopener\"><code>COM_STMT_EXECUTE<\/code><\/a>&nbsp;packet, send it and receive a response, decode <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/com-stmt-execute-response.html\" target=\"_blank\" rel=\"noopener\"><code>COM_STMT_EXECUTE Response<\/code><\/a>, into a <code>resultset<\/code> record, and finally build the result struct.<\/p>\n<p>Same as last time, if we get an <code>ERR Packet<\/code> we return an <code>{:error, _, _}<\/code> response; on socket problems, we simply disconnect and let DBConnection handle re-connecting at later time.<\/p>\n<p>We&#8217;ve mentioned that the <code>DBConnection.Query<\/code> protocol is used to prepare queries, and in fact we could perform encoding of params and decoding the result in implementation functions. We&#8217;ve left that part out for brevity.<\/p>\n<p>Finally, let&#8217;s add a public function that users of the driver will use:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL do\n  # ...\n\n  def prepare_execute(conn, statement, params, opts) do\n    query = %MyXQL.Query{statement: statement}\n    DBConnection.prepare_execute(conn, query, params, opts)\n  end\nend\n<\/code><\/pre>\n<p>and see it all working.<\/p>\n<pre><code class=\"elixir\">iex&gt; {:ok, pid} = MyXQL.start_link([])\niex&gt; MyXQL.prepare_execute(pid, \"SELECT ?\", [42], [])\n{:ok, %MyXQL.Query{statement: \"SELECT ? + ?\", statement_id: 1},\n%MyXQL.Result{columns: [\"? + ?\"], rows: [[5]]}}\n<\/code><\/pre>\n<p>Arguments to <code>MyXQL.start_link<\/code> are passed down to<br \/>\n<a href=\"https:\/\/hexdocs.pm\/db_connection\/DBConnection.html#start_link\/2\" target=\"_blank\" rel=\"noopener\"><code>DBConnection.start_link\/2<\/code><\/a>,<br \/>\nso starting a pool of 2 connections is as simple as:<\/p>\n<pre><code class=\"elixir\">iex&gt; {:ok, pid} = MyXQL.start_link(pool_size: 2)\n<\/code><\/pre>\n<h2>Conclusion<\/h2>\n<p>In this article, we&#8217;ve seen a sneak peek of integration with the DBConnection library. It gave us<br \/>\nmany benefits:<\/p>\n<ul>\n<li>a battle-tested connection pool without writing a single line of pooling code<\/li>\n<li>we can use blocking <code>:gen_tcp<\/code> functions without worrying about OTP messages and timeouts;<br \/>\nDBConnection will handle these<\/li>\n<li>automatic re-connection, backoff etc<\/li>\n<li>a way to structure our code<\/li>\n<\/ul>\n<p>With this, we&#8217;re almost done with our adapter series. In the final article we&#8217;ll use our driver as an Ecto adapter. Stay tuned!<\/p>\n<p><a href=\"https:\/\/pages.plataformatec.com.br\/elixir-development-subscription\" target=\"_blank\" rel=\"noopener\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-8124 size-full\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1.png\" alt=\"\" width=\"1024\" height=\"213\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1.png 1024w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1-300x62.png 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1-768x160.png 768w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Welcome to the &#8220;Building a new MySQL adapter for Ecto&#8221; series: Part I: Hello World Part II: Encoding\/Decoding Part III: DBConnection Integration (you&#8217;re here!) Part IV: Ecto Integration In the first two articles of the series we have learned the basic building blocks for interacting with a MySQL server using its binary protocol over TCP. &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-iii-dbconnection-integration\/\">\u00bb<\/a><\/p>\n","protected":false},"author":70,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8158"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/70"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=8158"}],"version-history":[{"count":31,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8158\/revisions"}],"predecessor-version":[{"id":8336,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8158\/revisions\/8336"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=8158"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=8158"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=8158"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}