{"id":7491,"date":"2018-05-07T14:08:17","date_gmt":"2018-05-07T17:08:17","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=7491"},"modified":"2018-05-07T18:29:17","modified_gmt":"2018-05-07T21:29:17","slug":"setting-up-rails-with-webpacker-react-and-jest","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2018\/05\/setting-up-rails-with-webpacker-react-and-jest\/","title":{"rendered":"Setting up Rails with Webpack(er), React and Jest."},"content":{"rendered":"<h1>Setting up Rails with Webpack(er), React and Jest.<\/h1>\n<h2>An opinionated and straightforward way.<\/h2>\n<p>This article has a clear purpose: present a quick and easy way to setup Rails + Webpacker + React + Jest. So if your team is considering, or has already decided, to use React, this is the right article for you. The open source community went through a long journey of features to bring Rails and modern Javascript together. You&#8217;ll see that combining React with Rails is easier than ever.<\/p>\n<p>We need to make two concepts very clear before we start. There are two names that look similar, but they are NOT the same. <code>Webpack<\/code> and <code>Webpacker<\/code>. Webpack is a javascript bundler and task runner that runs on top of Node.js and thanks to its amazing community, there are a lot of modules to add features to it without or with little specific knowledge and configuration. Webpacker is a ruby gem created by the Rails Core Team to integrate Webpack to the Rails asset pipeline. So that means Webpacker is a way to have the Webpack functionality within a Rails application.<\/p>\n<p>Let&#8217;s get started!<\/p>\n<h3>Rails setup<\/h3>\n<p>In this section we will create a new Rails application to be used in the example. If you already have an Rails app, you can skip to <a href=\"#add-webpacker-gem-and-react\">Add Webpacker Gem and React<\/a>.<\/p>\n<p>Create a new Rails application by running:<\/p>\n<pre><code class=\"shell\">$ rails new rails_app --skip-coffee --skip-javascript\n<\/code><\/pre>\n<p>A folder called <code>rails_app<\/code> will be created. It is worth mentioning that you could add a flag <code>--webpack=react<\/code> and it would skip some steps, but in my experience, most of the projects will, or at least should, add React in a later development stage.<\/p>\n<pre><code class=\"shell\">$ cd rails_app\n<\/code><\/pre>\n<p>Prepare your database by running these commands:<\/p>\n<pre><code class=\"shell\">$ bin\/rails db:setup\n<\/code><\/pre>\n<p>Let&#8217;s create a view to put our React app later on.<\/p>\n<pre><code class=\"shell\">$ bin\/rails generate controller home\n$ touch app\/views\/home\/index.html.erb\n<\/code><\/pre>\n<p>Inside <code>config\/routes.rb<\/code> set the root to <code>home#index<\/code>.<\/p>\n<pre><code class=\"ruby\"># on config\/routes.rb\n\nRails.application.routes.draw do\n  root to: 'home#index'\nend\n<\/code><\/pre>\n<p>Place any content inside <code>app\/views\/home\/index.html.erb<\/code> and run <code>$ rails server<\/code>. Now you can visit <code>localhost:3000<\/code> and see your view&#8217;s content there. The <code>index<\/code> will be used to render the React component.<\/p>\n<p>Great! Now we have a running webserver and should be ready to go to the next section.<\/p>\n<h3>Add Webpacker Gem and React<\/h3>\n<p>At this point we have a view, in which we will render a React component. Now, it is time to add Webpacker which will integrate files generated by Webpack to the Rails assets. As the &#8220;Rails doctrine&#8221; says <a href=\"http:\/\/rubyonrails.org\/doctrine\/#convention-over-configuration\">convention over configuration<\/a>, Webpacker add Webpack and configure it so you can start hacking.<\/p>\n<p><em>Note: If you are doing this in an existing application, Webpacker can operate alongside sprockets. You should discuss with your team whether you should migrate your assets to Webpack or not, according to your context.<\/em><\/p>\n<p>Go to <code>Gemfile<\/code> and add the Webpacker gem.<\/p>\n<pre><code class=\"ruby\"># on Gemfile\n\ngem 'webpacker'\n<\/code><\/pre>\n<p>Run the command to install:<\/p>\n<pre><code class=\"shell\">$ bundle install\n<\/code><\/pre>\n<p>With the gem installed we need to run the task to setup React and Webpack with Rails. To do that, you need to have Yarn installed. You can follow this <a href=\"https:\/\/yarnpkg.com\/lang\/en\/docs\/install\/\">guide<\/a>.<\/p>\n<pre><code class=\"shell\">$ bin\/rails webpacker:install\n$ bin\/rails webpacker:install:react\n<\/code><\/pre>\n<p>Go to <code>app\/views\/home\/index.html.erb<\/code> and add the <code>hello_react<\/code> import.<\/p>\n<pre><code class=\"erb\">\/* anywhere in app\/views\/index.html.erb *\/\n\n&lt;%= javascript_pack_tag 'hello_react' %&gt;\n<\/code><\/pre>\n<p>Go to <a href=\"http:\/\/localhost:3000\">localhost:3000<\/a> and it should show <code>Hello React!<\/code><\/p>\n<p>All right, React and Webpack are all set and ready to go! However, we are not fully done yet. The reason behind React existing in the first place, is that UI can be very complex and even though React(and other frameworks) tries to simplify it, we still have to create a lot of logic in an React application. To ensure that our components are working correctly we need to test them!<\/p>\n<h3>Add Jest<\/h3>\n<p>In this section we will add Jest, a test framework, created by the Facebook team, the same team behind React. You can use other test library, but I chose Jest because of its syntax that relates to RSpec, works with all major javascript libraries, provides a good bundle of utilities, and the setup is simpler.<\/p>\n<p>We need to add Jest with Yarn because now we are using the javascript ecosystem.<\/p>\n<pre><code class=\"shell\">$ yarn add --dev jest babel-jest babel-preset-es2015\n<\/code><\/pre>\n<p>Jest has many configurations, but we want to keep it as short as possible, since the defaults are pretty good. But there are two items that you need do adapt in order for it to work nicely with Rails.<\/p>\n<p>The <code>moduleDirectories<\/code> configuration indicates where to find modules. I think it&#8217;s useful to add the Rails javascript folder to the <code>moduleDirectories<\/code> configuration because it will be easier to import the files to be tested. For example, use the following directory structures:<\/p>\n<pre><code>app\n| - javascript\n| | - packs\n| | | - index.js\n...\nspec\n| - javascript\n| | - packs\n| | | - index.spec.js\n<\/code><\/pre>\n<p>Without <code>moduleDirectories<\/code> configuration, to import <code>app\/javascript\/packs\/index.js<\/code> in <code>spec\/javascript\/packs\/index.spec.js<\/code>, you&#8217;ll need to configure the import using a relative path that will look like this: <code>..\/..\/..\/app\/javascript\/packs\/index.js<\/code>. It&#8217;s very painful to maintain relative paths in a long-term project, especially when you need to rename directories and move files.<br \/>\nAs it is suggested by <a href=\"https:\/\/twitter.com\/kylefox\">Kyle Fox<\/a> <a href=\"https:\/\/medium.com\/@kylefox\/how-to-setup-javascript-testing-in-rails-5-1-with-webpacker-and-jest-ef7130a4c08e\">here<\/a>, add <code>app\/javascript<\/code> to the modules directory of Jest. Then you can use only <code>packs\/index.js<\/code> to import from <code>index.spec.js<\/code>.<\/p>\n<p>The root configuration indicates the directory of your tests file.<br \/>\nJest will look for files to run and will match the files with <code>*spec.js<\/code> or <code>*test.js<\/code>, so it is important to set the root for Jest otherwise it will try to run <code>test.js<\/code> on <code>config\/webpack<\/code> as a test. I will use <code>spec\/javascript<\/code> because I like the RSpec folder organization, but you can change to any folder you want.<\/p>\n<p>Add to your <code>package.json<\/code> the custom Jest configuration.<\/p>\n<pre><code class=\"json\">\/* On your package.json *\/\n\n\"jest\": {\n  \"roots\": [\n    \"spec\/javascript\"\n  ],\n  \"moduleDirectories\": [\n    \"node_modules\",\n    \"app\/javascript\"\n  ]\n}\n<\/code><\/pre>\n<p>On your <code>.babelrc<\/code>, add the <code>es2015<\/code> preset to ensure your ES6 is working fine throughout you app and your tests.<\/p>\n<pre><code class=\"json\">\/* On your .babelrc *\/\n\n{\n  \"presets\": [\n    \"es2015\",\n    ...\n  ]\n}\n<\/code><\/pre>\n<p>You can try run <code>yarn jest<\/code>, but it will fail. You don&#8217;t have any test yet, so, let&#8217;s create one. We&#8217;re going to test a React component generated by Webpacker, we will talk about it soon. We need to add the <code>enzyme<\/code> library to render React components in the test environment. We need to add an adapter together with Enzyme to render our React components. Run the following command:<\/p>\n<pre><code class=\"shell\">$ yarn add --dev enzyme enzyme-adapter-react-16\n<\/code><\/pre>\n<p>Please, notice that the adapter&#8217;s version depends on the version of react that you are using.<\/p>\n<p>Now, to setup enzyme and its adapter we will create a file to setup the tests, and you can add other configurations like setup Mocha and Chai.<\/p>\n<pre><code class=\"shell\">$ touch spec\/javascript\/setupTests.js\n<\/code><\/pre>\n<p>Inside <code>setupTests.js<\/code> put:<\/p>\n<pre><code class=\"js\">\/* On spec\/javascript\/setupTests.js *\/\n\nimport Enzyme from 'enzyme'\nimport EnzymeAdapter from 'enzyme-adapter-react-16'\n\nEnzyme.configure({ adapter: new EnzymeAdapter() })\n<\/code><\/pre>\n<p>Add the setup path to Jest:<\/p>\n<pre><code class=\"json\">\/* On your .babelrc *\/\n\n\"jest\": {\n  \"roots\": [\n    \"spec\/javascript\"\n  ],\n  \"moduleDirectories\": [\n    \"node_modules\",\n    \"app\/javascript\"\n  ],\n  \"setupTestFrameworkScriptFile\": \".\/spec\/javascript\/setupTests.js\"\n}\n<\/code><\/pre>\n<p>Ok, now we have Jest ready to go, with <code>enzyme<\/code> to render our components. We can go to the next section to create tests for our component.<\/p>\n<h3>Testing with Jest + Enzyme<\/h3>\n<p>Now it is time to dive into Jest tests and ensure that the component behave like we expect. We will import the <code>hello_react<\/code> component and test it by rendering and checking its content.<\/p>\n<p>The component created by Webpacker looks something like this:<\/p>\n<pre><code class=\"js\"><br \/>\/* On app\/javascript\/packs\/hello_react.jsx *\/\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport PropTypes from 'prop-types'\n\nconst Hello = props =&gt; (\n\n\n<div>Hello {props.name}!<\/div>\n\n\n)\n\nHello.defaultProps = {\n  name: 'David'\n}\n\nHello.propTypes = {\n  name: PropTypes.string\n}\n\ndocument.addEventListener('DOMContentLoaded', () =&gt; {\n  ReactDOM.render(\n    &lt;Hello name=\"React\" \/&gt;,\n    document.body.appendChild(document.createElement('div')),\n  )\n})\n\n<\/code><\/pre>\n<p>Add at the end of the file the following line to export the component. We can only test exported components in our Jest test files.<\/p>\n<pre><code class=\"js\">\/* Add at the end of app\/javascript\/packs\/hello_react.jsx *\/\n\nexport default Hello\n<\/code><\/pre>\n<p>I won&#8217;t go in depth on how React works, let&#8217;s play along with that component. The component should render a <code>div<\/code> with <code>Hello {name}!<\/code> inside. So, lets create a test for that.<\/p>\n<pre><code class=\"shell\">$ touch spec\/javascript\/packs\/hello_react.spec.js\n<\/code><\/pre>\n<p>Open the test file with your favorite text editor. We need to import the component, Enzyme, and React in order to render the component.<\/p>\n<pre><code class=\"js\">\/* On spec\/javascript\/packs\/hello_react.spec.js *\/\n\nimport React from 'react'\nimport { shallow } from 'enzyme'\nimport HelloReact from 'packs\/hello_react'\n<\/code><\/pre>\n<p>Please notice that we have imported only <code>shallow<\/code> from <code>enzyme<\/code>. <code>shallow<\/code> improves the test performance by only rendering the component and its children, and it prevents rendering the entire DOM tree. However, you might need other rendering types, in this case, check the <a href=\"http:\/\/airbnb.io\/enzyme\/docs\/api\/\">Enzyme&#8217;s documentation<\/a>.<\/p>\n<p>Let&#8217;s describe the component and create an expectation of having <code>Hello David!<\/code> or any other name we pass to the <code>HelloReact<\/code> component.<\/p>\n<pre><code class=\"js\">\/* On spec\/javascript\/packs\/hello_react.spec.js *\/\n\ndescribe('HelloReact component', () =&gt; {\n  describe('when a name is given as a prop', () =&gt; {\n    it('render Hello Caique!', () =&gt; {\n      expect(shallow().text()).toBe('Hello Caique!')\n    })\n  })\n\n  describe('when no name is given', () =&gt; {\n    it('render Hello David!', () =&gt; {\n      expect(shallow().text()).toBe('Hello David!')\n    })\n  })\n})\n<\/code><\/pre>\n<p>Next run <code>$ yarn test<\/code> to see if the tests were successful and that&#8217;s it.<\/p>\n<p>Now you have a full Rails + React + tests setup. To extend that setup you could add Redux to manage state or Mocha\/Chai to test, but either way, from now on it is just a matter of following documentation to add the frameworks as any Yarn + Webpack setup, then Webpacker should run without hassle. If you have any question about this tutorial, feel free to leave a comment below.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Setting up Rails with Webpack(er), React and Jest. An opinionated and straightforward way. This article has a clear purpose: present a quick and easy way to setup Rails + Webpacker + React + Jest. So if your team is considering, or has already decided, to use React, this is the right article for you. The &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2018\/05\/setting-up-rails-with-webpacker-react-and-jest\/\">\u00bb<\/a><\/p>\n","protected":false},"author":68,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7491"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/68"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=7491"}],"version-history":[{"count":13,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7491\/revisions"}],"predecessor-version":[{"id":7502,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7491\/revisions\/7502"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=7491"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=7491"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=7491"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}