{"id":5493,"date":"2016-07-06T17:02:33","date_gmt":"2016-07-06T20:02:33","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5493"},"modified":"2017-01-31T08:22:31","modified_gmt":"2017-01-31T10:22:31","slug":"understanding-deps-and-applications-in-your-mixfile","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/07\/understanding-deps-and-applications-in-your-mixfile\/","title":{"rendered":"Understanding deps and applications in your Mixfile"},"content":{"rendered":"<p><strong>Note<\/strong>: Elixir v1.4 has been released and improves on many points touched by this article. From v1.4, Elixir will automatically infer the list of applications based on your dependencies. For more information, <a href=\"http:\/\/elixir-lang.org\/blog\/2017\/01\/05\/elixir-v1-4-0-released\/\">read the official announcement<\/a>.<\/p>\n<p>In my journey as a curious Elixir developer, I&#8217;ve come across this seemingly simple question a few times: which <code>applications<\/code> from third-party libraries do I need to declare in my <code>mix.exs<\/code> file?<\/p>\n<p>Before we get down to the nitty-gritty of application dependencies, let&#8217;s first recap some basics of the initialization process in Elixir OTP applications.<\/p>\n<p>In its essence, an OTP application is a reusable software component, consisting of multiple modules of its own and it can also depend on third-party code. These dependencies can be either <em>library applications<\/em> \u2014 a collection of standalone modules and functions, with no processes involved \u2014 or <em>active applications<\/em>, with their own life cycles and supervision trees. This distinction is quite subtle, it took me a while to fully grasp its implications.<\/p>\n<p>Applications are defined with an <em>application resource file<\/em>, like <code>my_app.app<\/code>, which is a metadata file comprised of a single Erlang term. It includes all the information needed to start our application and is managed by Mix. If you want to dig deeper into that topic you can take a look at its <a href=\"http:\/\/erlang.org\/doc\/design_principles\/applications.html\" target=\"_blank\">documentation<\/a>. Once we create a new application with <code>mix new my_app<\/code> a brand new <code>mix.exs<\/code> file is generated. This is the file that customizes how <code>my_app.app<\/code> will be assembled by Mix and it is the file we&#8217;ll be dealing with in the Elixir world. Here is what it looks like:<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :my_app,\n     version: \"0.1.0\",\n     elixir: \"~&gt; 1.3\",\n     build_embedded: Mix.env == :prod,\n     start_permanent: Mix.env == :prod,\n     deps: deps()]\n  end\n\n  # Configuration for the OTP application\n  #\n  # Type \"mix help compile.app\" for more information\n  def application do\n    [applications: [:logger]]\n  end\n\n  # Dependencies can be Hex packages:\n  #\n  #   {:mydep, \"~&gt; 0.3.0\"}\n  #\n  # Or git\/path repositories:\n  #\n  #   {:mydep, git: \"https:\/\/github.com\/elixir-lang\/mydep.git\", tag: \"0.1.0\"}\n  #\n  # Type \"mix help deps\" for more examples and options\n  defp deps do\n    []\n  end\nend\n<\/code><\/pre>\n<p>As we can see, there are some important pieces of information in it, such as the app name, version, Elixir version requirements and so on. In addition, the <code>application<\/code> function lets us explain what is required to boot our application: which other applications need to be started before ours, locally registered processes, which module represents the starting point of our application and also some default values for the application environment. By running <code>mix help compile.app<\/code> we can get more information about that function. The <a href=\"http:\/\/elixir-lang.org\/docs\/stable\/elixir\/Application.html\" target=\"_blank\">docs<\/a>  available for the <code>Application<\/code> behavior \u2014 which abstracts the initialization process <em>per se<\/em> \u2014 are pretty extensive and helpful as well.<\/p>\n<p>So far, so good. Now things start to get interesting. Let&#8217;s take a look at the <code>mix.exs<\/code> file of a new Phoenix project. First we generate an application skeleton with <code>mix phoenix.new hello<\/code>, then we add <code>{:exrm, \"~&gt; 1.0\"}<\/code> to our <code>deps<\/code>, including the <a href=\"https:\/\/github.com\/bitwalker\/exrm\" target=\"_blank\">Exrm<\/a> tool for generating our releases.<\/p>\n<pre><code class=\"elixir\">defmodule Hello.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :hello,\n     version: \"0.0.1\",\n     elixir: \"~&gt; 1.3\",\n     # ...\n     deps: deps()]\n  end\n\n  # Configuration for the OTP application.\n  #\n  # Type `mix help compile.app` for more information.\n  def application do\n    [mod: {Hello, []},\n     applications: [:phoenix, :phoenix_pubsub, :phoenix_html, :cowboy, :logger, :gettext,\n                    :phoenix_ecto, :postgrex]]\n  end\n\n  # ...\n\n  defp deps do\n    [{:phoenix, \"~&gt; 1.2.0\"},\n     {:phoenix_pubsub, \"~&gt; 1.0\"},\n     {:phoenix_ecto, \"~&gt; 3.0\"},\n     {:postgrex, \"&gt;= 0.0.0\"},\n     {:phoenix_html, \"~&gt; 2.6\"},\n     {:phoenix_live_reload, \"~&gt; 1.0\", only: :dev},\n     {:gettext, \"~&gt; 0.11\"},\n     {:cowboy, \"~&gt; 1.0\"},\n     {:exrm, \"~&gt; 1.0\"}]\n  end\n\n  # ...\nend\n<\/code><\/pre>\n<p>Along with the <code>:logger<\/code> application we&#8217;ve seen before in our vanilla Elixir app, now we have a few other applications we depend upon: some from Phoenix itself, an HTTP server, some <em>i18n<\/em> utilities and a database driver too. If we pay close attention to the <code>deps<\/code> and the <code>applications<\/code> lists, we can see it is almost a 1 to 1 ratio. Every <code>application<\/code> relates to its <code>dep<\/code> counterpart, like <code>cowboy<\/code>, <code>phoenix_pubsub<\/code>, <code>postgrex<\/code> and others. The exceptions are <code>:logger<\/code>, which is <a href=\"http:\/\/elixir-lang.org\/docs\/stable\/logger\/Logger.html\" target=\"_blank\">pre-built as part of Elixir<\/a>, <code>exrm<\/code> and <code>phoenix_live_reload<\/code>.<\/p>\n<p>That mismatch confused me. I wondered if I wasn&#8217;t mixing them up (pun intended).<\/p>\n<h3>Library applications must be included too<\/h3>\n<p>Why should library-only applications like <code>phoenix_html<\/code> and <code>gettext<\/code> be included in my <code>application<\/code> function then? It&#8217;s not that they need to be booted up and start spawning processes or something. It turns out that our <code>application<\/code> function has more to do with <em>Releases<\/em> and runtime than with supervision trees. Yes, listing <em>active applications<\/em> ensures they are started before our application, but including <em>library applications<\/em> will also <strong>make sure they will be included<\/strong> in our installable release packages.<\/p>\n<p>To support that claim, we can see that even <code>exrm<\/code> warns us when we forget to do so. Let&#8217;s try removing <code>phoenix_html<\/code> and <code>cowboy<\/code> from our <code>applications<\/code>:<\/p>\n<pre><code class=\"elixir\">defmodule Hello.Mixfile do\n  # ...\n  def application do\n    [mod: {Hello, []},\n     applications: [:phoenix, :phoenix_pubsub, :logger, :gettext, :phoenix_ecto, :postgrex]]\n  end\nend\n<\/code><\/pre>\n<p>Then make a new release:<\/p>\n<pre><code>mix deps.get\nRunning dependency resolution\n* Getting phoenix (Hex package)\n  Checking package (https:\/\/repo.hex.pm\/tarballs\/phoenix-1.2.0.tar)\n  Using locally cached package\n...\n\nMIX_ENV=prod mix release\nBuilding release with MIX_ENV=prod.\n\nYou have dependencies (direct\/transitive) which are not in :applications!\nThe following apps should be added to :applications in mix.exs:\n\n        phoenix_html =&gt; phoenix_html is missing from hello\n        cowboy       =&gt; cowboy is missing from hello\n\nContinue anyway? Your release may not work as expected if these dependencies are required! [Yn]:\n<\/code><\/pre>\n<p>Both dependencies would be missing from the final package :bomb:. We certainly don&#8217;t want that.<\/p>\n<h3>Development, test, docs and optional dependencies stay out<\/h3>\n<p>You might still ask, shouldn&#8217;t <code>cowboy<\/code> and <code>phoenix_html<\/code> be out of my control and get required automatically by <code>phoenix<\/code>? That way I&#8217;d just need to worry about <code>phoenix<\/code> as a single, rich dependency.<\/p>\n<p>Actually, no. From the Phoenix framework standpoint, none of these applications are actually required. Cowboy isn&#8217;t a strict runtime dependency; we can freely run our Phoenix app on another compatible web server of our choice. As for Phoenix HTML and even Gettext, they are not strictly required either. We can totally build our Phoenix app without any HTML output or localization at all, consider an API-only app for example. It&#8217;s all up to us.<\/p>\n<p>As we can see in <a href=\"https:\/\/github.com\/phoenixframework\/phoenix\/blob\/v1.2.0\/mix.exs#L41-L55\" target=\"_blank\">Phoenix&#8217;s own <code>mix.exs<\/code> file<\/a>, <code>cowboy<\/code> is declared as <code>optional: true<\/code> and <code>phoenix_html<\/code> as <code>only: :test<\/code>, <code>gettext<\/code> likewise is <code>only: :test<\/code>. The reason these dependencies are declared is that if we eventually need them in <strong>our<\/strong> app, they must be at least compatible with the Phoenix version currently in use.<\/p>\n<p>That also explains why <code>exrm<\/code> and <code>phoenix_live_reload<\/code> can be kept out of the applications list. We don&#8217;t want <code>phoenix_live_reload<\/code> running in production, since there will be no live code reloading. As for <code>exrm<\/code>, it is a tool used exclusively to package our application, our business code has no need to know anything about it.<\/p>\n<p>Cool. How come <code>phoenix_live_reload<\/code> works in development though? Well, when we start our application \u2014 with <code>mix phoenix.start<\/code>, for example \u2014 the code is available in the load path, but the <code>phoenix_live_reload<\/code> application is not started yet; it only starts when <a href=\"https:\/\/github.com\/phoenixframework\/phoenix_live_reload\/blob\/v1.0.5\/lib\/phoenix_live_reload\/channel.ex#L10\" target=\"_blank\">we connect to its channel<\/a>. We can try it out by starting up our little Phoenix app and checking which applications get loaded.<\/p>\n<pre><code>iex -S mix phoenix.start\nErlang\/OTP 18 [erts-7.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\n[info] Running Hello.Endpoint with Cowboy using http:\/\/localhost:4000\nInteractive Elixir (1.3.0) - press Ctrl+C to exit (type h() ENTER for help)\niex(1)&gt; Application.loaded_applications\n[\n  {:plug, 'A specification and conveniences for composable modules between web applications', '1.1.6'},\n  {:hex, 'hex', '0.12.1'},\n  ...\n]\n<\/code><\/pre>\n<p>A list of all the applications currently loaded is returned when we call <code>Application.loaded_applications<\/code>. Now, after we make our first request by opening <code>http:\/\/localhost:4000<\/code> then calling <code>Application.loaded_applications<\/code> once again, we can see two new applications on that list: <code>fs<\/code> and <code>phoenix_live_reload<\/code>.<\/p>\n<pre><code>iex(2)&gt; Application.loaded_applications\n[\n  {:plug, 'A specification and conveniences for composable modules between web applications', '1.1.6'},\n  {:hex, 'hex', '0.12.1'},\n  ...\n  {:fs, 'VXZ FS Listener', '0.9.1'},\n  ...\n  {:phoenix_live_reload, 'Provides live-reload functionality for Phoenix',  '1.0.5'}\n  ...\n]\n<\/code><\/pre>\n<h3>Declare your applications, even when you&#8217;re not using releases<\/h3>\n<p>I am deploying to Heroku and my application requires no release packaging whatsoever, should I still worry about my list of applications? Yes, definitely. Suppose we need to upgrade some dependencies, one of them used to be just a <em>library application<\/em> but now has become an <em>active application<\/em>, e.g. a cache library which now has to keep a reaper process to clean up stale data. Once we upgrade the <code>dep<\/code> for that undeclared <code>application<\/code>, a runtime bug is potentially introduced, given we have no guarantee our new dependencies&#8217; applications will get started properly.<\/p>\n<h3>As a library author, you should take extra care<\/h3>\n<p>The same goes for libraries, regardless of open sourcing them or not. Remember that runtime application dependencies are transitive. Let&#8217;s say an application <code>A<\/code> depends on <code>B<\/code>, which in turn depends on <code>C<\/code>, the application responsible for ensuring <code>C<\/code> is started is <code>B<\/code>, unless <code>C<\/code> is an optional dependency. In that case, the author of <code>B<\/code> should document the pluggable nature of that optional dependency appropriately, or even provide code generators if applicable \u2014 as Phoenix does with <code>cowboy<\/code>.<\/p>\n<h3>Elixir tooling is our friend<\/h3>\n<p>One of the most noticeable benefits of Elixir is all the tools-support built around it. Not only in runtime, <a href=\"http:\/\/erlang.org\/doc\/man\/runtime_tools_app.html\" target=\"_blank\">standing<\/a> on the <a href=\"http:\/\/erlang.org\/doc\/man\/Observer_app.html\" target=\"_blank\">shoulders<\/a> of Erlang, but primarily in development and build time. In case you overlooked the <a href=\"http:\/\/elixir-lang.org\/blog\/2016\/06\/21\/elixir-v1-3-0-released\/#mix-apptree-and-depstree\" target=\"_blank\">announcement of Elixir v1.3<\/a> recently released, you should definitely check it out. Among the improvements in dependency tracking are two new built-in mix tasks: <code>app.tree<\/code> and <code>deps.tree<\/code>. They are priceless timesavers in this routine task of keeping up with our dependencies.<\/p>\n<h3>Summing up<\/h3>\n<p>So, when we are evaluating these dependency issues individually, it all boils down to a few simple criteria.<\/p>\n<p>For the <code>deps<\/code> function in our Mixfile:<\/p>\n<ul>\n<li>Always add it to <code>deps<\/code> if it is a <strong>direct<\/strong> dependency.<\/li>\n<li>Don&#8217;t forget the <code>only: [...]<\/code> option if not every environment needs it.<\/li>\n<li>Optional dependencies must be set as <code>optional: true<\/code>. It is always good to document and explain how they are supposed to be included.<\/li>\n<\/ul>\n<p>For the <code>applications<\/code> key in our <code>application<\/code> function:<\/p>\n<ul>\n<li>Add it to <code>applications<\/code> if it is required at <strong>runtime<\/strong> in <strong>production<\/strong>.<\/li>\n<\/ul>\n<p>All said and done, where can we go from here? Well, I&#8217;d say start at home, <strong>review your <code>mix.exs<\/code><\/strong>. Is there anything important missing? Any unused dependency? Then you can start taking a closer look at your external dependencies&#8217; Mixfiles. Are all runtime dependencies properly required? What about their environments? Once you&#8217;re there, take your time to contribute, give back. These tiny bits might seem worthless at first, but rest assured, as some clever man used to say, \u201csuccess is in the details\u201d.<\/p>\n<div style=\"height:30px;\"><\/div>\n<hr>\n<div style=\"margin:20px 0 60px;\">\n<p style=\"text-align:center; margin-bottom:0; padding-bottom:0; font-weight:bold; font-size:1em; color:#444;\">If you are into Elixir-Phoenix, you may also like&#8230;<\/p>\n<p><a href=\"http:\/\/pages.plataformatec.com.br\/ebook-whats-new-in-ecto-2-0?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=ebook-ecto-2-0&amp;utm_content=cta-blog-post-bottom-with-title\" target=\"_blank\"><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0.jpg\" alt=\"What&#039;s new in Ecto 2.0 -- Download your copy\" width=\"831\" height=\"147\" class=\"aligncenter size-full wp-image-5997\" \/<\/a srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0.jpg 831w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0-300x53.jpg 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0-768x136.jpg 768w\" sizes=\"(max-width: 831px) 100vw, 831px\" \/>\n<\/div>\n","protected":false},"excerpt":{"rendered":"<p>Note: Elixir v1.4 has been released and improves on many points touched by this article. From v1.4, Elixir will automatically infer the list of applications based on your dependencies. For more information, read the official announcement. In my journey as a curious Elixir developer, I&#8217;ve come across this seemingly simple question a few times: which &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/07\/understanding-deps-and-applications-in-your-mixfile\/\">\u00bb<\/a><\/p>\n","protected":false},"author":14,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[143,245],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5493"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/14"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5493"}],"version-history":[{"count":23,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5493\/revisions"}],"predecessor-version":[{"id":6061,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5493\/revisions\/6061"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5493"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5493"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5493"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}