{"id":49,"date":"2009-08-07T15:35:20","date_gmt":"2009-08-07T18:35:20","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=49"},"modified":"2014-03-24T18:46:46","modified_gmt":"2014-03-24T21:46:46","slug":"embracing-rest-with-mind-body-and-soul","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2009\/08\/embracing-rest-with-mind-body-and-soul\/","title":{"rendered":"Embracing REST with mind, body and soul"},"content":{"rendered":"<p><strong>UPDATE:<\/strong> ActionController::Renderer was renamed to ActionController::Responder, so this post was changed to properly reflect such changes.<\/p>\n<p>About two and a half years ago, resources started to be a first class citizen in Rails when version 1.2 was released and it was all about <a href=\"http:\/\/weblog.rubyonrails.org\/2007\/1\/19\/rails-1-2-rest-admiration-http-lovefest-and-utf-8-celebrations\" target=\"_blank\">RESTful admiration and HTTP Lovefest<\/a>. Since then we&#8217;ve added <em>map.resources<\/em> to our routes, started to use different formats in <em>respond_to<\/em> and really learned how to love all HTTP verbs.<\/p>\n<p>Your application entry point (the router) has become completely RESTful, but it still haven&#8217;t reached ActionPack core. Today we are bringing the missing ingredient: make your controllers more resource aware.<\/p>\n<h3>The first step: respond_with(@resource)<\/h3>\n<p>About one week ago <a href=\"http:\/\/github.com\/rails\/rails\/commit\/09de34ca56598ae5d0302a14715b2a11b6cc9845\" target=\"_blank\">the first step was given<\/a>. We brought Merb&#8217;s provide\/display into Rails, <a href=\"http:\/\/loudthinking.com\/posts\/37-bringing-merbs-providesdisplay-into-rails-3\" target=\"_blank\">just as DHH proposed<\/a>: you can define supported formats at the class level and tell in the instance the resource to be represented by those formats. Let&#8217;s see some code:<\/p>\n<pre lang=\"ruby\">  class UsersController &lt; ApplicationController\r\n    respond_to :html, :xml, :json\r\n\r\n    def index\r\n      @users = User.all\r\n      respond_with(@users)\r\n    end\r\n  end<\/pre>\n<p>It works like this: when a request comes, for example with format xml, it will first search for a template at users\/index.xml. If the template is not available, it tries to render the resource given (in this case, @users) by calling :to_xml on it. Before Rails 3.0, the equivalent to the index action above would be:<\/p>\n<pre lang=\"ruby\">  class UsersController &lt; ApplicationController\r\n    def index\r\n      @users = User.all\r\n      respond_to do |format|\r\n        format.html\r\n        format.xml { render :xml =&gt; @users }\r\n        format.json { render :json =&gt; @users }\r\n      end\r\n    end\r\n  end<\/pre>\n<p>The gain with respond_with introduction is more obvious if you compare index, new and show actions:<\/p>\n<pre lang=\"ruby\">  class UsersController &lt; ApplicationController\r\n    respond_to :html, :xml, :json\r\n\r\n    def index\r\n      @users = User.all\r\n      respond_with(@users)\r\n    end\r\n\r\n    def new\r\n      @user = User.new\r\n      respond_with(@user)\r\n    end\r\n\r\n    def show\r\n      @user = User.find(params[:id])\r\n      respond_with(@user)\r\n    end\r\n  end<\/pre>\n<p>With older version:<\/p>\n<pre lang=\"ruby\">  class UsersController &lt; ApplicationController\r\n    def index\r\n      @users = User.all\r\n      respond_to do |format|\r\n        format.html\r\n        format.xml { render :xml =&gt; @users }\r\n        format.json { render :json =&gt; @users }\r\n      end\r\n    end\r\n\r\n    def new\r\n      @user = User.new\r\n      respond_to do |format|\r\n        format.html\r\n        format.xml { render :xml =&gt; @user }\r\n        format.json { render :json =&gt; @user }\r\n      end\r\n    end\r\n\r\n    def show\r\n      @user = User.find(params[:id])\r\n      respond_to do |format|\r\n        format.html\r\n        format.xml { render :xml =&gt; @user }\r\n        format.json { render :json =&gt; @user }\r\n      end\r\n    end\r\n  end<\/pre>\n<p>However, even if respond_with is full featured (Ryan Daigle has done <a href=\"http:\/\/ryandaigle.com\/articles\/2009\/8\/6\/what-s-new-in-edge-rails-cleaner-restful-controllers-w-respond_with\/\" target=\"_blank\">an excellent job covering all respond_with features<\/a>), it started to show some flaws on create, update and destroy actions. A default create action could be written with respond_with as:<\/p>\n<pre lang=\"ruby\">  def create\r\n    @user = User.new(params[:user])\r\n    if @user.save\r\n      flash[:notice] = \"User was created successfully.\"\r\n      respond_with(@user, :status =&gt; :created, :location =&gt; @user) do |format|\r\n        format.html { redirect_to @user }\r\n      end\r\n    else\r\n      respond_with(@user.errors, :status =&gt; :unprocessable_entity) do |format|\r\n        format.html { render :action =&gt; :new }\r\n      end\r\n    end\r\n  end<\/pre>\n<p>You can notice that:<\/p>\n<ol>\n<li>You have to call respond_with twice;<\/li>\n<li>On the first respond_with, you have to give the location twice. One as a hash and other as parameter to redirect_to;<\/li>\n<li>And by giving a block to respond_with, you focus more on the exception than on the default behavior.<\/li>\n<\/ol>\n<p>Suddenly we realized that respond_with is useful just for GET requests. There was no HTTP Lovefest, it was more like HTTP monotheism.<\/p>\n<h3>2. Second step: Love all<\/h3>\n<p>At this point, we started to ask ourselves: why can&#8217;t respond_with include HTTP verb semantics? Isn&#8217;t that what RESTful is all about?<\/p>\n<p>After <a href=\"http:\/\/github.com\/rails\/rails\/commit\/5b7e81efec649b424037c68a93bddad1bc4e0c23\" target=\"_blank\">this commit<\/a>, we brought all HTTP verbs to respond_with, but only for resourceful formats like xml and json (ie. formats that don&#8217;t need to render a template). Then our create action with POST request could be rewritten as:<\/p>\n<pre lang=\"ruby\">  def create\r\n    @user = User.new(params[:user])\r\n    respond_with(@user) do |format|\r\n      if @user.save\r\n        flash[:notice] = \"User was created successfully.\"\r\n        format.html { redirect_to @user }\r\n      else\r\n        format.html { render :action =&gt; :new }\r\n      end\r\n    end\r\n  end<\/pre>\n<p>Internally, when a xml request happened, respond_with would check the current request method (in this case, POST) and whether the resource has errors or not. Depending on these values, it will render the resource or the resource errors, setting accordingly the status and location headers. Now we just have to worry with non-RESTful requests, like html, mobile and iphone&#8230; (which we call navigational formats).<\/p>\n<p>Personally, I was quite happy with the results at this iteration, since it solves two of the three problems exposed previously. However, Jeremy Kemper and Yehuda Katz wanted more. And they were right, yeah!<\/p>\n<h3>3. Third step: Responder<\/h3>\n<p>In step 2, we were able to abstract POST, PUT and DELETE requests for formats like xml and json, but we still would have to repeat html behavior through all controllers, even if almost all of them behave similarly.<\/p>\n<p>So what we want is a simple way to tell the controller <strong>how to render our resources depending on the format AND HTTP verb<\/strong>. <a href=\"http:\/\/github.com\/rails\/rails\/commit\/aed135d3e261cbee153a35fcfbeb47e2e02b12e4\" target=\"_blank\">In this commit<\/a>, we&#8217;ve added <strong>ActionController::Responder<\/strong>.<\/p>\n<p>By default, ActionController::Responder holds all formats behavior in a method called to_format. It&#8217;s similar to this:<\/p>\n<pre lang=\"ruby\">  def to_format\r\n    return render unless resource.respond_to?(:\"to_#{format}\")\r\n\r\n    if get?\r\n      render format =&gt; resource\r\n    elsif has_errors?\r\n      render format =&gt; resource.errors, :status =&gt; :unprocessable_entity\r\n    elsif post?\r\n      render format =&gt; resource, :status =&gt; :created, :location =&gt; resource\r\n    else\r\n      head :ok\r\n    end\r\n  end<\/pre>\n<p>As you can see, it renders the resource based on the HTTP verb and whether it has errors or not. If some format, like :html, does not fall into the to_format behavior, we just need to define a to_html in ActionController::Responder, which by default is:<\/p>\n<pre lang=\"ruby\">  def to_html\r\n    if get?\r\n      render\r\n    elsif has_errors?\r\n      render :action =&gt; (post? ? :new : :edit)\r\n    else\r\n      redirect_to resource\r\n    end\r\n  end<\/pre>\n<p>As result, you have your resources representation encapsulated in one place. Your controller code just have to send the resource using <strong>respond_with(@resource)<\/strong> and respond_with will call <strong>ActionController::Responder<\/strong> which will know what to do. Our create action (POST request) can then be written as:<\/p>\n<pre lang=\"ruby\">  def create\r\n    @user = User.new(params[:user])\r\n    flash[:notice] = \"User was created successfully.\" if @user.save\r\n    respond_with(@user)\r\n  end<\/pre>\n<p>If you need to change the redirect URL, you can overwrite just the html behavior:<\/p>\n<pre lang=\"ruby\">  def create\r\n    @user = User.new(params[:user])\r\n    flash[:notice] = \"User was created successfully.\" if @user.save\r\n    respond_with(@user) do |format|\r\n      format.html { redirect_to user_confirmation_url }\r\n    end\r\n  end<\/pre>\n<p>On the other hand, if you want to change the redirect url and the Location header for XML and JSON, you can simply give :location as option:<\/p>\n<pre lang=\"ruby\">  def create\r\n    @user = User.new(params[:user])\r\n    flash[:notice] = \"User was created successfully.\" if @user.save\r\n    respond_with(@user, :location =&gt; user_confirmation_url)\r\n  end<\/pre>\n<p>The best of all is that the responder implementation is quite simple and straight-forward, but still powerful. We haven&#8217;t enforced any restriction in the API. Anything that responds to :call can be a responder, so you can create your custom classes or even give procs, fibers and so on.<\/p>\n<p>Embrace REST in your design and enjoy a consistent behavior through all your controllers. Spread the word!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>UPDATE: ActionController::Renderer was renamed to ActionController::Responder, so this post was changed to properly reflect such changes. About two and a half years ago, resources started to be a first class citizen in Rails when version 1.2 was released and it was all about RESTful admiration and HTTP Lovefest. Since then we&#8217;ve added map.resources to our &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2009\/08\/embracing-rest-with-mind-body-and-soul\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[86,7,17,57,18],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/49"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=49"}],"version-history":[{"count":27,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/49\/revisions"}],"predecessor-version":[{"id":3780,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/49\/revisions\/3780"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=49"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=49"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=49"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}