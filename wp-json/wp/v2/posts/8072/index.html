{"id":8072,"date":"2018-12-03T14:07:11","date_gmt":"2018-12-03T16:07:11","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=8072"},"modified":"2019-01-15T15:41:55","modified_gmt":"2019-01-15T17:41:55","slug":"building-a-new-mysql-adapter-for-ecto-part-ii-encoding-decoding","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-ii-encoding-decoding\/","title":{"rendered":"Building a new MySQL adapter for Ecto, Part II: Encoding\/Decoding"},"content":{"rendered":"<p>Welcome to the &#8220;Building a new MySQL adapter for Ecto&#8221; series:<\/p>\n<ul>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/11\/building-a-new-mysql-adapter-for-ecto-part-i-hello-world\/\" target=\"_blank\" rel=\"noopener\">Part I: Hello World<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-ii-encoding-decoding\/\">Part II: Encoding\/Decoding<\/a> (you&#8217;re here!)<\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-iii-dbconnection-integration\/\" target=\"_blank\" rel=\"noopener\">Part III: DBConnection Integration<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2019\/01\/building-a-new-mysql-adapter-for-ecto-part-iv-ecto-integration\/\" target=\"_blank\" rel=\"noopener\">Part IV: Ecto Integration<\/a><\/li>\n<\/ul>\n<p>Last time we briefly looked at encoding and decoding data over MySQL wire protocol. In this article we&#8217;ll dive deeper into that topic, let&#8217;s get started!<\/p>\n<h2>Basic Types<\/h2>\n<p>MySQL protocol has two &#8220;<a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/basic-types.html\" target=\"_blank\" rel=\"noopener\">Basic Data Types<\/a>&#8220;: integers and strings. Within integers we have fixed-length and length-encoded integers.<br \/>\nThe simplest type is <code>int&lt;1&gt;<\/code> which is an integer stored in 1 byte.<\/p>\n<p>To recap, MySQL is using little endianess when encoding\/decoding integers as binaries. Let&#8217;s define a function that takes an <code>int&lt;1&gt;<\/code> from the given binary and returns the rest of the binary:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.Types do\n  def take_int1(data) do\n    &lt;&lt;value::8-little-integer, rest::binary&gt;&gt; = data\n    {value, rest}\n  end\nend\n<\/code><\/pre>\n<pre><code class=\"elixir\">iex&gt; MyXQL.Types.take_int1(&lt;&lt;1, 2, 3&gt;&gt;)\n{1, &lt;&lt;2, 3&gt;&gt;}\n<\/code><\/pre>\n<p>We can generalize this function to accept any fixed-length integer:<\/p>\n<pre><code class=\"elixir\">def take_fixed_length_integer(data, size) do\n  &lt;&lt;value::little-integer-size(size)-unit(8), rest::binary&gt;&gt; = data\n  {value, rest}\nend\n<\/code><\/pre>\n<pre><code class=\"elixir\">iex&gt; MyXQL.Types.take_fixed_length_integer(&lt;&lt;1, 2, 3&gt;&gt;, 2)\n{513, &lt;&lt;3&gt;&gt;}\n<\/code><\/pre>\n<p>(See <a href=\"https:\/\/hexdocs.pm\/elixir\/Kernel.SpecialForms.html#%3C%3C%3E%3E\/1\" target=\"_blank\" rel=\"noopener\"><code>&lt;&lt;&gt;&gt;\/1<\/code><\/a> for more information on bitstrings.)<\/p>\n<p>Decoding a <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/integer.html#length-encoded-integer\" target=\"_blank\" rel=\"noopener\">length-encoded integer<\/a>&nbsp;is slightly more complicated.<br \/>\nBasically, if the first byte value is less than <code>251<\/code>, then it&#8217;s a 1-byte integer; if the first-byte is <code>0xFC<\/code>, then it&#8217;s a 2-byte integer and so on up to a 8-byte integer:<\/p>\n<pre><code class=\"elixir\">def take_length_encoded_int1(&lt;&lt;int::8-little-integer, rest::binary&gt;&gt;) when int &lt; 251, do: {int, rest}\n\ndef take_length_encoded_int2(&lt;&lt;0xFC, int::16-little-integer, rest::binary&gt;&gt;), do: {int, rest}\n\ndef take_length_encoded_int3(&lt;&lt;0xFD, int::24-little-integer, rest::binary&gt;&gt;), do: {int, rest}\n\ndef take_length_encoded_int8(&lt;&lt;0xFE, int::64-little-integer, rest::binary&gt;&gt;), do: {int, rest}\n<\/code><\/pre>\n<pre><code class=\"elixir\">iex&gt; MyXQL.Types.take_length_encoded_int1(&lt;&lt;1, 2, 3&gt;&gt;)\n{1, &lt;&lt;2, 3&gt;&gt;}\n\niex&gt; MyXQL.Types.take_length_encoded_int2(&lt;&lt;0xFC, 1, 2, 3&gt;&gt;)\n{513, &lt;&lt;3&gt;&gt;}\n<\/code><\/pre>\n<p>Can we generalize this function to a single binary pattern match, the same way we did with <code>take_fixed_length_integer\/2<\/code>? Unfortunately we can&#8217;t. Our logic is essentially a <code>case<\/code> with 4 clauses and such cannot be used in pattern matches.<br \/>\nFor this reason, the way we decode data is by reading some bytes, decoding them, and returning the rest of the binary.<\/p>\n<p>It&#8217;s a shame that MySQL doesn&#8217;t encode the <em>size<\/em> of the binary in the first byte because otherwise our decode function could be easily implemented in a single binary pattern match, e.g.:<\/p>\n<pre><code class=\"elixir\">iex&gt; &lt;&lt;size::8, value::little-integer-size(size)-unit(8), rest::binary&gt;&gt; = &lt;&lt;2, 1, 2, 3&gt;&gt;\niex&gt; {value, rest}\n{513, &lt;&lt;3&gt;&gt;}\n<\/code><\/pre>\n<p>In fact, it&#8217;s common for protocols to encode data as <a href=\"https:\/\/en.wikipedia.org\/wiki\/Type-length-value\" target=\"_blank\" rel=\"noopener\">Type-Length-Value (TLV)<\/a>&nbsp;which as you can see above, it&#8217;s very easy to implement with Elixir.<\/p>\n<p>In any case, we can still leverage binary pattern matching in the function head. Here&#8217;s our final <code>take_length_encoded_integer\/1<\/code> function:<\/p>\n<pre><code class=\"elixir\">def take_length_encoded_integer(&lt;&lt;int::8, rest::binary&gt;&gt;) when int &lt; 251, do: {int, rest}\ndef take_length_encoded_integer(&lt;&lt;0xFC, int::int(2), rest::binary&gt;&gt;), do: {int, rest}\ndef take_length_encoded_integer(&lt;&lt;0xFD, int::int(3), rest::binary&gt;&gt;), do: {int, rest}\ndef take_length_encoded_integer(&lt;&lt;0xFE, int::int(8), rest::binary&gt;&gt;), do: {int, rest}\n<\/code><\/pre>\n<p>There&#8217;s one last thing that we can do. Because <code>take_fixed_length_integer\/2<\/code> is so simple and basically uses a single binary pattern match (in particular, it <em>does not<\/em> have a <code>case<\/code> statement), we can replace it with a macro instead. All we need to do is to emit <code>little-integer-size(size)-unit(8)<\/code> AST so that we can use it in a bitstring; that&#8217;s easy:<\/p>\n<pre><code class=\"elixir\">defmacro int(size) do\n  quote do\n    little-integer-size(unquote(size))-unit(8)\n  end\nend\n<\/code><\/pre>\n<p>Because it&#8217;s a macro we need to <code>require<\/code> or <code>import<\/code> it to use it:<\/p>\n<pre><code class=\"elixir\">iex&gt; import MyXQL.Types\n\niex&gt; &lt;&lt;value::int(1), rest::binary&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;\niex&gt; {value, rest}\n{1, &lt;&lt;2, 3&gt;&gt;}\n\niex&gt; &lt;&lt;value::int(2), rest::binary&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;\niex&gt; {value, rest}\n{513, &lt;&lt;3&gt;&gt;}\n<\/code><\/pre>\n<p>A really nice thing about using a macro here is we get encoding for free:<\/p>\n<pre><code class=\"elixir\">iex&gt; &lt;&lt;513::int(2)&gt;&gt;\n&lt;&lt;1, 2&gt;&gt;\n<\/code><\/pre>\n<p>We could write a macro for encoding length-encoded integers (we could even invoke it as <code>513::int(lenenc)<\/code> to mimic the spec, by adjusting <code>int\/1<\/code> macro) but I decided against it as it won&#8217;t be usable in a binary pattern match.<\/p>\n<p>Encoding\/decoding <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/describing-packets.html\" target=\"_blank\" rel=\"noopener\">MySQL strings<\/a>&nbsp;is very similar so we will not be going over that and we&#8217;ll jump into the&nbsp;next section on bit flags. (Sure enough, working with strings would be easy, even in binary pattern matches, if not for an EOF-terminated <code>string&lt;eof&gt;<\/code> and <code>string&lt;lenenc&gt;<\/code> types.)<\/p>\n<h2>Bit Flags<\/h2>\n<p>MySQL provides <a href=\"https:\/\/dev.mysql.com\/doc\/internals\/en\/capability-flags.html#packet-Protocol::CapabilityFlags\" target=\"_blank\" rel=\"noopener\">&#8220;Capability Flags&#8221;<\/a>&nbsp;like:<\/p>\n<pre><code class=\"elixir\">CLIENT_PROTOCOL_41 0x00000200\nCLIENT_SECURE_CONNECTION 0x00008000\nCLIENT_PLUGIN_AUTH 0x00080000\n<\/code><\/pre>\n<p>The idea is we represent a set of capabilities as a single integer on which we can use <code>Bitwise<\/code> operations like: <code>0x00000200 ||| 0x00008000<\/code>, <code>flags &amp;&amp;&amp; 0x00080000<\/code> etc.<\/p>\n<p>We definitely don&#8217;t want to pass these &#8220;magic&#8221; bytes around so we should encapsulate them somehow.<br \/>\nWe could store them as module attributes, e.g.: <code>@client_protocol_41 0x00000200<\/code>; if we mistype the name of the flag, we&#8217;ll get a helpful compiler warning. Using functions, however, gives us a bit more flexibility as we can generate great error messages as well as &#8220;hide&#8221; usage of bitwise operations underneath.<br \/>\nLet&#8217;s implement a function that checks whether given <code>flags<\/code> has a given capability:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.Messages do\n  use Bitwise\n\n  def has_capability_flag?(flags, :client_protocol_41), do: (flags &amp;&amp;&amp; 0x00000200) == 0x00000200\n  def has_capability_flag?(flags, :client_secure_connection), do: (flags &amp;&amp;&amp; 0x00008000) == 0x00008000\n  def has_capability_flag?(flags, :client_plugin_auth), do: (flags &amp;&amp;&amp; 0x00080000) == 0x00080000\n  # ...\nend\n<\/code><\/pre>\n<pre><code class=\"elixir\">iex&gt; MyXQL.Messages.has_capability_flag?(0, :client_protocol_41)\nfalse\niex&gt; MyXQL.Messages.has_capability_flag?(0x00000200, :client_protocol_41)\ntrue\n\niex&gt; MyXQL.Messages.has_capability_flag?(0x00000200, :bad)\n** (FunctionClauseError) no function clause matching in MyXQL.Messages.has_capability_flag?\/2\n\n    The following arguments were given to MyXQL.Messages.has_capability_flag?\/2:\n\n        # 1\n        512\n\n        # 2\n        :bad\n\n    Attempted function clauses (showing 3 out of 3):\n\n        def has_capability_flag?(flags, :client_protocol_41)\n        def has_capability_flag?(flags, :client_secure_connection)\n        def has_capability_flag?(flags, :client_plugin_auth)\n<\/code><\/pre>\n<p>This is a very useful error message, we can see what are all available capabilities. If we want something more customized, all we need to do is define an additional catch-all clause at the end:<\/p>\n<pre><code class=\"elixir\">def has_capability_flag?(flags, other) do\n  raise ...\nend\n<\/code><\/pre>\n<p>and raise an error there. That way we could, for example, implement a &#8220;Did you mean?&#8221; hint.<\/p>\n<p>Last but not least, instead of manually defining each function head by hand, we can use Elixir meta-programming capabilities to define them at compile time:<\/p>\n<pre><code class=\"elixir\">capability_flags = [\n  client_protocol_41: 0x00000200,\n  client_secure_connection: 0x00008000,\n  client_plugin_auth: 0x00080000,\n]\n\nfor {name, value} &lt;- capability_flags do\n  def has_capability_flag?(flags, unquote(name)), do: (flags &amp;&amp;&amp; unquote(value)) == unquote(value)\nend\n<\/code><\/pre>\n<h2>Packets<\/h2>\n<p>Finally, let&#8217;s bring this all together to handle packets. We need a data structure that&#8217;s going to store packet fields and we basically have two options: <a href=\"https:\/\/hexdocs.pm\/elixir\/Kernel.html#defstruct\/1\">structs<\/a> and <a href=\"https:\/\/hexdocs.pm\/elixir\/Record.html\">records<\/a>. Structs are great when data has to be sent between modules, especially because they are polymorphic. However, when the data belongs to a single module, or separate modules that are considered private API, using records may make more sense as they are more space efficient. Let&#8217;s verify that using <code>:erts_debug<\/code> module and instead of comparing structs and records let&#8217;s just compare their internal representations: maps and tuples, respectively:<\/p>\n<pre><code class=\"elixir\">iex&gt; :erts_debug.size(%{x: 1})\n6\niex&gt; :erts_debug.size(%{x: 1, y: 2})\n8\niex&gt; :erts_debug.size(%{x: 1, y: 2, z: 3})\n10\n<\/code><\/pre>\n<pre><code class=\"elixir\">iex&gt; :erts_debug.size({:Point, 1})\n3\niex&gt; :erts_debug.size({:Point, 1, 2})\n4\niex&gt; :erts_debug.size({:Point, 1, 2, 3})\n5\n<\/code><\/pre>\n<p>As you can see, as we add more keys to the map our data structure grows twice as fast and the reason is we store both keys and values whereas tuple stores the size of the tuple once and then just values.<br \/>\nSince we may be processing thousands of packets per second, this difference may add up, so we&#8217;re going to use records here.<\/p>\n<p>The final packet we discussed in the last article was the <code>OK Packet<\/code>. Let&#8217;s now write a function to decode it (it&#8217;s not fully following the spec for brevity):<\/p>\n<pre><code class=\"elixir\"># https:\/\/dev.mysql.com\/doc\/internals\/en\/packet-OK_Packet.html\ndefrecord :ok_packet, [:affected_rows, :last_insert_id, :status_flags, :warning_count]\n\ndef decode_ok_packet(data, capability_flags) do\n  &lt;&lt;0x00, rest::binary&gt;&gt; = data\n\n  {affected_rows, rest} = take_length_encoded_integer(rest)\n  {last_insert_id, rest} = take_length_encoded_integer(rest)\n\n  packet = ok_packet(\n    affected_rows: affected_rows,\n    last_insert_id: last_insert_id\n  )\n\n  if has_capability_flag?(capability_flags, :client_protocol_41) do\n    &lt;&lt;\n      status_flags::int(2),\n      warning_count::int(2)\n    &gt;&gt; = rest\n\n    ok_packet(packet,\n      status_flags: status_flags,\n      warning_count: warning_count\n    )\n  else\n    packet\n  end\nend\n<\/code><\/pre>\n<p>And let&#8217;s test this with the OK packet we got at the end of the last article (<code>00 00 00 02 00 00 00<\/code>):<\/p>\n<pre><code class=\"elixir\">iex&gt; ok_packet(affected_rows: affected_rows) = decode_ok_packet(&lt;&lt;0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00&gt;&gt;, 0x00000200)\niex&gt; affected_rows\n0\n<\/code><\/pre>\n<p>It works!<\/p>\n<h2>Conclusion<\/h2>\n<p>In this article, we discussed encoding and decoding basic data types, handling bit flags, and finally using both of these ideas to decode packets. Using these tools we should be able to fully implement MySQL protocol specification and with examples of <a href=\"http:\/\/erlang.org\/doc\/man\/gen_tcp.html#send-2\" target=\"_blank\" rel=\"noopener\"><code>:gen_tcp.send\/2<\/code><\/a> and <a href=\"http:\/\/erlang.org\/doc\/man\/gen_tcp.html#recv-2\" target=\"_blank\" rel=\"noopener\"><code>:gen_tcp.recv\/2<\/code><\/a> calls from Part I, we could interact with the server. However, that&#8217;s not enough to build a resilient and production-quality driver. For that, we&#8217;ll look into <a href=\"https:\/\/hex.pm\/packages\/db_connection\" target=\"_blank\" rel=\"noopener\"><code>DBConnection<\/code><\/a>&nbsp;integration in Part III. Stay tuned!<\/p>\n<p><a href=\"https:\/\/pages.plataformatec.com.br\/elixir-development-subscription\" target=\"_blank\" rel=\"noopener\"><img loading=\"lazy\" decoding=\"async\" class=\"size-large wp-image-7816 alignnone\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png\" alt=\"banner-elixir development subscription\" width=\"1024\" height=\"213\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png 1024w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-300x63.png 300w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-768x160.png 768w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1.png 1200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Welcome to the &#8220;Building a new MySQL adapter for Ecto&#8221; series: Part I: Hello World Part II: Encoding\/Decoding (you&#8217;re here!) Part III: DBConnection Integration Part IV: Ecto Integration Last time we briefly looked at encoding and decoding data over MySQL wire protocol. In this article we&#8217;ll dive deeper into that topic, let&#8217;s get started! Basic &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-ii-encoding-decoding\/\">\u00bb<\/a><\/p>\n","protected":false},"author":70,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8072"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/70"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=8072"}],"version-history":[{"count":31,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8072\/revisions"}],"predecessor-version":[{"id":8334,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8072\/revisions\/8334"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=8072"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=8072"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=8072"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}