{"id":5315,"date":"2016-04-20T08:54:12","date_gmt":"2016-04-20T11:54:12","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5315"},"modified":"2016-04-19T19:44:49","modified_gmt":"2016-04-19T22:44:49","slug":"ecto-2-0-0-rc-is-out","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/04\/ecto-2-0-0-rc-is-out\/","title":{"rendered":"Ecto 2.0.0-rc is out!"},"content":{"rendered":"<p>We are really glad to announce the release candidate for Ecto 2.0 has been released. The upcoming Ecto version packs many goodies:<\/p>\n<ul>\n<li>We have migrated to DBConnection, which considerably improves the performance of how Ecto manages connections to the database as a whole. Improved pool management, faster encoding\/decoding, support for prepared queries and more;<\/p>\n<\/li>\n<li>\n<p>The effective deprecation of <code>Ecto.Model<\/code> in favor of a more data-oriented approach. With Ecto 2.0, we want developers to focus on using Ecto as a tool instead of being responsible for your domain design;<\/p>\n<\/li>\n<li>\n<p>Support for <code>many_to_many<\/code> associations and a more flexible approach to associations in general, including parallel preloading of associations;<\/p>\n<\/li>\n<li>\n<p>Introduction of a new SQL sandbox that allows developers to run tests that rely on the database concurrently;<\/p>\n<\/li>\n<li>\n<p>Support for subqueries, composite primary keys, <code>insert_all<\/code> (alongside <code>update_all<\/code> and <code>delete_all<\/code>) and more.<\/p>\n<\/li>\n<\/ul>\n<p>There are many more features, bug fixes, and improvements. There are also backwards incompatible changes (hence the 2.0 version). We recommend you to <a href=\"https:\/\/github.com\/elixir-lang\/ecto\/blob\/v2.0.0-rc.1\/CHANGELOG.md\">check the CHANGELOG for more information<\/a>.<\/p>\n<p>We recommend developers to give the release candidate a try. There are only <a href=\"https:\/\/github.com\/elixir-lang\/ecto\/milestones\/v2.0\">a couple of improvements left before the final release<\/a>. In case you encounter an unexpected behaviour, please <a href=\"https:\/\/github.com\/elixir-lang\/ecto\/issues\">open up an issue report<\/a>.<\/p>\n<p>This release supports both MySQL (mariaex) and PostgreSQL (postgrex) adapters.<\/p>\n<h2>Using Ecto 2.0.0-rc with Phoenix<\/h2>\n<p>This release candidate introduced some backwards incompatible changes for those using Ecto in their Phoenix projects. We summarize those changes below:<\/p>\n<ol>\n<li>The first step is to update the <code>Phoenix.Ecto<\/code> dependency to <code>3.0.0-rc<\/code> (which depends on <code>ecto<\/code> <code>2.0.0-rc<\/code>) in your <code>mix.exs<\/code>:\n<pre><code class=\"elixir\">{:phoenix_ecto, \"~&gt; 3.0.0-rc\"}\n<\/code><\/pre>\n<\/li>\n<li>Ecto 2.0 now requires an explicit <code>:ecto_repos<\/code> configuration for running tasks like <code>ecto.migrate<\/code> and others. Open up your <code>config\/config.exs<\/code> and add:\n<pre><code class=\"elixir\">config :my_app, ecto_repos: [MyApp.Repo]\n<\/code><\/pre>\n<\/li>\n<li>We also recommend developers to move the creation and migration of their test databases to aliases. First, remove the following lines from your <code>test\/test_helper.exs<\/code>:\n<pre><code class=\"elixir\">Mix.Task.run \"ecto.create\", ~w(-r &lt;%= application_module %&gt;.Repo --quiet)\nMix.Task.run \"ecto.migrate\", ~w(-r &lt;%= application_module %&gt;.Repo --quiet)\n<\/code><\/pre>\n<p>And now add the following entry to <code>defp aliases<\/code> in your <code>mix.exs<\/code> file:<\/p>\n<pre><code class=\"elixir\">\"test\": [\"ecto.create --quiet\", \"ecto.migrate\", \"test\"]\n<\/code><\/pre>\n<\/li>\n<li>Ecto also changed how it stores changeset in errors. If you are using gettext, you will need to update your <a href=\"https:\/\/github.com\/phoenixframework\/phoenix\/pull\/1649\/files#diff-665e5bb3af466c70d1b34de4399e03cc\"><code>errors.po<\/code> files<\/a> as well as <a href=\"https:\/\/github.com\/phoenixframework\/phoenix\/pull\/1649\/files#diff-54096bbf678a5a4d9a72f4fdb82b2a4d\">your <code>error_helper.ex<\/code> view<\/a><\/p>\n<\/li>\n<li>\n<p>Phoenix projects by default use transactions in the test environment. Ecto 2.0 replaces the test transactions API by the new SQL sandbox. In your <code>test\/test_helper.exs<\/code>, replace the following:<\/p>\n<pre><code class=\"elixir\">Ecto.Adapters.SQL.begin_test_transaction(MyApp.Repo)\n<\/code><\/pre>\n<p>by<\/p>\n<pre><code class=\"elixir\">Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, :manual)\n<\/code><\/pre>\n<p>Then, in each <code>test\/support\/*_case.ex<\/code> file, replace:<\/p>\n<pre><code class=\"elixir\">unless tags[:async] do\n  Ecto.Adapters.SQL.restart_test_transaction(MyApp.Repo, [])\nend\n<\/code><\/pre>\n<p>by<\/p>\n<pre><code class=\"elixir\">:ok = Ecto.Adapters.SQL.Sandbox.checkout(MyApp.Repo)\n\nunless tags[:async] do\n  Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, {:shared, self()})\nend\n<\/code><\/pre>\n<\/li>\n<\/ol>\n<p>That&#8217;s it! You can check <a href=\"https:\/\/github.com\/phoenixframework\/phoenix\/pull\/1649\">the pull request that migrates Phoenix generators to Ecto 2.0-rc<\/a> for a detailed list of changes.<\/p>\n<p>Before we move on, let&#8217;s explore exactly what the sandbox changes mean in the next section.<\/p>\n<h2>Concurrent transactional tests<\/h2>\n<p>In previous versions, Ecto would keep a single connection to the database during tests and wrap the connection inside a transaction for every test. Ecto 2.0 introduces a sandbox mechanism where every test gets its own connection to the database, all of them wrapped in a transaction. Such allows tests to run concurrently by passing <code>async: true<\/code> to <code>use MyApp.ConnCase<\/code> (and similar) even if they rely on the database.<\/p>\n<p>Let&#8217;s further explore the changes we did above. In your test helper, you should now see:<\/p>\n<pre><code class=\"elixir\">Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, :manual)\n<\/code><\/pre>\n<p>This command sets the sandbox to manual mode, meaning any Elixir process must explicitly check a database connection out before performing any database operation. If you open up <code>test\/support\/conn_case.ex<\/code>, you should see:<\/p>\n<pre><code class=\"elixir\">setup tags do\n  :ok = Ecto.Adapters.SQL.Sandbox.checkout(MyApp.Repo)\n\n  unless tags[:async] do\n    Ecto.Adapters.SQL.Sandbox.mode(MyApp.Repo, {:shared, self()})\n  end\n\n  :ok\nend\n<\/code><\/pre>\n<p>The second line in the snippet above does exactly that: it checks a connection out and wraps it inside a transaction. After the connection is checked out, it belongs exclusively to the current test process.<\/p>\n<p>If you enabled <code>async: true<\/code> in your test case, its tests will run concurrently with tests from other test cases, each of them using its own and isolated database connection.<\/p>\n<p>If the test is not asynchronous (<code>:async<\/code> was not set to true), we will execute the <code>unless<\/code> block in <code>setup<\/code> and share the connection we just checked out with all other processes, effectively falling back to the mechanism we had in Ecto 1.0.<\/p>\n<p>The SQL Sandbox provides other options for managing your concurrent tests and <a href=\"https:\/\/hexdocs.pm\/ecto\/2.0.0-rc.1\/Ecto.Adapters.SQL.Sandbox.html\">you can learn more about them in the Ecto documentation<\/a>.<\/p>\n<p>We recommend developers to enable their concurrent tests and enjoy even faster test suites. When doing so, have the following in mind:<\/p>\n<ul>\n<li>MySQL does not support concurrent tests. Unfortunately, MySQL will run into deadlocks when different connections try to write to the same table inside transactions and those transactions are rolled back;<\/p>\n<\/li>\n<li>\n<p>When testing your models, controllers, and views, most of the tests should be able to run concurrently as is, except if they are interacting with other Elixir processes in your application (see example in the next bullet);<\/p>\n<\/li>\n<li>\n<p>On the other hand, your channel tests require the collaboration between two processes: the test process and the channel process itself. If the channel process is accessing the database, you will need to allow explicitly it to use a database connection. See the <a href=\"https:\/\/hexdocs.pm\/ecto\/2.0.0-rc.1\/Ecto.Adapters.SQL.Sandbox.html\"><code>Ecto.Adapters.SQL.Sandbox.allow\/2<\/code> function<\/a>;<\/p>\n<\/li>\n<li>\n<p>Finally, tools for writing acceptance tests like <a href=\"https:\/\/github.com\/HashNuke\/hound\">Hound<\/a> and <a href=\"https:\/\/github.com\/keathley\/wallaby\">Wallaby<\/a> also support concurrent tests. You can find more information about doing so <a href=\"https:\/\/github.com\/phoenixframework\/phoenix_ecto\">in the Phoenix.Ecto README<\/a>.<\/p>\n<\/li>\n<\/ul>\n<h2>Summing up<\/h2>\n<p>We are really excited about Ecto 2.0. By focusing on Ecto as a tool instead of an abstraction layer, we expect developers to have a simpler and a more light-weight mechanism for interacting with databases.<\/p>\n<p>In the upcoming weeks, we will publish a series of blog posts that focuses on the new features and perspectives brought by Ecto 2.0. Meanwhile, don&#8217;t forget to <a href=\"https:\/\/github.com\/elixir-lang\/ecto\/blob\/v2.0.0-rc.1\/CHANGELOG.md\">read the CHANGELOG<\/a> for the full list of changes.<\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=elixir-radar&amp;utm_content=elixir-radar-cta-blog-post-bottom\"><br \/>\n<img decoding=\"async\" style=\"border: 0;\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\" \/><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>We are really glad to announce the release candidate for Ecto 2.0 has been released. The upcoming Ecto version packs many goodies: We have migrated to DBConnection, which considerably improves the performance of how Ecto manages connections to the database as a whole. Improved pool management, faster encoding\/decoding, support for prepared queries and more; The &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/04\/ecto-2-0-0-rc-is-out\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143,245],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5315"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5315"}],"version-history":[{"count":7,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5315\/revisions"}],"predecessor-version":[{"id":5319,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5315\/revisions\/5319"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5315"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5315"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5315"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}