{"id":845,"date":"2010-04-01T13:47:42","date_gmt":"2010-04-01T16:47:42","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=845"},"modified":"2010-04-01T16:43:21","modified_gmt":"2010-04-01T19:43:21","slug":"quick-tip-search-forms","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2010\/04\/quick-tip-search-forms\/","title":{"rendered":"Quick tip: search forms"},"content":{"rendered":"<p>Rails is very friendly whenever you need to create forms to input data to your web app&#8217;s database. Things get a little different when you must have forms and you don&#8217;t want to save anything in the database. For that, you have to resort to other ways, maybe creating <a href=\"http:\/\/railscasts.com\/episodes\/193-tableless-model\">tableless models<\/a>. <\/p>\n<p>However, there are some simple cases that even creating a new class seems an overkill, such as forms for searching or filtering data in your app. In these cases, you just want a form that user can pick options and hit a button to see the results. When returning to the user, it is expected to have that form filled with the options the user had chosen before, but there is no simple, clean way to do that with plain old &#8220;form_tag&#8221;. Here is where our little tip comes in.<\/p>\n<p>OpenStruct is a cool lib that comes with the Ruby Standard Library. &#8220;It is like a hash with a different way to access the data&#8221; says the documentation:<\/p>\n<pre lang=\"ruby\">\r\n>> user = OpenStruct.new({:name => 'John', :last_name => 'Doe'})\r\n=> #<OpenStruct name=\"John\", last_name=\"Doe\">\r\n>> user.name\r\n=> \"John\"\r\n>> user.last_name\r\n=> \"Doe\"\r\n>> user.bla\r\n=> nil\r\n<\/pre>\n<p>We can use it to fool our old friend &#8220;form_for&#8221; helper to think we&#8217;re dealing with normal AR objects, so we can create a method that wraps &#8220;form_for&#8221;, simple as this:<\/p>\n<pre lang=\"ruby\">\r\nrequire 'ostruct'\r\nmodule SearchFormHelper\r\n  def search_form_for(object_name, options={}, &block)\r\n    options[:html] = {:method => :get}.update(options[:html] || {})\r\n    object = OpenStruct.new(params[object_name])\r\n    form_for(object_name, object, options, &block)\r\n  end\r\nend\r\n<\/pre>\n<p>Inside the view, you will do the same way you do with AR models:<\/p>\n<pre lang=\"ruby\">\r\n<% search_form_for :search do |f| %>\r\n  <p>\r\n    <%= f.label :start_at %>\r\n    <%= f.date_select :start_at %>\r\n  <\/p>\r\n  <p>\r\n    <%= f.label :end_at %>\r\n    <%= f.date_select :end_at %>\r\n  <\/p>\r\n  <p>\r\n    <%= f.submit 'Search' %>\r\n  <\/p>\r\n<% end %>\r\n<\/pre>\n<p>That&#8217;s pretty much it! If you&#8217;re filtering data, by a category for example, try checking the <a href=\"http:\/\/github.com\/plataformatec\/has_scope\">has_scope plugin<\/a>, works like a charm in combination with this tip, but it is a matter for other post.<\/p>\n<p>And you, reader, do you have any little tricks like this? If you don&#8217;t mind, share with us!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Rails is very friendly whenever you need to create forms to input data to your web app&#8217;s database. Things get a little different when you must have forms and you don&#8217;t want to save anything in the database. For that, you have to resort to other ways, maybe creating tableless models. However, there are some &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2010\/04\/quick-tip-search-forms\/\">\u00bb<\/a><\/p>\n","protected":false},"author":10,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[54,82,7,81],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/845"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/10"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=845"}],"version-history":[{"count":14,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/845\/revisions"}],"predecessor-version":[{"id":859,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/845\/revisions\/859"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=845"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=845"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=845"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}