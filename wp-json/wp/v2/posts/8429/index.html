{"id":8429,"date":"2019-01-21T15:02:59","date_gmt":"2019-01-21T17:02:59","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=8429"},"modified":"2019-10-28T11:55:46","modified_gmt":"2019-10-28T14:55:46","slug":"indices-para-jsonb-no-postgres","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2019\/01\/indices-para-jsonb-no-postgres\/","title":{"rendered":"\u00cdndices para JSONB no Postgres"},"content":{"rendered":"<p>No Postgres existe a op\u00e7\u00e3o de salvar dados como <a href=\"https:\/\/www.postgresql.org\/docs\/9.5\/datatype-json.html\" target=\"_blank\" rel=\"noopener noreferrer\">JSON<\/a> &#8211; o que pode ser muito \u00fatil especialmente quando temos muitas incertezas quanto aos requisitos de neg\u00f3cio que ajudariam na modelagem das tabelas.<\/p>\n<p>A flexibilidade de poder armazenar os dados sem se preocupar com a estrutura das tabelas parece interessante, por\u00e9m qual o impacto disso na performance?<\/p>\n<p>A verdade \u00e9 o que os dados do tipo JSON s\u00e3o armazenados da maneira como foram inseridos &#8211; isto \u00e9, em texto &#8211; o que deixa as consultas um pouco mais lentas j\u00e1 que os dados precisam ser <em>parseados<\/em> novamente. Por\u00e9m, existe uma outra varia\u00e7\u00e3o: o JSONB. Esse formato processa o texto no momento da inser\u00e7\u00e3o e o armazena em formato bin\u00e1rio. Isso faz com que a inser\u00e7\u00e3o demore um pouco mais, em troca de consultas mais r\u00e1pidas. Ah, e o JSONB tamb\u00e9m suporta \u00edndices!<\/p>\n<p>Nesse artigo voc\u00ea vai encontrar uma compara\u00e7\u00e3o dos tipos de \u00edndices dispon\u00edveis para JSONB no Postgres, um <em>benchmark<\/em> e como us\u00e1-los em aplica\u00e7\u00f5es Rails.<\/p>\n<h2>Setup<\/h2>\n<p>Para testar a performance de \u00edndices, \u00e9 importante ter um banco populado com uma quantidade razo\u00e1vel de registros. Abaixo voc\u00ea encontrar\u00e1 as etapas necess\u00e1rias para criar o banco de dados utilizado nesse <em>benchmark<\/em>.<br \/>\nPara acompanhar as etapas \u00e0 seguir, precisaremos do <a href=\"https:\/\/www.postgresql.org\/download\/\" target=\"_blank\" rel=\"noopener noreferrer\">Postgres devidamente instalado e rodando<\/a>.<\/p>\n<p>Iremos importar cerca de 600 mil registros na estrutura abaixo:<\/p>\n<pre><code class=\"json\">{\n\n        \"customer_id\": \"ATVPDKIKX0DER\",\n        \"product\": {\n            \"category\": \"Arts &amp; Photography\",\n            \"group\": \"Book\",\n            \"id\": \"1854103040\",\n            \"sales_rank\": 72019,\n            \"similar_ids\": [\n                \"1854102664\",\n                \"0893815381\",\n                \"0893816493\",\n                \"3037664959\",\n                \"089381296X\"\n            ],\n            \"subcategory\": \"Art\",\n            \"title\": \"The Age of Innocence\"\n        },\n        \"review\": {\n            \"date\": \"1995-08-10\",\n            \"helpful_votes\": 5,\n            \"rating\": 5,\n            \"votes\": 12\n        }\n   }\n<\/code><\/pre>\n<p>Para importar esses dados, fa\u00e7a o <a href=\"http:\/\/examples.citusdata.com\/customer_reviews_nested_1998.json.gz\" target=\"_blank\" rel=\"noopener noreferrer\">download do arquivo<\/a> e siga as instru\u00e7\u00f5es abaixo:<\/p>\n<h3>1. Criar banco de dados<\/h3>\n<pre><code class=\"bash\">\u276f psql\n<\/code><\/pre>\n<pre><code class=\"sql\">CREATE DATABASE store;\n<\/code><\/pre>\n<h3>2. Criar tabela<\/h3>\n<p>Vamos criar a tabela <code>reviews<\/code> com um \u00fanico campo (<code>content<\/code>) para armazenar o conte\u00fado de cada registro:<\/p>\n<pre><code class=\"bash\">\u276f psql store\n<\/code><\/pre>\n<pre><code class=\"sql\">CREATE TABLE reviews(content jsonb);\n<\/code><\/pre>\n<h3>3. Importar os dados<\/h3>\n<p>Por fim, vamos importar os dados do JSON que acabamos de baixar utilizando o comando <code>copy<\/code> dentro do console do Postgres:<\/p>\n<pre><code class=\"sql\">copy reviews (content) FROM 'customer_reviews_nested_1998.json'\n<\/code><\/pre>\n<h2>B-tree<\/h2>\n<p>O \u00edndice do formato <strong>B-tree<\/strong> funciona somente com uma chave do documento e para um operador espec\u00edfico: isto \u00e9, o operador usado na defini\u00e7\u00e3o do \u00edndice dever\u00e1 ser o mesmo utilizado na consulta:<\/p>\n<pre><code class=\"sql\">CREATE INDEX ON reviews((content #&gt;&gt; '{product,category}'));\n<\/code><\/pre>\n<p>Para que o \u00edndice seja utilizado, devemos fazer a consulta com o mesmo operador:<\/p>\n<pre><code class=\"sql\">SELECT COUNT(*) FROM reviews WHERE content #&gt;&gt; '{product,category}' = 'Arts &amp; Photography';\n<\/code><\/pre>\n<p>Se utilizarmos outros operadores o \u00edndice n\u00e3o ser\u00e1 aplicado, e consequentemente a busca ficar\u00e1 mais lenta:<\/p>\n<pre><code class=\"sql\">SELECT COUNT(*) FROM reviews WHERE content-&gt;'product'-&gt;&gt;'category' = 'Arts &amp; Photography';\n<\/code><\/pre>\n<p>O \u00edndice para a consulta acima seria o seguinte:<\/p>\n<pre><code class=\"sql\">CREATE INDEX ON reviews((content-&gt;'product'-&gt;&gt;'category'));\n<\/code><\/pre>\n<p>Se for necess\u00e1rio responder perguntas como \u201cquais as <em>reviews<\/em> tem <em>rating<\/em> <code>4<\/code> ou mais\u201d ou \u201cquais <em>reviews<\/em> n\u00e3o s\u00e3o de livros\u201d &#8211; operadores <code>&gt;<\/code>, <code>=<\/code>, <code>&lt;<\/code>, <code>&gt;=<\/code>, <code>&lt;=<\/code> e <code>!=<\/code> &#8211; esse \u00e9 o \u00edndice mais indicado.<\/p>\n<p>Por\u00e9m fica uma observa\u00e7\u00e3o aqui: nos testes feitos nesse <em>benchmark<\/em>, os \u00edndices para esses operadores acabaram <strong>n\u00e3o<\/strong> valendo a pena, o tempo de execu\u00e7\u00e3o foi o mesmo. Mas pode ser que esse n\u00e3o seja sempre o caso, por isso \u00e9 importante fazer <em>benchmarks<\/em> no seu ambiente para ter uma escolha mais assertiva.<\/p>\n<h3>Pr\u00f3s:<\/h3>\n<ul>\n<li>Melhor performance na consulta;<\/li>\n<li>Mais r\u00e1pido para gerar;<\/li>\n<li>Utiliza menos espa\u00e7o em disco;<\/li>\n<li>Suporta os operadores <code>&gt;<\/code>, <code>=<\/code>, <code>&lt;<\/code>, <code>&gt;=<\/code>, <code>&lt;=<\/code> e <code>!=<\/code>.<\/li>\n<\/ul>\n<h3>Contras:<\/h3>\n<ul>\n<li>Somente um operador de consulta;<\/li>\n<li>Se for necess\u00e1rio buscar por v\u00e1rias chaves do documento, ser\u00e1 preciso criar um \u00edndice para cada uma.<\/li>\n<\/ul>\n<h2>Hash<\/h2>\n<p>Apenas uma men\u00e7\u00e3o honrosa. Sua funcionalidade \u00e9 muito similar ao <strong>B-tree<\/strong>, por\u00e9m o pr\u00f3prio banco j\u00e1 lan\u00e7a um <em>warning<\/em> ao cri\u00e1-lo. O <em>warning<\/em> informa que o <strong>Hash<\/strong> n\u00e3o suport algo chamado <strong>WAL<\/strong> e, portanto, seu uso \u00e9 desencorajado:<\/p>\n<pre><code class=\"sql\">CREATE INDEX ON reviews USING HASH((content #&gt;&gt; '{product,category}'));\nWARNING:  hash indexes are not WAL-logged and their use is discouraged\n<\/code><\/pre>\n<p>O <em>Write-Ahead Logging<\/em> (WAL) \u00e9 um padr\u00e3o que garante a integridade dos dados. De forma resumida, ele garante que as altera\u00e7\u00f5es nos arquivos do banco de dados s\u00f3 sejam salvas depois que essas mudan\u00e7as forem salvas em um log. Isso permite que, se houver um <em>crash<\/em> no banco, seja poss\u00edvel aplicar as mudan\u00e7as perdidas com base no log.<br \/>\nCaso queira saber mais sobre <strong>WAL<\/strong>, recomendo ler a <a href=\"https:\/\/www.postgresql.org\/docs\/9.1\/static\/wal-intro.html\" target=\"_blank\" rel=\"noopener noreferrer\">documenta\u00e7\u00e3o de Postgres<\/a>.<\/p>\n<p>Por n\u00e3o suportar o WAL, o <strong>Hash<\/strong> acaba sendo um pouco mais r\u00e1pido que o <strong>B-tree<\/strong>, por\u00e9m ele n\u00e3o foi inclu\u00eddo no <em>benchmark<\/em> por conta de seu uso ser desencorajado.<\/p>\n<p><strong>Atualiza\u00e7\u00e3o:<\/strong> a partir do Postgres 10, os \u00edndices de tipo <strong>Hash<\/strong> passaram a suportar o WAL. Portanto, pode valer a pena considerar essa op\u00e7\u00e3o na hora de escolher qual \u00edndice utilizar.<\/p>\n<h2>GIN (General inverted Index)<\/h2>\n<p>A partir do Postgres <strong>9.4<\/strong>, podemos utilizar esse novo formato de \u00edndice para os documentos. Esse \u00edndice pode ser usado em todo o documento (com qualquer chave).<\/p>\n<pre><code class=\"sql\">CREATE INDEX on reviews USING GIN(content);\n<\/code><\/pre>\n<p>Nesse caso podemos realizar a consulta dessa forma:<\/p>\n<pre><code class=\"sql\">SELECT COUNT(*) FROM reviews WHERE content @&gt; '{\"product\": {\"category\": \"Arts &amp; Photography\"}}';\n<\/code><\/pre>\n<p>Tamb\u00e9m \u00e9 poss\u00edvel utilizar os operadores <code>?<\/code>, <code>?|<\/code> e <code>?&amp;<\/code>\u00a0&#8211; que s\u00e3o usados para saber se o documento cont\u00e9m alguma chave.<\/p>\n<h3>GIN (jsonb_path_ops)<\/h3>\n<p>Normalmente o operador mais usado \u00e9 o <code>@&gt;<\/code> , para saber se o documento \u201ccont\u00e9m o peda\u00e7o\u201d que for passado como argumento.<br \/>\nSe na sua aplica\u00e7\u00e3o for poss\u00edvel utilizar apenas esse operador, \u00e9 interessante usar a varia\u00e7\u00e3o <code>jsonb_path_ops<\/code>:<\/p>\n<pre><code class=\"sql\">CREATE INDEX ON reviews USING GIN(content jsonb_path_ops);\n<\/code><\/pre>\n<p>Por suportar somente esse operador, o \u00edndice fica um pouco menor e as consultas mais perform\u00e1ticas.<\/p>\n<h3>Pr\u00f3s:<\/h3>\n<ul>\n<li>Funciona com qualquer chave do documento;<\/li>\n<li>Um \u00edndice serve para consultas por qualquer chave.<\/li>\n<\/ul>\n<h3>Contras:<\/h3>\n<ul>\n<li>Ocupa mais espa\u00e7o em disco;<\/li>\n<li>Demora mais tempo para ser gerado;<\/li>\n<li>Consulta \u00e9 mais lenta;<\/li>\n<li>N\u00e3o permite utilizar os operadores <code>&gt;<\/code>, <code>=<\/code>, <code>&lt;<\/code>, <code>&gt;=<\/code>, <code>&lt;=<\/code> e <code>!=<\/code>.<\/li>\n<\/ul>\n<h2>Benchmarks<\/h2>\n<p>Os testes foram realizados em um MacBook Pro 13\u2019 Early 2015 com 8GB de RAM, Core i5 2.7GHz e 120GB SSD.<br \/>\nO banco possu\u00ed 589.859 registros.<\/p>\n<h3>Cria\u00e7\u00e3o do \u00edndice<\/h3>\n\n<table id=\"tablepress-5\" class=\"tablepress tablepress-id-5\">\n<thead>\n<tr class=\"row-1 odd\">\n\t<th class=\"column-1\">\u00cdndice<\/th><th class=\"column-2\">Tempo (ms)<\/th>\n<\/tr>\n<\/thead>\n<tbody class=\"row-hover\">\n<tr class=\"row-2 even\">\n\t<td class=\"column-1\">Btree<\/td><td class=\"column-2\">\t1207.831<\/td>\n<\/tr>\n<tr class=\"row-3 odd\">\n\t<td class=\"column-1\">GIN<\/td><td class=\"column-2\">\t20676.872<\/td>\n<\/tr>\n<tr class=\"row-4 even\">\n\t<td class=\"column-1\">GIN (jsonb_path_ops)<\/td><td class=\"column-2\">8880.895<br \/>\n<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<!-- #tablepress-5 from cache -->\n<h3>Consulta<\/h3>\n\n<table id=\"tablepress-11\" class=\"tablepress tablepress-id-11\">\n<thead>\n<tr class=\"row-1 odd\">\n\t<th class=\"column-1\">\u00cdndice<\/th><th class=\"column-2\">Tempo (ms)<\/th>\n<\/tr>\n<\/thead>\n<tbody class=\"row-hover\">\n<tr class=\"row-2 even\">\n\t<td class=\"column-1\">Btree<\/td><td class=\"column-2\">         2.661<\/td>\n<\/tr>\n<tr class=\"row-3 odd\">\n\t<td class=\"column-1\">GIN<\/td><td class=\"column-2\">\t13.643<\/td>\n<\/tr>\n<tr class=\"row-4 even\">\n\t<td class=\"column-1\">GIN (jsonb_path_ops)<\/td><td class=\"column-2\">         3.985<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<!-- #tablepress-11 from cache -->\n<p>Com o resultado do <em>benchmark<\/em>, podemos concluir que: se a ideia for utilizar operadores de compara\u00e7\u00e3o simples (<code>&gt;<\/code>, <code>=<\/code>, <code>&lt;<\/code>, <code>&gt;=<\/code>, <code>&lt;=<\/code> e <code>!=<\/code>) ou apenas um chave do documento, a melhor op\u00e7\u00e3o \u00e9 o <strong>B-tree<\/strong>.<br \/>\nSe as consultas necessitarem de maior flexibilidade &#8211; buscar por v\u00e1rias chaves do documento &#8211; a melhor op\u00e7\u00e3o \u00e9 o <strong>GIN<\/strong>. E se voc\u00ea utilizar somente o operador <code>@&gt;<\/code>, vale a pena utilizar a varia\u00e7\u00e3o <code>jsonb_path_ops<\/code> do <strong>GIN<\/strong>.<\/p>\n<h1>Uso em aplica\u00e7\u00f5es Rails<\/h1>\n<p>Os \u00edndices acima cont\u00e9m express\u00f5es de SQL, ent\u00e3o como podemos criar esses tipos de \u00edndice no Rails? Bom, se sua aplica\u00e7\u00e3o estiver usando Rails 4 ou anterior, o jeito \u00e9 usar o m\u00e9todo <a href=\"https:\/\/api.rubyonrails.org\/classes\/ActiveRecord\/ConnectionAdapters\/PostgreSQL\/DatabaseStatements.html#method-i-execute\" target=\"_blank\" rel=\"noopener noreferrer\">execute<\/a> que aceita um SQL literal como argumento:<\/p>\n<pre><code class=\"ruby\">class AddIndex &lt; ActiveRecord::Migration\n  def up\n    execute 'CREATE INDEX index_reviews_on_content ON reviews USING GIN(content jsonb_path_ops)'\n  end\n\n  def down\n    remove_index :reviews, name: 'index_reviews_on_content'\n  end\nend\n<\/code><\/pre>\n<p>Por conta disso tamb\u00e9m \u00e9 preciso especificar como a <em>migration<\/em> pode ser revertida &#8211; ou seja, implementar o m\u00e9todo <code>down<\/code>.<\/p>\n<p>A boa not\u00edcia \u00e9 que, a partir do Rails 5 podemos utilizar <a href=\"https:\/\/blog.bigbinary.com\/2016\/07\/20\/rails-5-adds-support-for-expression-indexes-for-postgresql.html\" target=\"_blank\" rel=\"noopener noreferrer\">express\u00f5es SQL<\/a> na cria\u00e7\u00e3o dos \u00edndices:<\/p>\n<pre><code class=\"ruby\">class AddIndex &lt; ActiveRecord::Migration[5.0]\n  def up\n    add_index :reviews, 'content jsonb_path_ops', using: :gin, name: 'index_reviews_on_content'\n  end\n\n  def down\n    remove_index :reviews, name: 'index_reviews_on_content'\n  end\nend\n<\/code><\/pre>\n<p>Em um pr\u00f3ximo post, vamos mostrar alguns exemplos de como fazer <em>queries<\/em> e <em>updates<\/em> utilizando Rails e JSONB. Fique ligado!<\/p>\n<h2>Links de refer\u00eancia<\/h2>\n<p>https:\/\/www.postgresql.org\/docs\/9.5\/static\/functions-json.html<\/p>\n<p>https:\/\/www.postgresql.org\/docs\/9.5\/static\/datatype-json.html<\/p>\n<p>https:\/\/blog.heapanalytics.com\/when-to-avoid-jsonb-in-a-postgresql-schema\/<\/p>\n<p>http:\/\/schinckel.net\/2014\/05\/25\/querying-json-in-postgres\/<\/p>\n<blockquote class=\"wp-embedded-content\" data-secret=\"4FyLATrOQj\"><p><a href=\"https:\/\/bitnine.net\/blog-postgresql\/postgresql-internals-jsonb-type-and-its-indexes\/\">PostgreSQL internals: JSONB type and its indexes<\/a><\/p><\/blockquote>\n<p><iframe class=\"wp-embedded-content\" sandbox=\"allow-scripts\" security=\"restricted\" style=\"position: absolute; clip: rect(1px, 1px, 1px, 1px);\" src=\"https:\/\/bitnine.net\/blog-postgresql\/postgresql-internals-jsonb-type-and-its-indexes\/embed\/#?secret=4FyLATrOQj\" data-secret=\"4FyLATrOQj\" width=\"500\" height=\"282\" title=\"&#8220;PostgreSQL internals: JSONB type and its indexes&#8221; &#8212; Bitnine Global Inc.\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\"><\/iframe><\/p>\n<p>https:\/\/blog.2ndquadrant.com\/jsonb-type-performance-postgresql-9-4\/<\/p>\n<p>https:\/\/stackoverflow.com\/questions\/36075918\/postgresql-index-on-json<\/p>\n<p>http:\/\/blog.bigbinary.com\/2016\/07\/20\/rails-5-adds-support-for-expression-indexes-for-postgresql.html<\/p>\n","protected":false},"excerpt":{"rendered":"<p>No Postgres existe a op\u00e7\u00e3o de salvar dados como JSON &#8211; o que pode ser muito \u00fatil especialmente quando temos muitas incertezas quanto aos requisitos de neg\u00f3cio que ajudariam na modelagem das tabelas. A flexibilidade de poder armazenar os dados sem se preocupar com a estrutura das tabelas parece interessante, por\u00e9m qual o impacto disso &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2019\/01\/indices-para-jsonb-no-postgres\/\">\u00bb<\/a><\/p>\n","protected":false},"author":54,"featured_media":9452,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[3],"tags":[7],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2019\/10\/indices-para-jsonb-no-postgres.png","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8429"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/54"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=8429"}],"version-history":[{"count":45,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8429\/revisions"}],"predecessor-version":[{"id":9451,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8429\/revisions\/9451"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media\/9452"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=8429"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=8429"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=8429"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}