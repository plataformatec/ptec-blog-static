{"id":5107,"date":"2016-02-12T13:27:30","date_gmt":"2016-02-12T15:27:30","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5107"},"modified":"2016-02-12T13:46:55","modified_gmt":"2016-02-12T15:46:55","slug":"how-to-setup-ci-to-run-phoenix-projects","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/02\/how-to-setup-ci-to-run-phoenix-projects\/","title":{"rendered":"How to setup CI to run Phoenix projects"},"content":{"rendered":"<p>Writing tests is an important step in software development and everyone knows the benefits. In our last post, we took a look on <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/01\/writing-acceptance-tests-in-phoenix\/\">how to write acceptance tests in Phoenix<\/a> and today we will see how to configure CI to run the tests.<\/p>\n<h2>Install Erlang and Elixir<\/h2>\n<p>We use Jenkins to run ours builds and Ansible to setup the agents. The following code are snippets from the tasks used for machine provisioning. Our agents are using Ubuntu, but you can check the <a href=\"http:\/\/elixir-lang.org\/install.html\">Elixir Install section<\/a> to follow the steps for another OS.<\/p>\n<h3>Step 1: Add the Erlang Solutions repository:<\/h3>\n<p>First, we need to add the Erlang Solution repo and its GPG key before updating the repo. With this step we can find the Erlang and Elixir packages.<\/p>\n<pre><code class=\"yaml\">- name: Add Erlang Solutions repository\n  apt_repository: &gt;\n    repo='deb https:\/\/packages.erlang-solutions.com\/ubuntu\/ {{ansible_distribution_release}} contrib'\n    state=present\n    update_cache=yes\n\n- name: Add the GPG key for Erlang Solutions\n  apt_key:\n    url: \"https:\/\/packages.erlang-solutions.com\/{{ ansible_distribution | lower }}\/erlang_solutions.asc\"\n    state: present\n<\/code><\/pre>\n<h3>Step 2: Install Erlang and Elixir packages.<\/h3>\n<p>We are using the latest version of Elixir but if you need to manage it you can take a look at a manager like <a href=\"https:\/\/github.com\/taylor\/kiex\">kiex<\/a> or <a href=\"https:\/\/github.com\/HashNuke\/asdf\">asdf<\/a>.<\/p>\n<pre><code class=\"yaml\">- name: Install Erlang\n  apt: pkg=esl-erlang state=latest\n\n- name: Install Elixir\n  apt: pkg=elixir state=latest\n<\/code><\/pre>\n<h3>Step 3: Install Hex and Rebar.<\/h3>\n<p>If you are new to Elixir\/Erlang, you probably don&#8217;t know about these tools. Hex is the package manager for the Erlang ecosystem and you can learn more at <a href=\"https:\/\/hex.pm\/\">https:\/\/hex.pm<\/a>.<\/p>\n<p>Rebar is an Erlang build tool, and it&#8217;s necessary to build the dependency <code>poolboy<\/code>. The task <code>mix local.rebar<\/code> will install both <code>rebar<\/code> and <code>rebar3<\/code>. You can check the <a href=\"http:\/\/elixir-lang.org\/docs\/master\/mix\/Mix.Tasks.Local.Rebar.html\">Mix.Tasks.Local.Rebar<\/a> documentation to install one of them if you need.<\/p>\n<pre><code class=\"yaml\">- name: Install Elixir Hex\n  command: mix local.hex --force\n\n- name: Install Rebar\n  command: mix local.rebar\n<\/code><\/pre>\n<h2>Running your tests<\/h2>\n<p>We use <a href=\"https:\/\/github.com\/github\/janky\">Janky<\/a>, along with Jenkins, which can execute a custom build configuration into <code>script\/cibuild<\/code> that is stored at the root of the repository. Our Phoenix projects use the following script:<\/p>\n<pre><code class=\"bash\">#!\/bin\/bash -ex\nenv\n\nsource \/etc\/profile\n\nexport POSTGRESQL_USER=\"test\"\nexport POSTGRESQL_PASSWORD=\"test\"\n\nmix ecto.reset\nmix deps.get\nmix test\n<\/code><\/pre>\n<h3>Exporting ENV variables<\/h3>\n<p>Our project is using Postgres and it isn&#8217;t a good practice to store the credentials in the version control. So, we export the credential to environment variables and get it in <code>config\/test.exs<\/code>:<\/p>\n<pre><code class=\"elixir\">config :my_app, MyApp.Repo,\n  adapter: Ecto.Adapters.Postgres,\n  username: System.get_env(\"POSTGRESQL_USER\") || \"postgres\",\n  password: System.get_env(\"POSTGRESQL_PASSWORD\") || \"postgres\",\n  database: \"my_app_test\",\n  hostname: \"localhost\",\n  pool: Ecto.Adapters.SQL.Sandbox,\n  port: System.get_env(\"POSTGRESQL_PORT\") || 5432\n<\/code><\/pre>\n<p>You can read more about this practice at <a href=\"http:\/\/12factor.net\/config\">Twelve-Factor App<\/a>.<\/p>\n<h3>Reset your database<\/h3>\n<p>Usually, each builder is responsible for provision in a new machine. Instead of this, we setup a machine that will run several builds from different projects while there is activity. Therefore, we need to reset the database to avoid side-effects with different schemas.<\/p>\n<p>The task <code>mix test<\/code> will run the tasks <code>ecto.create<\/code> and <code>ecto.migrate<\/code> (you can check it in <code>test\/test_helper.exs<\/code>). We could use <code>mix ecto.destroy<\/code> instead of <code>mix ecto.reset<\/code>, but we prefer to use the latter to be more explicit.<\/p>\n<h3>Install dependencies and run the tests<\/h3>\n<p>Now, <code>mix deps.get<\/code> and <code>mix test<\/code> will install the project dependencies and run your tests.<\/p>\n<p><em>Which tips do you have to install or use in CI to run Phoenix tests?<\/em><\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&#038;utm_medium=referral&#038;utm_campaign=elixir-radar&#038;utm_content=elixir-radar-cta-blog-post-bottom\"><br \/>\n  <img decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\" style=\"border:0\"><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Writing tests is an important step in software development and everyone knows the benefits. In our last post, we took a look on how to write acceptance tests in Phoenix and today we will see how to configure CI to run the tests. Install Erlang and Elixir We use Jenkins to run ours builds and &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/02\/how-to-setup-ci-to-run-phoenix-projects\/\">\u00bb<\/a><\/p>\n","protected":false},"author":18,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[143,245,96],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5107"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/18"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5107"}],"version-history":[{"count":5,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5107\/revisions"}],"predecessor-version":[{"id":5112,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5107\/revisions\/5112"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5107"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5107"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5107"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}