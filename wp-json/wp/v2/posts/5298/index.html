{"id":5298,"date":"2016-04-14T11:38:12","date_gmt":"2016-04-14T14:38:12","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5298"},"modified":"2016-04-19T16:55:59","modified_gmt":"2016-04-19T19:55:59","slug":"how-to-trace-elixir-nodes-with-erlyberly","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2016\/04\/how-to-trace-elixir-nodes-with-erlyberly\/","title":{"rendered":"How to trace Elixir nodes with Erlyberly"},"content":{"rendered":"<p>At Plataformatec, we are always learning new techniques to help our clients introspect and monitor their production systems. Last week, we saw <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/04\/debugging-techniques-in-elixir-lang\/\">debugging techniques in Elixir<\/a> and now we will see one of many ways to do tracing in Elixir.<\/p>\n<p>For this post, we will use <a href=\"https:\/\/github.com\/andytill\/erlyberly\">erlyberly<\/a>. You can see the installation instructions in its README.<\/p>\n<p>Tracing gives you all the data you need and doesn&#8217;t block your process as debuggers. It&#8217;s indicated for production and development.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir.png\" alt=\"erlyberly\" width=\"1472\" height=\"874\" class=\"aligncenter size-full wp-image-5300\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir.png 1472w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir-300x178.png 300w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir-768x456.png 768w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir-1024x608.png 1024w\" sizes=\"(max-width: 1472px) 100vw, 1472px\" \/><\/p>\n<h2>Naming nodes<\/h2>\n<p>After you start erlyberly with <code>java -jar target\/erlyberly-&lt;version&gt;-runnable.jar<\/code>, you need two pieces of information from your application to connect: the target node and its cookie.<\/p>\n<p>The target node is how you will identify the node that you want to connect to. You need to start your process with the option <code>--name<\/code> or <code>--sname<\/code> (short name).<\/p>\n<pre><code class=\"elixir\">$ iex --name \"foo@127.0.0.1\" -S mix\nErlang\/OTP 18 [erts-7.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nInteractive Elixir (1.2.4) - press Ctrl+C to exit (type h() ENTER for help)\niex(foo@127.0.0.1)1&gt; node\n:\"foo@127.0.0.1\"\n<\/code><\/pre>\n<p>The cookie provides authentication for connecting nodes. When you start a node with a name, you will receive a cookie that is created randomly the first time and reused in the next ones. You can check the cookies in IEx with <code>Node.get_cookie\/0<\/code> or in the file <code>~\/.erlang.cookie<\/code>.<\/p>\n<p>You can start a new node with a different cookie too:<\/p>\n<pre><code class=\"elixir\">$ iex --name \"foo@127.0.0.1\" --cookie \"my_cookie\" -S mix\nErlang\/OTP 18 [erts-7.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nInteractive Elixir (1.2.4) - press Ctrl+C to exit (type h() ENTER for help)\niex(foo@127.0.0.1)1&gt; Node.get_cookie\n:my_cookie\n<\/code><\/pre>\n<p>The target and cookie are used to connect remotely to your node. Similar to when we use the <code>User Switch command<\/code> inside the IEx shell or via the option <code>--remsh<\/code> when starting IEx.<\/p>\n<h2>Erlyberly usage<\/h2>\n<p>Now we are connected to our application. We have 3 panels: processes, modules and trace log. Furthermore, we can see the Erlang memory and the crash dumps.<\/p>\n<h3>Processes<\/h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir-processes.png\" alt=\"erlyberly processes\" width=\"991\" height=\"505\" class=\"aligncenter size-full wp-image-5301\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir-processes.png 991w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir-processes-300x153.png 300w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-elixir-processes-768x391.png 768w\" sizes=\"(max-width: 991px) 100vw, 991px\" \/><\/p>\n<p>In the processes area, you can check a snapshot or start polling your application. We have a lot of information about our processes such as their PID, reductions, message queue and head\/stack size.<\/p>\n<p>With the message queue, we can avoid the most common cause of failure: out of memory in the node. This is usually related to message queues when a process receives messages at a faster pace than it can handle.<\/p>\n<p>The CPU is harder to profile. Some examples that we can point out: scheduling and busy looping to ensure the lowest latency. The VM internally uses a model based on reductions (work actions). Every function call will increment the reduction counter for its current process. The process is descheduled after a given number of reductions. We can access this information in the processes area.<\/p>\n<h3>Memory<\/h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-memory-graph-elixir.png\" alt=\"erlyberly memory graph\" width=\"912\" height=\"712\" class=\"aligncenter size-full wp-image-5302\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-memory-graph-elixir.png 912w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-memory-graph-elixir-300x234.png 300w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-memory-graph-elixir-768x600.png 768w\" sizes=\"(max-width: 912px) 100vw, 912px\" \/><\/p>\n<p>The memory graph is based on <code>:erlang.memory()<\/code>. The data is the memory actively used by Erlang VM, not the memory set aside by the OS. You can find information about the processes (stacks and heaps from Erlang), ETS tables, atoms in the VM and the binaries.<\/p>\n<h3>Modules and traces<\/h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-tracing-elixir.png\" alt=\"erlyberly tracing\" width=\"1123\" height=\"574\" class=\"aligncenter size-full wp-image-5307\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-tracing-elixir.png 1123w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-tracing-elixir-300x153.png 300w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-tracing-elixir-768x393.png 768w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/erlyberly-tracing-elixir-1024x523.png 1024w\" sizes=\"(max-width: 1123px) 100vw, 1123px\" \/><\/p>\n<p>In the modules area, you can filter your modules and check which functions you want to trace and see their source code. In the trace logs, you can check your function calls with breakdown of their arguments and their results.<\/p>\n<p>You can check for exceptions, incomplete calls, process states and so on. You can find more information in the <a href=\"https:\/\/github.com\/andytill\/erlyberly\">erlyberly<\/a> project.<\/p>\n<p>This is one more visual tool for tracing your application. Other options are redbug, recon_trace, dbg and more. Which tools and techniques do you use to introspect your production apps?<\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=elixir-radar&amp;utm_content=elixir-radar-cta-blog-post-bottom\"><br \/>\n<img decoding=\"async\" style=\"border: 0;\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\" \/><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>At Plataformatec, we are always learning new techniques to help our clients introspect and monitor their production systems. Last week, we saw debugging techniques in Elixir and now we will see one of many ways to do tracing in Elixir. For this post, we will use erlyberly. You can see the installation instructions in its &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2016\/04\/how-to-trace-elixir-nodes-with-erlyberly\/\">\u00bb<\/a><\/p>\n","protected":false},"author":18,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5298"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/18"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5298"}],"version-history":[{"count":9,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5298\/revisions"}],"predecessor-version":[{"id":5312,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5298\/revisions\/5312"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5298"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5298"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5298"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}