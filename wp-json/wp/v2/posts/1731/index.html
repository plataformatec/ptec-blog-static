{"id":1731,"date":"2011-02-02T16:41:27","date_gmt":"2011-02-02T18:41:27","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=1731"},"modified":"2011-02-02T16:59:52","modified_gmt":"2011-02-02T18:59:52","slug":"outpost-v0-1-0-is-released","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2011\/02\/outpost-v0-1-0-is-released\/","title":{"rendered":"Outpost v0.1.0 is released!"},"content":{"rendered":"<p>Outpost is me, scratching my own itch. For a while now, freelancing or working<br \/>\nfor others, I work with pretty much all the stack in web development: from front-end<br \/>\ndevelopment with HTML and CSS up to the system administration.<\/p>\n<p>And sometimes, I screw up. Sometimes, stuff go wrong. Maybe that Sphinx<br \/>\nisn&#8217;t getting indexed or even running after an unsuccessful deploy. Maybe that<br \/>\nbackground job isn&#8217;t being run, and I forget to verify it.<\/p>\n<p>I know there are excellent tools that already solve this problem. But I wanted an<br \/>\neasy way I would be able to code my own monitoring rules, using one of the<br \/>\nlanguages I like the most. And also, the fantastic Aaron Patterson (or<br \/>\ntenderlove), one of the most prominent faces of the Ruby community once told in<br \/>\na Q&amp;A at <a href=\"http:\/\/university.rubymendicant.com\">RMU<\/a>: it should be fun!<\/p>\n<p>And thus the Outpost idea was born. Outpost is a framework so I can easily<br \/>\nimplement Ruby code that query the current state of any service I want. I can<br \/>\nalso write code that can go into the database and do a SELECT on a table (a<br \/>\njobs table, for example) to check if everything&#8217;s fine.<\/p>\n<h3>What is Outpost?<\/h3>\n<p>Outpost is basically a DSL where you can describe rules to monitor your<br \/>\nservice, application, server, whatever. Below is a very simple example:<\/p>\n<pre lang=\"ruby\">require 'outpost'\r\nrequire 'outpost\/scouts'\r\n\r\nclass MyWebPageOutpost < Outpost::DSL\r\n  using Outpost::Scouts::Http => \"web page\" do\r\n    options :host => 'localhost', :port => 3000\r\n    report :up, :response_code => 200\r\n    report :down, :response_body => {:match => \/Ops\/}\r\n  end\r\nend<\/pre>\n<p>In this example, we are monitoring (using what I&#8217;ve called &#8216;Scouts&#8217;) HTTP<br \/>\ncommunication to <code>localhost:3000<\/code>. It will report that the system is<br \/>\nup if the response code is 200 (HTTP OK) and report that it is down if the<br \/>\nresponse body contains the word &#8220;Ops&#8221;, by matching a Regular Expression to it.<\/p>\n<p>There is still a lot of work to be done, but I feel it is ready for a very first<br \/>\nrelease. There are only two Scouts today: HTTP and Ping, but it&#8217;s so<br \/>\neasy to write new ones that I will be releasing a few more in the next<br \/>\ndays.<\/p>\n<p>Also, there are only three expectation matchers: response time, response body<br \/>\nand response code. I believe they are able to cover most of the cases, but it is also<br \/>\nvery easy to write new expectations.<\/p>\n<p>Below is another example of an Outpost, based on the integration tests:<\/p>\n<pre lang=\"ruby\">require 'outpost'\r\nrequire 'outpost\/scouts'\r\n\r\nclass ExamplePingAndHttp < Outpost::DSL\r\n using Outpost::Scouts::Http => 'master http server' do\r\n   options :host => 'localhost', :port => 9595, :path => '\/'\r\n   report :up, :response_body => {:match => \/Up\/}\r\n end\r\n\r\n using Outpost::Scouts::Ping => 'load balancer' do\r\n   options :host => 'localhost'\r\n   report :up, :response_time => {:less_than => 500}\r\n end\r\nend<\/pre>\n<p>For more details, please check the <a rel=\"nofollow\" href=\"http:\/\/www.github.com\/vinibaggio\/outpost\">project&#8217;s README, on GitHub<\/a>.<\/p>\n<h3>The future<\/h3>\n<p>My plans for Outpost are: SSH support, so you can connect to servers that do<br \/>\nnot expose their services to the outer world, a very simple web dashboard to show<br \/>\nthe results, better error reporting (for now you can only know which Scout<br \/>\nfailed, but not why), a script that automatically generates Outposts for Rails<br \/>\napps, and the list goes on!<\/p>\n<p>Crazy idea: wouldn&#8217;t it be nice to have a script that reads Outposts and<br \/>\ntells if a machine is ready to be in production? TDD for machines? Woot!<\/p>\n<h3>Thanks<\/h3>\n<p>This project was my personal project for RMU (Ruby Mendicant University) and<br \/>\nso I would like to thank all the people involved for the amazing experience and<br \/>\nreviews on the project. Also thanks to my friends for listening me nagging<br \/>\nabout this project for a while. Finally, thanks to Tom\u00e1s D&#8217;Stefano, who<br \/>\ndid some work on my previous attempt to write Outpost, your work won&#8217;t be<br \/>\nthrown away.<\/p>\n<h3>Closing<\/h3>\n<p>Please share your thoughts about this project. I would love to know your opinion!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Outpost is me, scratching my own itch. For a while now, freelancing or working for others, I work with pretty much all the stack in web development: from front-end development with HTML and CSS up to the system administration. And sometimes, I screw up. Sometimes, stuff go wrong. Maybe that Sphinx isn&#8217;t getting indexed or &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2011\/02\/outpost-v0-1-0-is-released\/\">\u00bb<\/a><\/p>\n","protected":false},"author":10,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[138,139,137,60],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1731"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/10"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=1731"}],"version-history":[{"count":15,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1731\/revisions"}],"predecessor-version":[{"id":1752,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1731\/revisions\/1752"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=1731"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=1731"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=1731"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}