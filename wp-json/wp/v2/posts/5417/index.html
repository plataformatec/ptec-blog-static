{"id":5417,"date":"2016-05-17T16:02:05","date_gmt":"2016-05-17T19:02:05","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5417"},"modified":"2016-10-31T16:57:13","modified_gmt":"2016-10-31T18:57:13","slug":"how-to-config-environment-variables-with-elixir-and-exrm","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/05\/how-to-config-environment-variables-with-elixir-and-exrm\/","title":{"rendered":"How to config environment variables with Elixir and Exrm"},"content":{"rendered":"<p>It&#8217;s very common (and highly recommended) that application keeps its configuration values separated from its version control. A way of doing this is by using <strong>ENV vars<\/strong> (environment variables). They&#8217;re being used for improvements mostly on maintainability. The 12-factor app manifesto explains it <a href=\"http:\/\/12factor.net\/config\" target=\"_blank\">on its Configuration section<\/a>:<\/p>\n<blockquote style=\"font-size: 1.1em; border-left: solid 4px #ccc; padding-left: 15px; color: #888;\"><p><em>The twelve-factor app stores config in environment variables (often shortened to env vars or env). Env vars are easy to change between deploys without changing any code; unlike config files, there is little chance of them being checked into the code repo accidentally; and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard.<\/em><\/p><\/blockquote>\n<p>In an Elixir project, the config goes in <code>Mix.Config<\/code> files. Some examples are: <code>config.exs<\/code> and environment config files (<code>dev.exs<\/code>, <code>test.exs<\/code> and <code>prod.exs<\/code>). These files are generally used by frameworks and libraries, but they have already proven useful for <a href=\"http:\/\/blog.plataformatec.com.br\/2015\/10\/mocks-and-explicit-contracts\/\" target=\"_blank\">using mocks in our tests<\/a>.<\/p>\n<p>Let&#8217;s take an <a href=\"https:\/\/github.com\/elixir-lang\/ecto\" target=\"_blank\"><strong>Ecto<\/strong><\/a> config as example:<\/p>\n<pre><code class=\"elixir\"># config\/dev.exs\nconfig :myapp, MyApp.Repo,\nadapter: Ecto.Adapters.Postgres,\nusername: \"postgres\",\npassword: \"postgres\",\ndatabase: \"myapp_dev\",\nhostname: \"localhost\",\npool_size: 10\n<\/code><\/pre>\n<p>A well-known approach is using <a href=\"https:\/\/en.wikipedia.org\/wiki\/Environment_variable\" target=\"_blank\"><strong>Environment variables<\/strong><\/a> to hide and scope these values through different environments. To use it, we just need to have a configured variable and get it in our application. In Elixir we do this easily with <a href=\"http:\/\/elixir-lang.org\/docs\/stable\/elixir\/System.html#get_env\/1\" target=\"_blank\"><code>System.get_env(\"ENV_VAR\")<\/code><\/a>.<\/p>\n<p>We could configure our last example with this approach:<\/p>\n<pre><code class=\"elixir\"># config\/dev.exs\nconfig :myapp, MyApp.Repo,\nadapter: Ecto.Adapters.Postgres,\nusername: System.get_env(\"DB_USER\"),\npassword: System.get_env(\"DB_PASSWORD\"),\ndatabase: System.get_env(\"DB_NAME\"),\nhostname: System.get_env(\"DB_HOST\"),\npool_size: 10\n<\/code><\/pre>\n<p>This way you won&#8217;t expose your database configs and will actually make things more dynamic. In development this is useful because the developers won&#8217;t need to make changes on this file, they&#8217;ll just need to export these vars.<\/p>\n<p>So far this isn&#8217;t much different from what we do in other languages. However, things start to happen differently when we try to generate an Exrm release to deploy our app in production.<\/p>\n<h2>ENV vars need to be present during compile time<\/h2>\n<p>We all already know that Elixir is a compiled language. And in order to deploy or generate a release we need to compile our application. So everything is compiled, even our config files! Then, there&#8217;s an interesting behavior while compiling our config files.<\/p>\n<p>Our <code>System.get_env()<\/code> calls will be evaluated during the compilation, so the binaries will be generated with the current value of the ENV var. Because of this, we need all of our environment variables to be exported during compiling. When we don&#8217;t have them, their value will be <code>nil<\/code> and we won&#8217;t be able to connect to our database, for example. This way, to build a release we&#8217;d need all our environment variables where we&#8217;re building it (our own machine or a build server).<\/p>\n<p>If we&#8217;re <strong>working with Phoenix<\/strong>, there is an exception. Phoenix has a special way of configuring an HTTP port with ENV vars that evaluates it during runtime.<\/p>\n<pre><code class=\"elixir\">config :myapp, MyApp.Endpoint,\nhttp: [port: {:system, \"PORT\"}],\n# ...\n<\/code><\/pre>\n<p>It works great and data won&#8217;t be fixed in the release, but it&#8217;s <a href=\"https:\/\/github.com\/phoenixframework\/phoenix\/blob\/v1.1.4\/lib\/phoenix\/endpoint\/server.ex#L45\" target=\"_blank\">specific for this Phoenix config<\/a>. But don&#8217;t be sad! There are already some <a href=\"https:\/\/github.com\/bitwalker\/exrm\/issues\/90\" target=\"_blank\">mature discussions<\/a> around this in the Exrm repo, take a look, you may be able to help!<\/p>\n<h2>There&#8217;s a way when using Exrm release<\/h2>\n<p>I was chatting around <a href=\"https:\/\/elixir-lang.slack.com\/\" target=\"_blank\">Elixir Slack channel<\/a><a href=\"\"><\/a> when our friend <a href=\"https:\/\/twitter.com\/renanranelli\" target=\"_blank\">Ranelli<\/a> mentioned that there was a simple technique that we could use to solve this when we build an Exrm release. Instead of using <code>System.get_env<\/code> in our configs, we must use <code>\"${ENV_VAR}\"<\/code>. Then, we just need to run our release with <code>RELX_REPLACE_OS_VARS=true<\/code>.<\/p>\n<p><code>RELX_REPLACE_OS_VARS=true rel\/myapp\/bin\/myapp start<\/code><\/p>\n<p>This will make our release to use the values represented by these special strings. I&#8217;ll explain.<\/p>\n<p>An Exrm release has two important files: <code>sys.config<\/code> and <code>vm.args<\/code>. These files are responsible by the data used in production (usually what&#8217;s in <code>config.exs<\/code> and <code>prod.exs<\/code>) and specific configs that we can make of the Erlang VM respectively.<\/p>\n<h3>sys.config<\/h3>\n<pre><code class=\"erlang\">[{sasl,[{errlog_type,error}]},\n{logger,\n[{console,\n[{format,&lt;&lt;\"$time $metadata[$level] $message\\n\"&gt;&gt;},\n{metadata,[request_id]}]},\n{level,info}]},\n{myapp,\n[{'Elixir.MyApp.Endpoint',\n[{root,&lt;&lt;\"\/Users\/igorffs\/src\/myapp\"&gt;&gt;},\n{render_errors,[{accepts,[&lt;&lt;\"html\"&gt;&gt;,&lt;&lt;\"json\"&gt;&gt;]}]},\n{pubsub,\n[{name,'Elixir.MyApp.PubSub'},\n{adapter,'Elixir.Phoenix.PubSub.PG2'}]},\n{http,[{port,&lt;&lt;\"${PORT}\"&gt;&gt;}]},\n{url,[{host,&lt;&lt;\"localhost\"&gt;&gt;}]},\n{cache_static_manifest,&lt;&lt;\"priv\/static\/manifest.json\"&gt;&gt;},\n{server,true},\n{secret_key_base,\n&lt;&lt;\"${SECRET_KEYBASE}\"&gt;&gt;}]},\n{'Elixir.MyApp.Repo',\n[{adapter,'Elixir.Ecto.Adapters.Postgres'},\n{username,&lt;&lt;\"${DB_USER}\"&gt;&gt;},\n{password,&lt;&lt;\"${DB_PASSWORD}\"&gt;&gt;},\n{database,&lt;&lt;\"${DB_NAME}\"&gt;&gt;},\n{hostname,&lt;&lt;\"localhost\"&gt;&gt;},\n{pool_size,10},\n{port,&lt;&lt;\"15432\"&gt;&gt;}]}]},\n{phoenix,[{generators,[{migration,true},{binary_id,false}]}]}].\n<\/code><\/pre>\n<h3>vm.args<\/h3>\n<pre><code class=\"erlang\">## Name of the node\n-sname myapp\n\n## Cookie for distributed erlang\n-setcookie myapp\n\n## Heartbeat management; auto-restarts VM if it dies or becomes unresponsive\n## (Disabled by default..use with caution!)\n##-heart\n\n## Enable kernel poll and a few async threads\n##+K true\n##+A 5\n\n## Increase number of concurrent ports\/sockets\n##-env ERL_MAX_PORTS 4096\n\n## Tweak GC to run more often\n##-env ERL_FULLSWEEP_AFTER 10\n<\/code><\/pre>\n<p>Exrm is using a lib called <a href=\"https:\/\/github.com\/erlware\/relx\" target=\"_blank\"><strong>relx<\/strong><\/a> under the hood to build its releases. When we exported <code>RELX_REPLACE_OS_VARS=true<\/code> <code>relx<\/code> will make a replace of the strings by their correspondent ENV var values in the config files.<\/p>\n<pre><code class=\"erlang\">{'Elixir.MyApp.Repo',\n[{adapter,'Elixir.Ecto.Adapters.Postgres'},\n{username,&lt;&lt;\"${DB_USER}\"&gt;&gt;},\n{password,&lt;&lt;\"${DB_PASSWORD}\"&gt;&gt;},\n{database,&lt;&lt;\"${DB_NAME}\"&gt;&gt;},\n{hostname,&lt;&lt;\"localhost\"&gt;&gt;},\n{pool_size,10},\n{port,&lt;&lt;\"15432\"&gt;&gt;}]}\n<\/code><\/pre>\n<p>You&#8217;ve noticed where our special strings are in the <code>sys.config<\/code>, and if you guessed that this process can be done manually, you got it! But this replace really makes things easier for us. Otherwise, we would have to edit every option in the file. It&#8217;s very important to mention, if you change those files, you&#8217;ll have to reboot your application.<\/p>\n<h2>Considerations<\/h2>\n<p>This subject is very important if we&#8217;re going on production. It concerned us a bit when we&#8217;ve noticed that we couldn&#8217;t have more dynamic configs. This replacement solution was a relief. Make sure to keep following <a href=\"https:\/\/github.com\/bitwalker\/exrm\/issues\/90\" target=\"_blank\">the discussion I mentioned before<\/a>, things are probably going to change after it.<\/p>\n<p>Have you already been in trouble dealing with ENV vars? How did you solve it?<\/p>\n<p><a href=\"http:\/\/pages.plataformatec.com.br\/ebook-whats-new-in-ecto-2-0?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=ebook-ecto-2-0&amp;utm_content=cta-blog-post-bottom\" target=\"_blank\"><br \/>\n<img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-5371\" style=\"max-width: 100%;\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0.png\" alt=\"What's new in Ecto 2.0 -- Reserve your copy\" width=\"831\" height=\"147\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0.png 831w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0-300x53.png 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0-768x136.png 768w\" sizes=\"(max-width: 831px) 100vw, 831px\" \/><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>It&#8217;s very common (and highly recommended) that application keeps its configuration values separated from its version control. A way of doing this is by using ENV vars (environment variables). They&#8217;re being used for improvements mostly on maintainability. The 12-factor app manifesto explains it on its Configuration section: The twelve-factor app stores config in environment variables &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/05\/how-to-config-environment-variables-with-elixir-and-exrm\/\">\u00bb<\/a><\/p>\n","protected":false},"author":38,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[249,230,143,245],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5417"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/38"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5417"}],"version-history":[{"count":16,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5417\/revisions"}],"predecessor-version":[{"id":5776,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5417\/revisions\/5776"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5417"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5417"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5417"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}