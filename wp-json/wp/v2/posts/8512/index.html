{"id":8512,"date":"2019-01-28T15:00:34","date_gmt":"2019-01-28T17:00:34","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=8512"},"modified":"2019-09-06T15:33:58","modified_gmt":"2019-09-06T18:33:58","slug":"custom-authentication-methods-with-devise","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2019\/01\/custom-authentication-methods-with-devise\/","title":{"rendered":"Custom authentication methods with Devise"},"content":{"rendered":"<p>In the past, we have been asked to include other authentication methods in Devise (e.g. token-based and <a href=\"https:\/\/github.com\/plataformatec\/devise\/issues\/4724\" target=\"_blank\" rel=\"noopener noreferrer\">magic email links<\/a>). Although it might make sense to include those for some applications, there is no plan to support them in Devise.<\/p>\n<p>But don&#8217;t be upset, it turns out you might not need to override Devise&#8217;s <code>SessionsController<\/code> or monkey patch some of its internals. In this article, you&#8217;ll learn how to create a token-based authentication for a JSON API by relying on <a href=\"https:\/\/github.com\/wardencommunity\/warden\/wiki\/Strategies\" target=\"_blank\" rel=\"noopener noreferrer\">Warden&#8217;s features<\/a>.<\/p>\n<h2>Disclaimers<\/h2>\n<h3>Warden? Huh?<\/h3>\n<p>This article will focus on how to include custom Warden strategies in a Rails application that uses Devise. If you want to know more about Warden strategies, I gave <a href=\"https:\/\/www.youtube.com\/watch?v=QBJ3G40fxHg\" target=\"_blank\" rel=\"noopener noreferrer\">a talk<\/a> last year at RailsConf that explains them in more details.<\/p>\n<h3>Show me the code!<\/h3>\n<p>The first part of this article will show how to set up a Rails application using Devise. If you want to skip to the token authentication part, click <a href=\"#the-api-token-strategy\">here<\/a>.<\/p>\n<h2>Setup<\/h2>\n<p>Create a new Rails application (this example uses Postgres as the database to take advantage of <a href=\"https:\/\/en.wikipedia.org\/wiki\/Universally_unique_identifier\" target=\"_blank\" rel=\"noopener noreferrer\">UUID<\/a>s to generate the access tokens):<\/p>\n<pre><code class=\"bash\">rails new devise-token-based-auth --database=postgresql\n<\/code><\/pre>\n<p>Add the <code>devise<\/code> gem to your Gemfile:<\/p>\n<pre><code class=\"ruby\">gem 'devise'\n<\/code><\/pre>\n<p>Now run the Devise generators:<\/p>\n<pre><code class=\"bash\">rails generate devise:install\nrails generate devise User\n<\/code><\/pre>\n<p>We are going to need a column to store the <code>api_token<\/code>. For this, we&#8217;ll use the <a href=\"https:\/\/www.postgresql.org\/docs\/10\/pgcrypto.html\" target=\"_blank\" rel=\"noopener noreferrer\">pgcrypto<\/a> extension&#8217;s <code>gen_random_uuid()<\/code> function.<\/p>\n<p>First, create a migration to enable the <code>pgcrypto<\/code> extension:<\/p>\n<pre><code class=\"bash\">rails generate migration enable_pgcrypto_extension\n<\/code><\/pre>\n<p>Now edit the migration to call the <code>#enable_extension<\/code> method:<\/p>\n<pre><code class=\"ruby\">class EnablePgcryptoExtension &lt; ActiveRecord::Migration[5.2]\n  def change\n    enable_extension 'pgcrypto'\n  end\nend\n<\/code><\/pre>\n<p>The database is now able to use <code>pgcrypto<\/code>&#8216;s functions. Now we can create a migration to add the <code>api_token<\/code> column:<\/p>\n<pre><code class=\"bash\">rails generate migration add_api_token_to_users\n<\/code><\/pre>\n<p>Now edit the migration like the one below. Notice the default is set to <code>gen_random_uuid()<\/code>:<\/p>\n<pre><code class=\"ruby\">class AddApiTokenToUsers &lt; ActiveRecord::Migration[5.2]\n  def change\n    add_column :users, :api_token, :string, default: -&gt; { 'gen_random_uuid()' }\n    add_index :users, :api_token, unique: true\n  end\nend\n<\/code><\/pre>\n<p>Don&#8217;t forget to create the database and run the migrations:<\/p>\n<pre>rails db:create db:migrate<\/pre>\n<p>The next step is to create a user using <code>rails console<\/code> and grab its <code>api_token<\/code>:<\/p>\n<pre><code class=\"bash\">rails console\nRunning via Spring preloader in process 60784\nLoading development environment (Rails 5.2.2)\nirb(main):001:0&gt; user = User.create!(email: 'bruce@wayne.com', password: '123123')\n=&gt; #\nirb(main):002:0&gt; user.reload.api_token\n=&gt; \"a4839b85-4c96-4f22-96f1-c2568e5d6a7f\"\n<\/code><\/pre>\n<p>It&#8217;s time to create the Warden strategy now!<\/p>\n<h2 id=\"the-api-token-strategy\">The Api Token Strategy<\/h2>\n<p>Create a file <code>app\/strategies\/api_token_strategy.rb<\/code> with the following content:<\/p>\n<pre><code class=\"ruby\">class ApiTokenStrategy &lt; Warden::Strategies::Base\n  def valid?\n    api_token.present?\n  end\n\n  def authenticate!\n    user = User.find_by(api_token: api_token)\n\n    if user\n      success!(user)\n    else\n      fail!('Invalid email or password')\n    end\n  end\n\n  private\n\n  def api_token\n    env['HTTP_AUTHORIZATION'].to_s.remove('Bearer ')\n  end\nend\n<\/code><\/pre>\n<p>In short, the strategy tries to find a user for the token sent in the <code>Authorization<\/code> header. If it does, it signs the user in. Otherwise, it returns an error. If you are not familiar with the <code>success!<\/code> and <code>fail!<\/code> methods, watch the talk on the start of the blog post to get a sense on how Warden works.<\/p>\n<p>Warden needs to know about this strategy. Create a file <code>config\/initializers\/warden.rb<\/code> with the following code:<\/p>\n<pre><code class=\"ruby\">Warden::Strategies.add(:api_token, ApiTokenStrategy)\n<\/code><\/pre>\n<p>This allows Warden to recognise that it should call the <code>ApiTokenStrategy<\/code> when it receives the <code>:api_token<\/code> symbol.<\/p>\n<h2>Authenticating a user<\/h2>\n<p>Now it&#8217;s time to use the strategy. Create an <code>UsersController<\/code> that renders the <code>current_user<\/code> in JSON:<\/p>\n<pre><code class=\"ruby\">class UsersController &lt; ApplicationController\n  def show\n    render json: current_user.to_json\n  end\nend\n<\/code><\/pre>\n<p>Don&#8217;t forget to add a route for this controller action. Open <code>config\/routes.rb<\/code> in your editor and include the following:<\/p>\n<pre><code class=\"ruby\">Rails.application.routes.draw do\n  devise_for :users\n  resource :user, only: :show\nend\n<\/code><\/pre>\n<p>To require authentication in the controller, the method <code>#authenticate!<\/code> should be called passing the desired strategy as a parameter:<\/p>\n<pre><code class=\"ruby\">class UsersController &lt; ApplicationController\n  def show\n    warden.authenticate!(:api_token)\n    render json: current_user.to_json\n  end\nend\n<\/code><\/pre>\n<p>You can see that this works using a simple <code>curl<\/code> request:<\/p>\n<pre><code class=\"bash\">curl http:\/\/localhost:3000\/user -H 'Authorization: Bearer a4839b85-4c96-4f22-96f1-c2568e5d6a7f'\n\n{\"id\":3,\"email\":\"bruce@wayne.com\",\"created_at\":\"2018-12-26T13:45:37.473Z\",\"updated_at\":\"2018-12-26T13:45:37.473Z\",\"api_token\":\"a4839b85-4c96-4f22-96f1-c2568e5d6a7f\"}\n<\/code><\/pre>\n<p>It is also possible to define <code>:api_token<\/code> as a default strategy so that it&#8217;s called when no strategy is passed as a parameter. Add the following code in the <code>config\/initializers\/devise.rb<\/code> file:<\/p>\n<pre><code class=\"ruby\">Devise.setup do |config|\n   # The secret key used by Devise. Devise uses this key to generate...\n   config.warden do |manager|\n     manager.default_strategies(scope: :user).unshift :api_token\n   end\n\n# ==&gt; Mountable engine configurations...\nend\n<\/code><\/pre>\n<p>This will add the&nbsp;<code>:api_token<\/code> strategy in the first position, followed by Devise&#8217;s default strategies (<code>:rememberable<\/code> and <code>:database_authenticatable<\/code>).<\/p>\n<p>Now it&#8217;s possible to use Devise&#8217;s <code>#authenticate_user!<\/code> helper, and the <code>:api_token<\/code> will still be used:<\/p>\n<pre><code class=\"ruby\">class UsersController &lt; ApplicationController\n  before_action :authenticate_user!\n\n  def show\n    render json: current_user.to_json\n  end\nend\n<\/code><\/pre>\n<h2>Summary<\/h2>\n<p>And&#8230; we&#8217;re done! The focus here was to show how to include custom Warden strategies in a Rails application. The example was straightforward but you can follow this structure to create custom authentication logic to suit your application&#8217;s needs.<\/p>\n<p>The entire application used in this article can be found in <a href=\"https:\/\/github.com\/tegon\/devise-token-based-auth\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub<\/a>.<\/p>\n\n\n<p><\/p>\n","protected":false},"excerpt":{"rendered":"<p>In the past, we have been asked to include other authentication methods in Devise (e.g. token-based and magic email links). Although it might make sense to include those for some applications, there is no plan to support them in Devise. But don&#8217;t be upset, it turns out you might not need to override Devise&#8217;s SessionsController &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2019\/01\/custom-authentication-methods-with-devise\/\">\u00bb<\/a><\/p>\n","protected":false},"author":54,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[36,7],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8512"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/54"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=8512"}],"version-history":[{"count":18,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8512\/revisions"}],"predecessor-version":[{"id":9298,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8512\/revisions\/9298"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=8512"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=8512"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=8512"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}