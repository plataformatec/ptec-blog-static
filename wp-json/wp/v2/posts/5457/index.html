{"id":5457,"date":"2016-06-07T17:32:27","date_gmt":"2016-06-07T20:32:27","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5457"},"modified":"2016-06-07T17:37:37","modified_gmt":"2016-06-07T20:37:37","slug":"deploying-elixir-applications-with-edeliver","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/06\/deploying-elixir-applications-with-edeliver\/","title":{"rendered":"Deploying Elixir applications with Edeliver"},"content":{"rendered":"<p>We&#8217;ve been talking about deploy and releases with Elixir lately, like <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/04\/running-migration-in-an-exrm-release\/\">how to run migrations on top of a release<\/a> or <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/05\/how-to-config-environment-variables-with-elixir-and-exrm\/\">how to deal with environment variables<\/a>. Now it&#8217;s time to discover another tool that can help us release our Elixir application.<\/p>\n<p>After practicing deploy and <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/04\/how-to-trace-elixir-nodes-with-erlyberly\/\">tracing through nodes<\/a> with <a href=\"https:\/\/github.com\/bitwalker\/exrm\" target=\"_blank\">Exrm<\/a>, we got more comfortable knowing that there is a tool we can count on for managing production releases. Our next biggest concern was how could we make the deploy process more manageable. We couldn&#8217;t stop thinking about Capistrano, which we normally use for our Rails projects, then we found <a href=\"https:\/\/github.com\/boldpoker\/edeliver\" target=\"_blank\">Edeliver<\/a>. From Edeliver&#8217;s README description:<\/p>\n<blockquote style=\"font-size: 1.1em; font-style: italic; border-left: solid 4px #ccc; padding-left: 15px; color: #888;\"><p>edeliver is based on deliver and provides a bash script to build and deploy Elixir and Erlang applications and perform hot-code upgrades.<\/p><\/blockquote>\n<p>Trying the whole deploy process manually was a bit harsh with some repetitive tasks. Using Edeliver for our first <code>script\/deploy<\/code> was awkwardly easy! In the end, the whole manual process was simplified to:<\/p>\n<pre><code class=\"bash\">    #!\/bin\/bash -ex\n\n    BRANCH=${1:-master};\n\n    mix edeliver build release --branch=BRANCH --verbose\n    mix edeliver deploy release to production --verbose\n    mix edeliver start production --verbose\n    mix edeliver migrate production up --verbose\n<\/code><\/pre>\n<p>You&#8217;re probably going to need to customize this script, adapting it for your needs. In this case, we&#8217;re using this script only for production deploys, but you can customize it for staging servers pretty easily. We&#8217;ll explain how environments work further along.<\/p>\n<h2>How it works<\/h2>\n<p>As we saw before in the README quote, Edeliver makes pretty much everything with bash scripts. The Mix tasks we saw above will be executed with Elixir, but they&#8217;ll result in bash script instructions. Part of the instructions are executed in the scripts locally, which will build new instructions that will run remotely via RPC (Remote procedure call).<\/p>\n<p>Let&#8217;s go deeper in some aspects of the lib.<\/p>\n<h2>Environments<\/h2>\n<p>Edeliver is a cool option for launching and distributing releases in multiple environments. It has a concept of three environments: build, staging and production. Among these, only the build environment should get a bit more of attention.<\/p>\n<p>For a release to work in a server, it must have been built in a machine with the same architecture where the release will run. That&#8217;s because Edeliver uses Exrm for building its releases. Exrm will internally use its local <a href=\"http:\/\/erlang.org\/doc\/tutorial\/nif.html\" target=\"_blank\">NIFs<\/a> (C functions used by Erlang) which may vary in a different architecture, thus causing, for example, an OSX release not working on Linux. You can read more about it in <a href=\"https:\/\/github.com\/phoenixframework\/phoenix_guides\/issues\/254\" target=\"_blank\">this Phoenix issue<\/a> where people are discussing cross-compiling issues and there are some other <a href=\"https:\/\/github.com\/bitwalker\/exrm\/issues?utf8=%E2%9C%93&#038;q=is%3Aissue+cross+compiling+\" target=\"_blank\">issues in Exrm<\/a> as well.<\/p>\n<p>In order to use the build environment in our own development machine, it needs to use the same architecture of our staging and production servers, otherwise it won&#8217;t work.<\/p>\n<p>To configure our environments, we&#8217;ll need to create a <code>.deliver<\/code> directory in our project and add a <code>config<\/code> file. Let&#8217;s see the suggested configs from Edeliver&#8217;s README for this file:<\/p>\n<pre><code class=\"bash\">#!\/usr\/bin\/env bash\n\nAPP=\"your-erlang-app\" # name of your release\n\nBUILD_HOST=\"build-system.acme.org\" # host where to build the release\nBUILD_USER=\"build\" # local user at build host\nBUILD_AT=\"\/tmp\/erlang\/my-app\/builds\" # build directory on build host\n\nSTAGING_HOSTS=\"test1.acme.org test2.acme.org\" # staging \/ test hosts separated by space\nSTAGING_USER=\"test\" # local user at staging hosts\nTEST_AT=\"\/test\/my-erlang-app\" # deploy directory on staging hosts. default is DELIVER_TO\n\nPRODUCTION_HOSTS=\"deploy1.acme.org deploy2.acme.org\" # deploy \/ production hosts separated by space\nPRODUCTION_USER=\"production\" # local user at deploy hosts\nDELIVER_TO=\"\/opt\/my-erlang-app\" # deploy directory on production hosts\n<\/code><\/pre>\n<p>It&#8217;s pretty easy to configure our environments, we only need to make sure we have <code>ssh<\/code> permission for these servers specified. A cool thing about this whole configuration, as mentioned before, is that it&#8217;s possible to distribute the releases through several servers.<\/p>\n<h2>How can I include extra tasks to my deploy process?<\/h2>\n<p>What Edeliver does is generic for Elixir and Erlang applications. When we&#8217;re using Phoenix, for example, we need to run some tasks before generating the release. The most important tasks are <code>brunch build --production<\/code> and <code>mix phoenix.digest<\/code> so we can have our assets working on our release.<\/p>\n<p>To make these work, we&#8217;ll need to define a hook in our <code>.deliver\/config<\/code> file:<\/p>\n<pre><code class=\"bash\">pre_erlang_clean_compile() {\n  status \"Preparing assets with: brunch build and phoenix.digest\"\n  __sync_remote \"\n    # runs the commands on the build host\n    [ -f ~\/.profile ] &amp;&amp; source ~\/.profile # load profile (optional)\n\n    # fail if any command fails (recommended)\n    set -e\n\n    # enter the build directory on the build host (required)\n    cd '$BUILD_AT'\n\n    mkdir -p priv\/static # required by the phoenix.digest task\n\n    # installing npm dependencies\n    npm install\n\n    # building brunch\n    brunch build --production\n\n    # run your custom task\n    APP='$APP' MIX_ENV='$TARGET_MIX_ENV' $MIX_CMD phoenix.digest $SILENCE\n  \"\n} \n<\/code><\/pre>\n<p>This was extracted from an Edeliver doc sample, which explains all the possibilities of hooks.<\/p>\n<h2>What about my environment variables?<\/h2>\n<p>We shared a tip on <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/05\/how-to-config-environment-variables-with-elixir-and-exrm\/\">dealing with environment variables with Exrm<\/a> in order to avoid exporting them in our build environment and it&#8217;s still up! Although, there&#8217;s an important detail we&#8217;ll need to pay attention.<\/p>\n<p>In order to make the environments replaceable we needed to set <code>RELX_REPLACE_OS_VARS=true<\/code> before our start command. But that&#8217;s not possible with Edeliver because the start task runs locally.<\/p>\n<p><code>mix edeliver start production<\/code><\/p>\n<p>Then a possible solution is to export the <code>RELX_REPLACE_OS_VARS<\/code> in your production environment.<\/p>\n<h2>Considerations<\/h2>\n<p>Edeliver seems like a cool option for dealing with our releases and deploy process, I found it really easy to use. I didn&#8217;t enter in implementation details in this post, so make sure to read its <a href=\"https:\/\/github.com\/boldpoker\/edeliver\" target=\"_blank\">README<\/a> and docs, they&#8217;re very useful and well-explained.<\/p>\n<p>This was a solution we found to ease our deploy process. How have you been managing your process? Did this post help you?<\/p>\n<hr>\n<div style=\"margin:30px 0 60px;\">\n<p style=\"text-align:center; margin-bottom:0; padding-bottom:0; font-weight:bold; font-size:1em; color:#444;\">If you are into Elixir-Phoenix, you may also like&#8230;<\/p>\n<p><a href=\"http:\/\/pages.plataformatec.com.br\/ebook-whats-new-in-ecto-2-0?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=ebook-ecto-2-0&amp;utm_content=cta-blog-post-bottom-with-title\" target=\"_blank\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-5371\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0.png\" alt=\"What's new in Ecto 2.0 -- Reserve your copy\" width=\"831\" height=\"147\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0.png 831w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0-300x53.png 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/CTA-blog-ebook-ecto-2-0-768x136.png 768w\" sizes=\"(max-width: 831px) 100vw, 831px\" \/><\/a>\n<\/div>\n","protected":false},"excerpt":{"rendered":"<p>We&#8217;ve been talking about deploy and releases with Elixir lately, like how to run migrations on top of a release or how to deal with environment variables. Now it&#8217;s time to discover another tool that can help us release our Elixir application. After practicing deploy and tracing through nodes with Exrm, we got more comfortable &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/06\/deploying-elixir-applications-with-edeliver\/\">\u00bb<\/a><\/p>\n","protected":false},"author":38,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[249,230,143,245],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5457"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/38"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5457"}],"version-history":[{"count":16,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5457\/revisions"}],"predecessor-version":[{"id":5460,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5457\/revisions\/5460"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5457"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5457"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5457"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}