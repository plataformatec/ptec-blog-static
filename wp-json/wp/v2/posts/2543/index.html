{"id":2543,"date":"2012-03-06T15:40:36","date_gmt":"2012-03-06T18:40:36","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=2543"},"modified":"2012-03-12T15:40:17","modified_gmt":"2012-03-12T18:40:17","slug":"barebone-models-to-use-with-actionpack-in-rails-4-0","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2012\/03\/barebone-models-to-use-with-actionpack-in-rails-4-0\/","title":{"rendered":"Barebone models to use with ActionPack in Rails 4.0"},"content":{"rendered":"<p>Rails 4.0 &#8211; current master branch at the time of this writing &#8211; <a href=\"https:\/\/github.com\/rails\/rails\/commit\/3b822e91d1a6c4eab0064989bbd07aae3a6d0d08\" title=\"Rails 4.0: ActiveModel::Model\">has recently got a small &#8211; yet very useful &#8211; addition: <code>ActiveModel::Model<\/code><\/a>. The implementation is really simple, as you can see below:<\/p>\n<pre lang=\"ruby\">\r\nmodule ActiveModel\r\n  module Model\r\n    def self.included(base)\r\n      base.class_eval do\r\n        extend  ActiveModel::Naming\r\n        extend  ActiveModel::Translation\r\n        include ActiveModel::Validations\r\n        include ActiveModel::Conversion\r\n      end\r\n    end\r\n\r\n    def initialize(params={})\r\n      params.each do |attr, value|\r\n        self.public_send(\"#{attr}=\", value)\r\n      end if params\r\n    end\r\n\r\n    def persisted?\r\n      false\r\n    end\r\n  end\r\nend\r\n<\/pre>\n<p>Quite straightforward, huh? But what does it do, and what are we supposed to do with it?<\/p>\n<h3>ActiveModel::Model: Basic Model implementation<\/h3>\n<p><a href=\"https:\/\/github.com\/rails\/rails\/blob\/master\/activemodel\/lib\/active_model\/model.rb#L3\" title=\"ActiveModel::Model docs\">According to the docs<\/a>, <em><code>ActiveModel::Model<\/code> includes all the required interface for an object to interact with <code>ActionPack<\/code>, using different <code>ActiveModel<\/code> modules. It includes model name instrospection, conversions, translations and validations. In addition to that, it allows you to initialize the object with a hash of attributes, pretty much like <code>ActiveRecord<\/code> does.<\/em><\/p>\n<p>Wait, what? In short: you can easily extend <code>ActiveModel::Model<\/code> in a normal Ruby class and use instances of that class with helpers like <code>form_for<\/code>, <code>dom_id \/ dom_class<\/code>, and any other <code>ActionView<\/code> helper, as you do with <code>ActiveRecord<\/code> objects. It also gives you known method helpers such as <code>human_attribute_name<\/code>.<\/p>\n<p>A minimal implementation could be:<\/p>\n<pre lang=\"ruby\">\r\nclass Person\r\n  include ActiveModel::Model\r\n\r\n  attr_accessor :name, :age\r\n  validates_presence_of :name\r\nend\r\n\r\nperson = Person.new(:name => 'bob', :age => '18')\r\nperson.name # => 'bob'\r\nperson.age # => 18\r\nperson.valid? # => true\r\n<\/pre>\n<p>This is really handy, considering that before this addition, we&#8217;d have to add all that code to have a model up and running to use with <code>ActionView's form_for<\/code>, for instance. Ok, it is not that much code to add, but now we don&#8217;t even need to remember which modules are required for such integration. And I have to add that I&#8217;ve been creating similar classes in different applications lately. Take a moment to think about a contact form, that does not need to be tied to a database: it&#8217;s a common scenario to implement using <code>ActiveModel::Model<\/code>.<\/p>\n<h3>Extending Basic Model even more<\/h3>\n<p>Note that, by default, <code>ActiveModel::Model<\/code> implements <code>persisted?<\/code> to return <code>false<\/code>, which is the most common case. For instance, when used with <code>form_for<\/code>, this means that the generated url would <code>post<\/code> to the <code>create<\/code> action. You may want to override it in your class to simulate a different scenario:<\/p>\n<pre lang=\"ruby\">\r\nclass Person\r\n  include ActiveModel::Model\r\n  attr_accessor :id, :name\r\n\r\n  def persisted?\r\n    self.id == 1\r\n  end\r\nend\r\n\r\nperson = Person.new(:id => 1, :name => 'bob')\r\nperson.persisted? # => true\r\n<\/pre>\n<p>Besides that, if for some reason you need to run code on <code>initialize<\/code>, make sure you call super if you want the attributes hash initialization to happen.<\/p>\n<pre lang=\"ruby\">\r\nclass Person\r\n  include ActiveModel::Model\r\n  attr_accessor :id, :name, :omg\r\n\r\n  def initialize(attributes)\r\n    super\r\n    @omg ||= true\r\n  end\r\nend\r\n\r\nperson = Person.new(:id => 1, :name => 'bob')\r\nperson.omg # => true\r\n<\/pre>\n<p>And remember that, at the end, this is all Ruby: you can include any other module of your own and other <code>ActiveModel<\/code> modules easily in your class. For instance, lets add <code>callbacks<\/code> to our model to mimic <code>ActiveRecord's save<\/code> functionality:<\/p>\n<pre lang=\"ruby\">\r\nclass Person\r\n  include ActiveModel::Model\r\n  extend ActiveModel::Callbacks\r\n\r\n  define_model_callbacks :save\r\n  attr_accessor :id, :name\r\n\r\n  # Just check validity, and if so, trigger callbacks.\r\n  def save\r\n    if valid?\r\n      run_callbacks(:save) { true }\r\n    else\r\n      false\r\n    end\r\n  end\r\nend\r\n<\/pre>\n<p>This gives you <code>before_save<\/code>, <code>after_save<\/code> and <code>around_save<\/code> callbacks. Quick and easy, huh?<\/p>\n<h3>Wrapping up<\/h3>\n<p><code>ActiveModel::Model<\/code> is a really small, handy addition to Rails 4.0, which helps us to get classes that act more like <code>ActiveRecord<\/code> and easily integrate with <code>ActionPack<\/code>.<\/p>\n<p>For more detailed information on other features available, please refer to the <a href=\"https:\/\/github.com\/rails\/rails\/tree\/master\/activemodel\/lib\/active_model\" title=\"ActiveModel available modules\">specific modules included in <code>ActiveModel::Model<\/code><\/a>. Each module includes plenty of docs explaining its functionality. Apart from these included modules, <code>ActiveModel<\/code> itself has a bunch of useful stuff to add to your Ruby classes that are really worth checking out.<\/p>\n<p>This is the kind of thing that makes me a happier Rails developer every day. What about you, what makes you a happier Rails developer? Please take a moment to tell us in the comments section below \ud83d\ude42<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Rails 4 will ship with ActiveModel::Model, a module that includes the minimum required by Action Pack to work in forms, urls and so forth. Learn more about this module, how to use and extend it in this blog post.<\/p>\n","protected":false},"author":7,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[177,92,7,176],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/2543"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/7"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=2543"}],"version-history":[{"count":23,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/2543\/revisions"}],"predecessor-version":[{"id":2593,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/2543\/revisions\/2593"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=2543"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=2543"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=2543"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}