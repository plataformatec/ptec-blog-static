{"id":1312,"date":"2010-08-19T16:48:54","date_gmt":"2010-08-19T19:48:54","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=1312"},"modified":"2010-08-19T19:04:39","modified_gmt":"2010-08-19T22:04:39","slug":"devise-1-1-is-out-and-ready-to-rock-with-rails-3","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2010\/08\/devise-1-1-is-out-and-ready-to-rock-with-rails-3\/","title":{"rendered":"Devise 1.1 is out and ready to rock with Rails 3"},"content":{"rendered":"<p>A couple weeks ago we finally released <a href=\"http:\/\/github.com\/plataformatec\/devise\" target=\"_blank\">Devise 1.1<\/a> which is fully-compatible with Rails 3! Not only that, we&#8217;ve been working with Rails 3 since the first betas and several features were added along the way! Let&#8217;s take a look at those, some architectural changes and see how Devise 1.1 and Rails 3 will change how you handle authentication.<\/p>\n<h3>Pretty URLs with Metal<\/h3>\n<p>A common complaint in Devise 1.0 (for Rails 2.3) was, in order to know which message to show to the user when sign in failed, we had to pass a parameter in the URL as in <code>\/users\/sign_in?unauthenticated=true<\/code> while one would expect us to simply use flash messages. This happened because the redirection was done not from inside a controller, but a Rack application set up in <a href=\"http:\/\/github.com\/hassox\/warden\" target=\"_blank\">Warden<\/a> (a Rack authentication framework Devise relies on) and we could not access flash messages from it.<\/p>\n<p>However, since Rails 3 moved several responsibilities to the Rack layer, including flash messages, we can easily access flash messages from any Rack application, allowing us to remove the parameter from the URL! Even more, Rails 3 provides small, fast, bare bone controllers through <code>ActionController::Metal<\/code>, which we used in Devise to clean and speed up the code considerably.<\/p>\n<h3>Locking goodness<\/h3>\n<p>The <strong>lockable<\/strong> module in Devise also went through a major overhaul. Previously, it already supported <code>:unlock_strategy<\/code> as option, allowing you to specify if the user could be automatically unlocked after a time period, through an e-mail token or both. Now, it also supports <code>:none<\/code> as option, meaning that all unlocking should be done manually.<\/p>\n<p>Even more, there is a new option called :lock_strategy, that allows you to specify whether the lock happens only manually or after an amount of invalid sign in attempts.<\/p>\n<h3>HTTP Authentication on by default<\/h3>\n<p>In Devise 2.3, you may remember that we had a module called <code>:http_authenticable<\/code> along with <code>:database_authenticatable<\/code> and <code>:token_authenticatable<\/code>. While all three worked great, it was confusing that all HTTP authentication features were built on top of the database authentication and it was not possible to do HTTP authentication using a token unless we created a forth module called <code>:http_token_authenticatable<\/code>. We quickly noticed this could be improved by providing a better design and better abstract Devise authentication strategies.<\/p>\n<p>And that is what happened in Devise 1.1. Now both database and token authentication work through HTTP with no extra work and the http authenticatable module was deprecated. Besides, if you are creating a new strategy on your own, you get both authentication through parameters (form) and HTTP with no extra work!<\/p>\n<h3>Routing customizations<\/h3>\n<p>We built Devise to be a full stack solution with customization in mind. In Devise 1.1, the customization abilities from Devise were taken to the next level. Now the <code>devise_for<\/code> method in routes accepts to extra options: <code>:skip<\/code> and <code>:controllers<\/code>. The first one allows you to skip the routes generation for a given controller\/module in case you want to define them on your own, while the second allows you to change the router to point to a given controller in your application, like <code>Users::ConfirmationsController<\/code> instead of Devise&#8217;s internal controller.<\/p>\n<p>Talking about Devise&#8217;s internal controller, Devise 1.1 namespaced all controllers classes, so now we have <code>Devise::ConfirmationsController<\/code> instead of <code>ConfirmationsController<\/code>.<\/p>\n<p>Another limitation removed from Devise in this new version is related to URLs customizations. In prior versions, Devise used the URL to retrieve which scope is being accessed. That said, if you were accessing &#8220;\/users\/sign_in&#8221;, Devise had to inspect this URL and find the &#8220;\/users&#8221; bit to specify the current scope is &#8220;users&#8221;. The same happened to &#8220;\/admin\/sign_in&#8221;.<\/p>\n<p>This had a huge impact in URL customization, because if you wanted to have an URL like &#8220;\/some_prefix\/users\/sign_in&#8221;, you had to tell Devise you were appending a prefix. Things could get even uglier if you wanted to prepend dynamic prefixes like &#8220;\/:locale&#8221;.<\/p>\n<p>In Devise 1.1, we use the new contraints API and Rack capabilities from the new router to specify which scope to use. So, instead of inspecting the URL, Devise retrieves the user from the request&#8217;s env hash as <code>request.env[\"devise.mapping\"]<\/code>.<\/p>\n<p>For all the routes generated by <code>devise_for<\/code>, Devise automatically sets this value in the env hash. However, if you are creating your own routes, you need to set it manually using the constraints API:<\/p>\n<pre lang=\"ruby\">\r\nconstraints lambda { |r| r.env[\"devise.mapping\"] = Devise.mappings[:user] } do\r\n  # Add a custom sign in route for user sign in\r\n  get \"\/sign_in\", :to => \"devise\/sessions\"\r\nend\r\n<\/pre>\n<p>Of course, since this is rather a common pattern, we encapsulated it in a nice API:<\/p>\n<pre lang=\"ruby\">\r\ndevise_scope :user do\r\n  # Add a custom sign in route for user sign in\r\n  get \"\/sign_in\", :to => \"devise\/sessions\"\r\nend\r\n<\/pre>\n<p>You can simply give a block to <code>devise_for<\/code> as well and get the same result:<\/p>\n<pre lang=\"ruby\">\r\ndevise_for :users do\r\n  # Add a custom sign in route for user sign in\r\n  get \"\/sign_in\", :to => \"devise\/sessions\"\r\nend\r\n<\/pre>\n<p>All the routes specified in the block have higher priority than the ones generated by <code>devise_for<\/code>.<\/p>\n<h3>Awesomeness pack<\/h3>\n<p>The last feature we want to discuss is also a routing customization, but we decided to leave it up for last because it shows all the potential coming with Rails 3 and Devise 1.1.<\/p>\n<p>In Devise 1.1, we added the ability to require authentication for a given url in the router, besides the existing before filters in controllers. This allow us to easily require authentication for third party rack application without a need to hack into them. <a href=\"http:\/\/blog.kiskolabs.com\/post\/776939029\/rails3-resque-devise\">Kisko Labs posted<\/a> an interesting case where you can use Devise to require authentication to a Resque application in very few lines of code:<\/p>\n<pre lang=\"ruby\">\r\nauthenticate :admin do\r\n  mount Resque::Server.new, :at => \"\/resque\"\r\nend\r\n<\/pre>\n<p>Devise simply uses the constraints API discussed above, allowing the request to continue only if the user is already authenticated. Otherwise, it redirects the admin to the sign page managed by Devise inside your Rails application. Indeed, when you have Rack, Rails 3 and Devise 1.1 playing along, great things can be accomplished quite easily!<\/p>\n<p>There are several other features, bug fixes and deprecations included in this release, we invite you to check the <a href=\"http:\/\/github.com\/plataformatec\/devise\/blob\/master\/CHANGELOG.rdoc\">CHANGELOG<\/a> and take a look at them!<\/p>\n<p>And we are happy to say this is not all, there is much more to come in Devise 1.2, including OAuth2 support which is already added in the master branch. Enjoy!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>A couple weeks ago we finally released Devise 1.1 which is fully-compatible with Rails 3! Not only that, we&#8217;ve been working with Rails 3 since the first betas and several features were added along the way! Let&#8217;s take a look at those, some architectural changes and see how Devise 1.1 and Rails 3 will change &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2010\/08\/devise-1-1-is-out-and-ready-to-rock-with-rails-3\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[37,36,115],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1312"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=1312"}],"version-history":[{"count":8,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1312\/revisions"}],"predecessor-version":[{"id":1325,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1312\/revisions\/1325"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=1312"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=1312"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=1312"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}