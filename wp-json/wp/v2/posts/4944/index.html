{"id":4944,"date":"2015-12-15T11:20:48","date_gmt":"2015-12-15T13:20:48","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=4944"},"modified":"2015-12-15T11:18:19","modified_gmt":"2015-12-15T13:18:19","slug":"ecto-v1-1-released-and-ecto-v2-0-plans","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2015\/12\/ecto-v1-1-released-and-ecto-v2-0-plans\/","title":{"rendered":"Ecto v1.1 released and Ecto v2.0 plans"},"content":{"rendered":"<p>Ecto v1.1 has been released. Ecto v1.1 brings improvements and bug fixes to Ecto but, more importantly, paves the way for the upcoming Ecto v2.0 release by deprecating functionality that has been said to be error prone or confusing by developers. This article will highlight both improvements and what to expect by Ecto 2.0.<\/p>\n<p>For detailed information on the release, please <a href=\"https:\/\/github.com\/elixir-lang\/ecto\/blob\/v1.1\/CHANGELOG.md\">check the CHANGELOG<\/a>.<\/p>\n<p>Let&#8217;s get started!<\/p>\n<h2>Better pipelines<\/h2>\n<p>The pipeline operator in Elixir is a great way to express a series of computations on top of a data structure. Given Ecto queries are just data structures, they are a perfect fit to be modified as part of pipelines.<\/p>\n<p><a href=\"http:\/\/hexdocs.pm\/ecto\/Ecto.Query.html\">Ecto has always supported both keyword and function queries<\/a>. Let&#8217;s start with a keyword query:<\/p>\n<pre><code class=\"elixir\">from p in Post,\n  where: p.author == \"Jos\u00e9\",\n  order_by: [desc: p.published_at],\n  limit: 5\n<\/code><\/pre>\n<p>In Ecto v1.0, it could have be written using pipelines as follows:<\/p>\n<pre><code class=\"elixir\">Post\n|&gt; where([p], p.author == \"Jos\u00e9\")\n|&gt; order_by([p], desc: p.published_at)\n|&gt; limit(5)\n<\/code><\/pre>\n<p>Ecto v1.1 improve pipelines by making the binding argument required only when working with associations and by allowing dynamic data to be given on more places. In v1.1, we can rewrite the example above as:<\/p>\n<pre><code class=\"elixir\">Post\n|&gt; where(author: \"Jos\u00e9\")\n|&gt; order_by(desc: :published_at)\n|&gt; limit(5)\n<\/code><\/pre>\n<p>Most query operations like <code>where<\/code>, <code>distinct<\/code>, <code>having<\/code> support the syntax above. The only exceptions are <code>select<\/code> and <code>group_by<\/code> which will be tackled on Ecto v2.0.<\/p>\n<h2>No more models<\/h2>\n<p><code>Ecto.Model<\/code> is being deprecated on Ecto v1.1. This aims to solve both conceptual and practical issues. Let&#8217;s discuss them.<\/p>\n<h3>What are models?<\/h3>\n<p>The big question imposed by <code>Ecto.Model<\/code> is: what is a model?<\/p>\n<p>One thing is clear, Ecto did not provide models in the &#8220;traditional&#8221; sense. In OO languages, you would say a model can be instantiated and it would have methods that contain business logic. However, the data that comes from the database in Ecto is just data. It is an Elixir struct. It is not an Ecto model.<\/p>\n<p>Working closely on Phoenix applications and on the <a href=\"https:\/\/pragprog.com\/book\/phoenix\/programming-phoenix\">Programming Phoenix<\/a> book made it clear that, similar to controllers\u00a0and views, models are not an entity. A model, a controller or a view (from the MVC pattern) are just group of functions that share similar responsibilities. They are just guidelines on how to group code towards a common purpose.<\/p>\n<p>For those reasons, <code>Ecto.Model<\/code> is being deprecated in Ecto. At first, this implies Ecto data structures are now defined directly with <code>Ecto.Schema<\/code>. In Ecto v1.0:<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.Post do\n  use Ecto.Model\n\n  schema \"posts\" do\n    # ...\n  end\nend\n<\/code><\/pre>\n<p>From Ecto v1.1:<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.Post do\n  use Ecto.Schema\n\n  schema \"posts\" do\n    # ...\n  end\nend\n<\/code><\/pre>\n<p>Not only that, many of the functions in the <a href=\"http:\/\/hexdocs.pm\/ecto\/Ecto.Model.html\"><code>Ecto.Model<\/code><\/a> module have been moved to <a href=\"http:\/\/hexdocs.pm\/ecto\/Ecto.html\"><code>Ecto<\/code><\/a>.<\/p>\n<p>However, the biggest change with the deprecation of models is that <strong>model callbacks are being removed<\/strong>. To understand why this matters, let&#8217;s look at one Ecto feature that relied on callbacks and was rewritten to be a simple function.<\/p>\n<h3>Optimistic lock<\/h3>\n<p>Ecto provides optimistic locks on top of your schema. A simple implementation of optimistic lock uses an integer column, usually named <code>lock_version<\/code>, to store the current version of a given row. On update, Ecto would do a &#8220;compare and increase&#8221; operation. If the entry being updated had the same <code>lock_version<\/code> as in the database, the update operation succeeds and the <code>lock_version<\/code> is incremented. Otherwise, the update fails because the entry is stale.<\/p>\n<p>On Ecto v1.0, <code>optimistic_lock<\/code> was enabled for the whole model:<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.Post do\n  use Ecto.Model\n\n  schema \"posts\" do\n    # ...\n  end\n\n  optimistic_lock :lock_version\nend\n<\/code><\/pre>\n<p>This reveals the awkwardness behind callbacks. We are suddenly adding &#8220;behaviour&#8221; to our data structures. Not only that, because callbacks are enabled on all operations, we have no control over its use.<\/p>\n<p>For example, what if you also provide an admin interface. Do you want the admin to be under the same lock constraints as regular users? More importantly, what if you want to trigger the lock only if some fields are changing? The only way to add this functionality is by growing the complexity of the <code>optimistic_lock<\/code> implementation by providing an ever growing set of complex options.<\/p>\n<p>It happens Ecto has the perfect solution to this problem: <a href=\"http:\/\/hexdocs.pm\/ecto\/Ecto.Changeset.html\">changesets<\/a>. For example, instead of defining validations in the model, you define per changeset:<\/p>\n<pre><code class=\"elixir\">@required_params [:title, :body]\n@optional_params [:metadata]\n\ndef changeset(post, params \\\\ :empty) do\n  post\n  |&gt; cast(params, @required_params, @optional_params)\n  |&gt; validate_length(:title, min: 3)\n  |&gt; validate_length(:metadata, min: 3)\nend\n<\/code><\/pre>\n<p>In other words, a changeset is a data structure that controls the changes being sent to the database. This means that, if you have different roles in your application that work on different facets of the same data, you define different changesets for every operation.<\/p>\n<p>Ecto v1.1 has replaced the <code>optimistic_lock\/1<\/code> macro implementation by a simple function that works on the changeset. If you want to add optimistic locking, just pipe your changeset in the <code>optimistic_lock\/2<\/code> with the lock column name:<\/p>\n<pre><code class=\"elixir\">def changeset(post, params \\\\ :empty) do\n  post\n  |&gt; cast(params, @required_params, @optional_params)\n  |&gt; validate_length(:title, min: 3)\n  |&gt; validate_length(:metadata, min: 3)\n  |&gt; optimistic_lock(:lock_version)\nend\n<\/code><\/pre>\n<p>Because it is only a function call, you have control of exactly when and where you can apply the lock. And ultimately that&#8217;s the fundamental problem with callbacks: it makes developers write functionality that is hard to compose.<\/p>\n<h3>Goodbye callbacks<\/h3>\n<p>After a quick search on GitHub, we quickly noticed that many developers relied on callbacks in many cases where changesets would suffice, introducing exactly the same problems we saw with <code>optimistic_lock<\/code>.<\/p>\n<p>Furthermore, <code>after_*<\/code> callbacks provide their own set of issues. Because <code>after_insert<\/code> and <code>after_update<\/code> callbacks would still run inside a transaction, there is no guarantee the transaction that wraps both <code>insert<\/code> and <code>update<\/code> would actually commit. So someone would rely on such callbacks to index data or write to the filesystem while the transaction could rollback afterwards. Those mistakes are always bound to happen with callbacks because the execution flow is hidden from developers.<\/p>\n<p>For all the reasons mentioned above, callbacks are deprecated in Ecto and will be removed by Ecto v2.0. Meanwhile <a href=\"https:\/\/github.com\/elixir-lang\/ecto\/issues\/1114\">we are working on solutions like <code>Ecto.Multi<\/code><\/a> that will give developers a data-driven approach to work with transactions.<\/p>\n<h2>Looking forward to 2.0<\/h2>\n<p>Besides the improvements already listed above, we are looking forward to many exciting new features on Ecto v2.0:<\/p>\n<ul>\n<li>Streamlined syntax for <code>select<\/code> and <code>group_by<\/code><\/li>\n<li>A more efficient way of working with transactions via <code>Ecto.Multi<\/code><\/li>\n<li>Many to many associations<\/li>\n<li>Automatic handling of associations and embeds on insert<\/li>\n<li>Automatic handling of both <code>belongs_to<\/code> and the upcoming <code>many_to_many<\/code> associations in insert and update<\/li>\n<li>An ownership system that allow tests that rely on the database to run concurrently by managing connection access<\/li>\n<\/ul>\n<p>Furthermore, James Fish is working on a project called <a href=\"http:\/\/github.com\/fishcakez\/db_connection\">db_connection<\/a> that will simplify adapter implementations and speed-up many operations by removing the amount of process communication and by providing client-side decoding. Early experiments showed performance improvements of ~25% when loading data. Such changes will also lead the way for running queries in parallel. For example, we will be able to preload associations in parallel instead of sequentially like today.<\/p>\n<p>The best news is that we expect Ecto v2.0 to be simpler and smaller in size than Ecto v1.1 thanks to the removal of callbacks and the support being brought by <code>db_connection<\/code>.<\/p>\n<p>We are really excited about future versions of Ecto and the improvements it will bring to everyday applications!<\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar\"><br \/>\n  <img decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\" style=\"border:0\"><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Ecto v1.1 has been released. Ecto v1.1 brings improvements and bug fixes to Ecto but, more importantly, paves the way for the upcoming Ecto v2.0 release by deprecating functionality that has been said to be error prone or confusing by developers. This article will highlight both improvements and what to expect by Ecto 2.0. For &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2015\/12\/ecto-v1-1-released-and-ecto-v2-0-plans\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[241,238,143,242],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4944"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=4944"}],"version-history":[{"count":5,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4944\/revisions"}],"predecessor-version":[{"id":4952,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4944\/revisions\/4952"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=4944"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=4944"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=4944"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}