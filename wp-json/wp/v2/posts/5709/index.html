{"id":5709,"date":"2016-09-29T09:15:48","date_gmt":"2016-09-29T12:15:48","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5709"},"modified":"2016-11-17T13:59:42","modified_gmt":"2016-11-17T15:59:42","slug":"dynamic-forms-with-phoenix","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/09\/dynamic-forms-with-phoenix\/","title":{"rendered":"Dynamic forms with Phoenix"},"content":{"rendered":"<p>Today we will learn how to build forms in Phoenix that use our schema information to dynamically show the proper input fields with validations, errors and so on. We aim to support the following API in our templates:<\/p>\n<pre><code class=\"eex\">&lt;%= input f, :name %&gt;\n&lt;%= input f, :address %&gt;\n&lt;%= input f, :date_of_birth %&gt;\n&lt;%= input f, :number_of_children %&gt;\n&lt;%= input f, :notifications_enabled %&gt;\n<\/code><\/pre>\n<p>Each generated input will have the proper markup and classes (we will use <a href=\"http:\/\/getbootstrap.com\/\">Bootstrap<\/a> in this example), include the proper HTML attributes, such as <code>required<\/code> for required fields and validations, and show any input error.<\/p>\n<p>The goal is to build this foundation in our own applications in very few lines of code, without 3rd party dependencies, allowing us to customize and extend it as desired as our application changes.<\/p>\n<h2>Setting up<\/h2>\n<p>Before building our <code>input<\/code> helper, let&#8217;s first generate a new resource which we will use as a template for experimentation (if you don&#8217;t have a Phoenix application handy, run <code>mix phoenix.new your_app<\/code> before the command below):<\/p>\n<pre><code>mix phoenix.gen.html User users name address date_of_birth:datetime number_of_children:integer notifications_enabled:boolean\n<\/code><\/pre>\n<p>Follow the instructions after the command above runs and then open the form template at &#8220;web\/templates\/user\/form.html.eex&#8221;. We should see a list of inputs such as:<\/p>\n<pre><code class=\"eex\">&lt;div class=\"form-group\"&gt;\n  &lt;%= label f, :address, class: \"control-label\" %&gt;\n  &lt;%= text_input f, :address, class: \"form-control\" %&gt;\n  &lt;%= error_tag f, :address %&gt;\n&lt;\/div&gt;\n<\/code><\/pre>\n<p>The goal is to replace each group above by a single <code>&lt;%= input f, field %&gt;<\/code> line.<\/p>\n<h3>Adding changeset validations<\/h3>\n<p>Still in the &#8220;form.html.eex&#8221; template, we can see that a Phoenix form operates on Ecto changesets:<\/p>\n<pre><code class=\"eex\">&lt;%= form_for @changeset, @action, fn f -&gt; %&gt;\n<\/code><\/pre>\n<p>Therefore, if we want to automatically show validations in our forms, the first step is to declare those validations in our changeset. Open up &#8220;web\/models\/user.ex&#8221; and let&#8217;s add a couple new validations at the end of the <code>changeset<\/code> function:<\/p>\n<pre><code class=\"elixir\">|&gt; validate_length(:address, min: 3)\n|&gt; validate_number(:number_of_children, greater_than_or_equal_to: 0)\n<\/code><\/pre>\n<p>Also, before we do any changes to our form, let&#8217;s start the server with <code>mix phoenix.server<\/code> and access <code>http:\/\/localhost:4000\/users\/new<\/code> to see the default form at work.<\/p>\n<h2>Writing the <code>input<\/code> function<\/h2>\n<p>Now that we have set up the codebase, we are ready to implement the <code>input<\/code> function.<\/p>\n<h3>The <code>YourApp.InputHelpers<\/code> module<\/h3>\n<p>Our <code>input<\/code> function will be defined in a module named <code>YourApp.InputHelpers<\/code> (where <code>YourApp<\/code> is the name of your application) which we will place in a new file at &#8220;web\/views\/input_helpers.ex&#8221;. Let&#8217;s define it:<\/p>\n<pre><code class=\"elixir\">defmodule YourApp.InputHelpers do\n  use Phoenix.HTML\n\n  def input(form, field) do\n    \"Not yet implemented\"\n  end\nend\n<\/code><\/pre>\n<p>Note we used <code>Phoenix.HTML<\/code> at the top of the module to import the functions from <a href=\"https:\/\/hexdocs.pm\/phoenix_html\">the <code>Phoenix.HTML<\/code> project<\/a>. We will rely on those functions to build the markup later on.<\/p>\n<p>If we want our <code>input<\/code> function to be automatically available in all views, we need to explicitly add it to the list of imports in the &#8220;def view&#8221; section of our &#8220;web\/web.ex&#8221; file:<\/p>\n<pre><code class=\"elixir\">import YourApp.Router.Helpers\nimport YourApp.ErrorHelpers\nimport YourApp.InputHelpers # Let's add this one\nimport YourApp.Gettext\n<\/code><\/pre>\n<p>With the module defined and properly imported, let&#8217;s change our &#8220;form.html.eex&#8221; function to use the new <code>input<\/code> functions. Instead of 5 &#8220;form-group&#8221; divs:<\/p>\n<pre><code class=\"eex\">&lt;div class=\"form-group\"&gt;\n  &lt;%= label f, :address, class: \"control-label\" %&gt;\n  &lt;%= text_input f, :address, class: \"form-control\" %&gt;\n  &lt;%= error_tag f, :address %&gt;\n&lt;\/div&gt;\n<\/code><\/pre>\n<p>We should have 5 input calls:<\/p>\n<pre><code class=\"eex\">&lt;%= input f, :name %&gt;\n&lt;%= input f, :address %&gt;\n&lt;%= input f, :date_of_birth %&gt;\n&lt;%= input f, :number_of_children %&gt;\n&lt;%= input f, :notifications_enabled %&gt;\n<\/code><\/pre>\n<p>Phoenix live-reload should automatically reload the page and we should see &#8220;Not yet implemented&#8221; appear 5 times.<\/p>\n<h3>Showing the input<\/h3>\n<p>The first functionality we will implement is to render the proper inputs as before. To do so, we will use <a href=\"https:\/\/hexdocs.pm\/phoenix_html\/Phoenix.HTML.Form.html#input_type\/3\">the <code>Phoenix.HTML.Form.input_type<\/code> function<\/a>, that receives a form and a field name and returns which input type we should use. For example, for <code>:name<\/code>, it will return <code>:text_input<\/code>. For <code>:date_of_birth<\/code>, it will yield <code>:datetime_select<\/code>. We can use the returned atom to dispatch to <code>Phoenix.HTML.Form<\/code> and build our input:<\/p>\n<pre><code class=\"elixir\">def input(form, field) do\n  type = Phoenix.HTML.Form.input_type(form, field)\n  apply(Phoenix.HTML.Form, type, [form, field])\nend\n<\/code><\/pre>\n<p>Save the file and watch the inputs appear on the page!<\/p>\n<h3>Wrappers, labels and errors<\/h3>\n<p>Now let&#8217;s take the next step and show the label and error messages, all wrapped in a div:<\/p>\n<pre><code class=\"elixir\">def input(form, field) do\n  type = Phoenix.HTML.Form.input_type(form, field)\n\n  content_tag :div do\n    label = label(form, field, humanize(field))\n    input = apply(Phoenix.HTML.Form, type, [form, field])\n    error = YourApp.ErrorHelpers.error_tag(form, field) || \"\"\n    [label, input, error]\n  end\nend\n<\/code><\/pre>\n<p>We used <code>content_tag<\/code> to build the wrapping <code>div<\/code> and the existing <code>YourApp.ErrorHelpers.error_tag<\/code> function that Phoenix generates for every new application that builds an error tag with proper markup.<\/p>\n<h3>Adding Bootstrap classes<\/h3>\n<p>Finally, let&#8217;s add some HTML classes to mirror the generated Bootstrap markup:<\/p>\n<pre><code class=\"elixir\">def input(form, field) do\n  type = Phoenix.HTML.Form.input_type(form, field)\n\n  wrapper_opts = [class: \"form-group\"]\n  label_opts = [class: \"control-label\"]\n  input_opts = [class: \"form-control\"]\n\n  content_tag :div, wrapper_opts do\n    label = label(form, field, humanize(field), label_opts)\n    input = apply(Phoenix.HTML.Form, type, [form, field, input_opts])\n    error = YourApp.ErrorHelpers.error_tag(form, field)\n    [label, input, error || \"\"]\n  end\nend\n<\/code><\/pre>\n<p>And that&#8217;s it! We are now generating the same markup that Phoenix originally generated. All in 14 lines of code. But we are not done yet, let&#8217;s take things to the next level by further customizing our input function.<\/p>\n<h2>Customizing inputs<\/h2>\n<p>Now that we have achieved parity with the markup code that Phoenix generates, we can further extend it and customize it according to our application needs.<\/p>\n<h3>Colorized wrapper<\/h3>\n<p>One useful UX improvement is to, if a form has errors, automatically wrap each field in a success or error state accordingly. Let&#8217;s rewrite the <code>wrapper_opts<\/code> to the following:<\/p>\n<pre><code class=\"elixir\">wrapper_opts = [class: \"form-group #{state_class(form, field)}\"]\n<\/code><\/pre>\n<p>And define the private <code>state_class<\/code> function as follows:<\/p>\n<pre><code class=\"elixir\">defp state_class(form, field) do\n  cond do\n    # The form was not yet submitted\n    !form.source.action -&gt; \"\"\n    form.errors[field] -&gt; \"has-error\"\n    true -&gt; \"has-success\"\n  end\nend\n<\/code><\/pre>\n<p>Now submit the form with errors and you should see every label and input wrapped in green (in case of success) or red (in case of input error).<\/p>\n<h3>Input validations<\/h3>\n<p>We can use <a href=\"https:\/\/hexdocs.pm\/phoenix_html\/Phoenix.HTML.Form.html#input_validations\">the <code>Phoenix.HTML.Form.input_validations<\/code> function<\/a> to retrieve the validations in our changesets as input attributes and then merge it into our <code>input_opts<\/code>. Add the following two lines after the <code>input_opts<\/code> variable is defined (and before the <code>content_tag<\/code> call):<\/p>\n<pre><code class=\"elixir\">validations = Phoenix.HTML.Form.input_validations(form, field)\ninput_opts = Keyword.merge(validations, input_opts)\n<\/code><\/pre>\n<p>After the changes above, if you attempt to submit the form without filling the &#8220;Address&#8221; field, which we imposed a length of 3 characters, the browser won&#8217;t allow the form to be submitted. Not everyone is a fan of browser validations and, in this case, you have direct control if you want to include them or not.<\/p>\n<p>At this point it is worth mentioning both <code>Phoenix.HTML.Form.input_type<\/code> and <code>Phoenix.HTML.Form.input_validations<\/code> are defined as part of the <code>Phoenix.HTML.FormData<\/code> protocol. This means if you decide to use something else besides Ecto changesets to cast and validate incoming data, all of the functionality we have built so far will still work. For those interested in learning more, I recommend checking out <a href=\"https:\/\/github.com\/phoenixframework\/phoenix_ecto\">the <code>Phoenix.Ecto<\/code> project<\/a> and learn how the integration between Ecto and Phoenix is done by simply implementing protocols exposed by Phoenix.<\/p>\n<h3>Per input options<\/h3>\n<p>The last change we will add to our <code>input<\/code> function is the ability to pass options per input. For example, for a given input, we may not want to use the type inflected by <code>input_type<\/code>. We can add options to handle those cases:<\/p>\n<pre><code class=\"elixir\">def input(form, field, opts \\\\ []) do\n  type = opts[:using] || Phoenix.HTML.Form.input_type(form, field)\n<\/code><\/pre>\n<p>This means we can now control which function to use from <code>Phoenix.HTML.Form<\/code> to build our input:<\/p>\n<pre><code class=\"eex\">&lt;%= input f, :new_password, using: :password_input %&gt;\n<\/code><\/pre>\n<p>We also don&#8217;t need to be restricted to the inputs supported by <code>Phoenix.HTML.Form<\/code>. For example, if you want to replace the <code>:datetime_select<\/code> input that ships with Phoenix by a custom datepicker, you can wrap the input creation into an function and pattern match on the inputs you want to customize.<\/p>\n<p>Let&#8217;s see how our <code>input<\/code> functions look like with all the features so far, including support for custom inputs (input validations have been left out):<\/p>\n<pre><code class=\"elixir\">defmodule YourApp.InputHelpers do\n  use Phoenix.HTML\n\n  def input(form, field, opts \\\\ []) do\n    type = opts[:using] || Phoenix.HTML.Form.input_type(form, field)\n\n    wrapper_opts = [class: \"form-group #{state_class(form, field)}\"]\n    label_opts = [class: \"control-label\"]\n    input_opts = [class: \"form-control\"]\n\n    content_tag :div, wrapper_opts do\n      label = label(form, field, humanize(field), label_opts)\n      input = input(type, form, field, input_opts)\n      error = YourApp.ErrorHelpers.error_tag(form, field)\n      [label, input, error || \"\"]\n    end\n  end\n\n  defp state_class(form, field) do\n    cond do\n      # The form was not yet submitted\n      !form.source.action -&gt; \"\"\n      form.errors[field] -&gt; \"has-error\"\n      true -&gt; \"has-success\"\n    end\n  end\n\n  # Implement clauses below for custom inputs.\n  # defp input(:datepicker, form, field, input_opts) do\n  #   raise \"not yet implemented\"\n  # end\n\n  defp input(type, form, field, input_opts) do\n    apply(Phoenix.HTML.Form, type, [form, field, input_opts])\n  end\nend\n<\/code><\/pre>\n<p>And then, once you implement your own <code>:datepicker<\/code>, just add to your template:<\/p>\n<pre><code class=\"eex\">&lt;%= input f, :date_of_birth, using: :datepicker %&gt;\n<\/code><\/pre>\n<p>Since your application owns the code, you will always have control over the inputs types and how they are customized. Luckily Phoenix ships with enough functionality to give us a head start, without compromising our ability to refine our presentation layer later on.<\/p>\n<h2>Summing up<\/h2>\n<p>This article showed how we can leverage the conveniences exposed in <code>Phoenix.HTML<\/code> to dynamically build forms using the information we have already specified in our schemas. Although the example above used the User schema, which directly maps to a database table, <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/05\/ectos-insert_all-and-schemaless-queries\/\">Ecto 2.0 allows us to use schemas to map to any data source<\/a>, so the <code>input<\/code> function can be used for validating search forms, login pages, and so on without changes.<\/p>\n<p>While we have developed <a href=\"http:\/\/github.com\/plataformatec\/simple_form\">projects such as Simple Form<\/a> to tackle those problems in our Rails projects, with Phoenix we can get really far using the minimal abstractions that ship as part of the framework, allowing us to get most of the functionality while having full control over the generated markup.<\/p>\n<div style=\"margin:20px 0 60px;\">\n<a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=lauching-elixir-radar-channel&amp;utm_content=cta-blog-post-bottom\"><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/09\/blog-cta-elixir-radar-channel.jpg\" alt=\"Elixir Radar\" width=\"831\" height=\"147\" class=\"aligncenter size-full wp-image-5701\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/09\/blog-cta-elixir-radar-channel.jpg 831w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/09\/blog-cta-elixir-radar-channel-300x53.jpg 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/09\/blog-cta-elixir-radar-channel-768x136.jpg 768w\" sizes=\"(max-width: 831px) 100vw, 831px\" \/><\/a>\n<\/div>\n","protected":false},"excerpt":{"rendered":"<p>Today we will learn how to build forms in Phoenix that use our schema information to dynamically show the proper input fields with validations, errors and so on. We aim to support the following API in our templates: &lt;%= input f, :name %&gt; &lt;%= input f, :address %&gt; &lt;%= input f, :date_of_birth %&gt; &lt;%= input &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/09\/dynamic-forms-with-phoenix\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[143,245],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5709"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5709"}],"version-history":[{"count":8,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5709\/revisions"}],"predecessor-version":[{"id":5888,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5709\/revisions\/5888"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5709"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5709"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5709"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}