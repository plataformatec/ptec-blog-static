{"id":1181,"date":"2010-07-05T12:19:46","date_gmt":"2010-07-05T15:19:46","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=1181"},"modified":"2011-02-21T09:35:01","modified_gmt":"2011-02-21T12:35:01","slug":"new-active-record-scoping-syntax","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2010\/07\/new-active-record-scoping-syntax\/","title":{"rendered":"New Active Record scoping syntax"},"content":{"rendered":"<p>You probably know that <a href=\"http:\/\/www.railsdispatch.com\/posts\/activerelation\" target=\"_blank\">Active Record got a facelift<\/a> and is now powered by Active Relation. A new chainable-award-winning-lazy API was added and received great feedback! However, as more and more people are trying Rails 3 beta, <a href=\"https:\/\/rails.lighthouseapp.com\/projects\/8994\/tickets\/3838\" target=\"_blank\">a small incompatibility between the old and new syntax was found<\/a>. This post explains this incompatibility and how it was solved.<\/p>\n<h3>The issue<\/h3>\n<p>Quoting the Lighthouse ticket, imagine the following scenario in Rails 2.3:<\/p>\n<pre lang=\"ruby\">\r\nclass Page < ActiveRecord::Base\r\n  default_scope :conditions => { :deleted_at => nil }\r\n\r\n  def self.deleted\r\n    with_exclusive_scope :find => { :conditions => \"pages.deleted_at IS NOT NULL\" } do\r\n      all\r\n    end\r\n  end\r\nend\r\n<\/pre>\n<p>If you rewrite it to the new 3.0 syntax, your first attempt would probably be:<\/p>\n<pre lang=\"ruby\">\r\nclass Page < ActiveRecord::Base\r\n  default_scope where(:deleted_at => nil)\r\n\r\n  def self.deleted\r\n    with_exclusive_scope :find => where('pages.deleted_at IS NOT NULL') do\r\n      all\r\n    end\r\n  end\r\nend\r\n<\/pre>\n<p>However, if you try it out on console, you will find out it does not work as expected:<\/p>\n<pre lang=\"ruby\">\r\nPage.all         #=> SELECT \"pages\".* FROM \"pages\" WHERE (\"pages\".\"deleted_at\" IS NULL)\r\nPage.deleted.all #=> SELECT \"pages\".* FROM \"pages\" WHERE (\"pages\".\"deleted_at\" IS NULL) AND (\"pages\".\"deleted_at\" IS NOT NULL)\r\n<\/pre>\n<p>To understand why it does not work, let&#8217;s take a look at the source code!<\/p>\n<h3>Investigating the issue<\/h3>\n<p>With Active Relation, Active Record is no longer responsible to build queries. That said, <code>ActiveRecord::Base<\/code> is not the one that implements <code>where()<\/code> and friends, in fact, it simply delegates to an <code>ActiveRecord::Relation<\/code> object. From <a href=\"http:\/\/github.com\/rails\/rails\/blob\/master\/activerecord\/lib\/active_record\/base.rb\" target=\"_blank\">ActiveRecord::Base source code<\/a>:<\/p>\n<pre lang=\"ruby\">\r\ndelegate :select, :group, :order, :limit, :joins, :where, :preload, :eager_load, :includes, :from, :lock, :readonly, :having, :create_with, :to => :scoped\r\n<\/pre>\n<p>And the <code>scoped<\/code> implementation is shown below:<\/p>\n<pre lang=\"ruby\">\r\ndef scoped(options = nil)\r\n  if options.present?\r\n    scoped.apply_finder_options(options)\r\n  else\r\n    current_scoped_methods ? relation.merge(current_scoped_methods) : relation.clone\r\n  end\r\nend\r\n\r\ndef relation\r\n  @relation ||= ActiveRecord::Relation.new(self, arel_table)\r\n  finder_needs_type_condition? ? @relation.where(type_condition) : @relation\r\nend\r\n<\/pre>\n<p>As you can see, <code>scoped<\/code> always returns an ActiveRecord::Relation that you build your query on top of (notice that <a href=\"http:\/\/metautonomo.us\/2010\/05\/11\/activerecord-relation-vs-arel\/\">ARel::Relation is not the same as ActiveRecord::Relation<\/a>).<\/p>\n<p>Besides, if there is any <code>current_scoped_methods<\/code>, the <code>scoped<\/code> method is responsible to merge this current scope into the raw relation. This is where things get interesting.<\/p>\n<p>When you create your model, <code>current_scoped_methods<\/code> returns by default nil. However, when you define a <code>default_scope<\/code>, the current scope now becomes the relation given to <code>default_scope<\/code>, meaning that, every time you call <code>scoped<\/code>, it returns the raw relation merged with your default scope.<\/p>\n<p>The whole idea of <code>with_exclusive_scope<\/code> is to be able to make a query without taking the default scope into account, just the relation you give in as argument. That said, it basically sets the <code>current_scope_methods<\/code> back to nil, so every time you call <code>scoped<\/code> to build your queries, it will be built on top of the raw relation without the default scope.<\/p>\n<p>With that in mind, if we look again at the code which we were trying to port from Rails 2.3, we can finally understand what was happening:<\/p>\n<pre lang=\"ruby\">\r\ndef self.deleted\r\n  with_exclusive_scope :find => where('pages.deleted_at IS NOT NULL') do\r\n    self\r\n  end\r\nend\r\n<\/pre>\n<p>When we called <code>where('pages.deleted_at IS NOT NULL')<\/code> above, we were doing the same as: <code>scoped.where('pages.deleted_at IS NOT NULL')<\/code>. But, as <code>scoped<\/code> was called <strong>outside<\/strong> the <code>with_exclusive_scope<\/code> block, it means that the relation given as argument to <code>:find<\/code> was built on top of <code>default_scope<\/code> explaining the query we saw as results.<\/p>\n<p>For example, the following syntax would work as expected:<\/p>\n<pre lang=\"ruby\">\r\ndef self.deleted\r\n  with_exclusive_scope do\r\n    where('pages.deleted_at IS NOT NULL').all\r\n  end\r\nend\r\n<\/pre>\n<p>Since we are calling <code>where<\/code> inside the block, the <code>scoped<\/code> method no longer takes the default scope into account. However, moving the relation inside the block is not the same as specifying it to <code>:find<\/code>, because if we were doing three queries inside the block, we would have to specify the same relation three times (or refactor the whole code to always do a query on top of this new relation).<\/p>\n<p>That said, it seems the previous <code>with_exclusive_scope<\/code> syntax does not suit very well with ActiveRecord&#8217;s new API. Maybe is it time for change? Can we provide a better API? Which are the use cases?<\/p>\n<h3>Identifying the use cases<\/h3>\n<p>The <code>with_exclusive_scope<\/code> method has mainly two use cases. The first one, which we just discussed above, is to allow us to make a query without taking the default scope into account inside our models:<\/p>\n<pre lang=\"ruby\">\r\ndef self.deleted\r\n  with_exclusive_scope do\r\n    where('pages.deleted_at IS NOT NULL').all\r\n  end\r\nend\r\n<\/pre>\n<p>While this code looks ok, if we think about relations, we will realize that we don&#8217;t need to give a block to achieve the behavior we want. If the <code>scoped<\/code> method returns a raw relation with the default scope, couldn&#8217;t we have a method that always returns the raw relation? Allowing us to build our query without taking the default scope into account?<\/p>\n<p>In fact, this method was already implemented in Active Record and it is called <code>unscoped<\/code>. That said, the code above could simply be rewritten as:<\/p>\n<pre lang=\"ruby\">\r\ndef self.deleted\r\n  unscoped.where('pages.deleted_at IS NOT NULL').all\r\nend\r\n<\/pre>\n<p>Much simpler! So, it seems that we don&#8217;t need to support the block usage at all, confirm?<\/p>\n<p>Deny! Going back to the <code>Page<\/code> example above, it seems we should never see deleted pages, that&#8217;s why we set the <code>default_scope<\/code> to <code>:deleted_at => nil<\/code>. However, if this application has an admin section, the admin may want to see all pages, including the deleted ones.<\/p>\n<p>That said, what we could do is to have one controller for the normal User and another for the Admin. In the former, we would always use <code>Page.all<\/code>, and <code>Page.unscoped.all<\/code> in the latter.<\/p>\n<p>However, if these controllers and views are very similar, you may not want do duplicate everything. Maybe it would be easier if we do something like this:<\/p>\n<pre lang=\"ruby\">def resource_class\r\n  if current_user.is_admin?\r\n    Page.unscoped\r\n  else\r\n    Page\r\n  end\r\nend<\/pre>\n<p>And, instead of always referencing the <code>Page<\/code> class directly in our actions, we could call <code>resource_class<\/code>. While this solution is also ok, there is a final alternative, that would require no changes to the current code. If you want to use the same controller for different roles, but changing the scope of what they are allowed to see, you could simply use an <code>around_filter<\/code> to change the model scope during the execution of an action. Here is an example:<\/p>\n<pre lang=\"ruby\">\r\nclass PagesController < ApplicationController\r\n  around_filter :apply_scope\r\n\r\n  # some code ...\r\n\r\n  protected\r\n\r\n  def apply_scope\r\n    if current_user.admin?\r\n      Page.with_exclusive_scope { yield }\r\n    else\r\n      yield\r\n    end\r\n  end\r\nend<\/pre>\n<p>That said, being allowed to give a block to <code>with_exclusive_scope<\/code> is actually useful and since we want to deprecate <code>with_exclusive_scope<\/code> in favor of <code>unscoped<\/code> in the future, we brought this very same syntax to <code>unscoped<\/code> as well:<\/p>\n<pre lang=\"ruby\">def apply_scope\r\n  if current_user.admin?\r\n    Page.unscoped { yield }\r\n  else\r\n    yield\r\n  end\r\nend<\/pre>\n<h3>Tidying it up<\/h3>\n<p>Well, after the behavior in <code>with_exclusive_scope<\/code> was properly ported to the new API, we need to be sure we are not forgetting about anything... wait, actually we are.<\/p>\n<p><code>with_exclusive_scope<\/code> has an evil twin brother called <code>with_scope<\/code> which behaves very similarly, except that it always build the query on top of the <code>scoped<\/code> relation. It works like this:<\/p>\n<pre lang=\"ruby\">\r\nclass Page < ActiveRecord::Base\r\n  default_scope where(:deleted_at => nil)\r\nend\r\n\r\nPage.with_scope :find => { :conditions => { :active => true } } do\r\n  Page.all #=> Bring all active pages that were not deleted\r\nend\r\n<\/pre>\n<p>However, this feels way too hash-ish. Of course, we could use relations to make it a bit prettier:<\/p>\n<pre lang=\"ruby\">\r\nPage.with_scope :find => where(:active => true) do\r\n  Page.all #=> Bring all active pages that were not deleted\r\nend\r\n<\/pre>\n<p>This is ok, but it seems that we could improve it even more. That said, we added a new method to relations, called <code>scoping<\/code>:<\/p>\n<pre lang=\"ruby\">\r\nPage.where(:active => true).scoping do\r\n  Page.all #=> Bring all active pages that were not deleted\r\nend\r\n<\/pre>\n<p>Yeah! Sign me up 'cause this looks way better than the previous syntax! And, if you check <a href=\"http:\/\/github.com\/rails\/rails\/commit\/bd1666ad1de88598ed6f04ceffb8488a77be4385\">the original commit<\/a>, you will notice the <code>unscoped<\/code> method with a block simply delegates <code>scoping<\/code>:<\/p>\n<pre lang=\"ruby\">\r\ndef unscoped\r\n  block_given? ? relation.scoping { yield } : relation\r\nend\r\n<\/pre>\n<p>So, with <code>unscoped<\/code> and <code>scoping<\/code> implemented, we just need to commit, git push and be happy, confirm? Deny! There is one last case to check.<\/p>\n<h3>create_with<\/h3>\n<p>If you payed attention properly, you can notice that every time we called <code>with_exclusive_scope<\/code> and <code>with_scope<\/code>, we always passed <code>{ :find => relation }<\/code> as hash, instead of simply giving the relation. This happens because these methods accept two hash keys: find and create.<\/p>\n<p>As you may expect, one specifies the behavior for create and the other for finding. In most of the cases, they are exactly the same and work with the new syntax:<\/p>\n<pre lang=\"ruby\">\r\npage = Page.where(:active => true).new\r\npage.active #=> true\r\n<\/pre>\n<p>However, for obvious reasons, this only works if the conditions are given as a hash. Consider this case:<\/p>\n<pre lang=\"ruby\">\r\npage = Page.where(\"active = true\").new\r\npage.active #=> nil\r\n<\/pre>\n<p>That said, there may be a few scenarios where you want to specify the creation conditions on its own, explaining the :find and :create options in <code>with_exclusive_scope<\/code> and <code>with_scope<\/code> methods. So, how can I achieve it with the new syntax? Easy!<\/p>\n<pre lang=\"ruby\">\r\npage = Page.create_with(:active => true).new\r\npage.active #=> true\r\n<\/pre>\n<p>If you provide both conditions as a hash and <code>create_with<\/code>, <code>create_with<\/code> always have higher priority:<\/p>\n<pre lang=\"ruby\">\r\npage = Page.where(:active => false).create_with(:active => true).new\r\npage.active #=> true\r\n<\/pre>\n<p>Note this syntax already existed, we are just making it explicit now as part of the new API! That said, commit, push and be happy!<\/p>\n<h3>Wrapping up<\/h3>\n<p>All in all, <code>with_exclusive_scope<\/code> and <code>with_scope<\/code> are now part of the old ActiveRecord API giving place to the new, strong and vibrant <code>unscoped<\/code> and <code>scoping<\/code> methods!<\/p>\n<p>However, they are not going to be deprecated now. They will follow the same <a href=\"http:\/\/m.onkey.org\/2010\/1\/22\/active-record-query-interface\" target=\"_blank\">deprecation strategy as all the current methods<\/a>.<\/p>\n<p>And you? What do you think about this new scoping API?<\/p>\n","protected":false},"excerpt":{"rendered":"<p>You probably know that Active Record got a facelift and is now powered by Active Relation. A new chainable-award-winning-lazy API was added and received great feedback! However, as more and more people are trying Rails 3 beta, a small incompatibility between the old and new syntax was found. This post explains this incompatibility and how &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2010\/07\/new-active-record-scoping-syntax\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[106,107,115,108],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1181"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=1181"}],"version-history":[{"count":17,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1181\/revisions"}],"predecessor-version":[{"id":1884,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/1181\/revisions\/1884"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=1181"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=1181"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=1181"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}