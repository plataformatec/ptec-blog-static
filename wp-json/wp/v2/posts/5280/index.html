{"id":5280,"date":"2016-04-07T14:33:20","date_gmt":"2016-04-07T17:33:20","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5280"},"modified":"2016-04-08T08:18:42","modified_gmt":"2016-04-08T11:18:42","slug":"debugging-techniques-in-elixir-lang","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2016\/04\/debugging-techniques-in-elixir-lang\/","title":{"rendered":"Debugging techniques in Elixir"},"content":{"rendered":"<p>It&#8217;s common that our first experience with debugging in a new language is by printing values to the terminal. Elixir isn&#8217;t different: we can use <code>IO.puts\/2<\/code> and <code>IO.inspect\/2<\/code>. However, Elixir also provides other approaches to debugging.<\/p>\n<p>In this blog post, we&#8217;ll show you other 2 options: <code>IEx.pry\/0<\/code> and <code>:debugger<\/code>.<\/p>\n<h2>IEx.pry<\/h2>\n<p>The name &#8220;pry&#8221; is an old friend in the Ruby ecosystem but it has a different behavior in Elixir. Let&#8217;s create a new project with <code>mix<\/code> to try it out:<\/p>\n<pre><code class=\"shell\">$ mix new example\n$ cd example\n<\/code><\/pre>\n<p>Now let&#8217;s write some sample code in <code>lib\/example.ex<\/code>:<\/p>\n<pre><code class=\"elixir\">require IEx;\n\ndefmodule Example do\n  def double_sum(x, y) do\n    IEx.pry\n    hard_work(x, y)\n  end\n\n  defp hard_work(x, y) do\n    2 * (x + y)\n  end\nend\n<\/code><\/pre>\n<p>Now start a new IEx session and invoke our new function:<\/p>\n<pre><code class=\"iex\">$ iex -S mix\nInteractive Elixir (1.2.4) - press Ctrl+C to exit (type h() ENTER for help)\niex(1)&gt; Example.double_sum(1, 2)\n<\/code><\/pre>\n<p><code>IEx.pry\/0<\/code> is built on top of IEx. Although it isn&#8217;t a traditional debugger since you can&#8217;t step, add breakpoints and so forth, it&#8217;s a good tool for non-production debugging. It runs in the caller process, blocking the caller and allowing us to access its binding (variables), verify its lexical information and access the process information. You can finish your &#8220;pry&#8221; session by calling <code>respawn<\/code>, which starts a new IEx shell.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/iex-pry-elixir.gif\" alt=\"Starting a new IEx session\" width=\"930\" height=\"506\" class=\"aligncenter size-full wp-image-5285\" \/><\/p>\n<p>You can find more information at <a href=\"http:\/\/elixir-lang.org\/docs\/stable\/iex\/IEx.html#pry\/1\">IEx.pry doc<\/a>.<\/p>\n<h2>Debugger<\/h2>\n<p>If you need a breakpoint feature, we can use the <code>:debugger<\/code> module that ships with Erlang. Let&#8217;s make a change in our example to be more didactic:<\/p>\n<pre><code class=\"elixir\">defmodule Example do\n  def double_sum(x, y) do\n    hard_work(x, y)\n  end\n\n  defp hard_work(x, y) do\n    x = 2 * x\n    y = 2 * y\n\n    x + y\n  end\nend\n<\/code><\/pre>\n<p>Now we can start our debugger:<\/p>\n<pre><code class=\"iex\">$ iex -S mix\nErlang\/OTP 18 [erts-7.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]\n\nCompiled lib\/example.ex\nInteractive Elixir (1.2.4) - press Ctrl+C to exit (type h() ENTER for help)\niex(1)&gt; :debugger.start()\n{:ok, #PID&lt;0.87.0&gt;}\niex(2)&gt; :int.ni(Example)\n{:module, Example}\niex(3)&gt; :int.break(Example, 3)\n:ok\niex(4)&gt; Example.double_sum(1,2)\n<\/code><\/pre>\n<p>When you started the debugger, a Graphical User Interface must have opened in your machine. We called <code>:int.ni(Example)<\/code> to prepare our module for debugging and then added a breakpoint to line 3 with <code>:int.break(Example, 3)<\/code>. After we call our function, we can see our process with break status in the debugger:<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/04\/debugger-elixir.gif\" alt=\"Process with break status in the de\" width=\"990\" height=\"752\" class=\"aligncenter size-full wp-image-5286\" \/><\/p>\n<p>The process is blocked as in <code>IEx.pry\/0<\/code>. We can add a new breakpoint in the monitor window, inspect the code, see the variables and navigate it in steps.<\/p>\n<p>Debugger has more options and command instructions that you can use. Take a look at <a href=\"http:\/\/erlang.org\/doc\/apps\/debugger\/debugger_chapter.html\">Debbuger doc<\/a> for more information.<\/p>\n<h3>Troubleshooting<\/h3>\n<p>You may have some problems when executing <code>:int.ni(Example)<\/code> in the example above:<\/p>\n<pre><code class=\"elixir\">iex(2)&gt; :int.ni(Example)\n** Invalid beam file or no abstract code: 'Elixir.Example'\n<\/code><\/pre>\n<p>Before the upcoming Erlang 19 version, the debugger did not have the <a href=\"https:\/\/github.com\/erlang\/otp\/pull\/977\">heuristic that traverses the module source attribute<\/a> applied. If you are not on the latest Erlang version, you can update the debugger manually with the following steps:<\/p>\n<ol>\n<li>Download the file <code>int.erl<\/code> from the PR.<\/li>\n<li>Compile it with <code>erlc -o . int.erl<\/code>.<\/li>\n<li>Overwrite <code>lib\/debugger\/ebin\/int.beam<\/code> in your Erlang installation with the new compiled file.<\/li>\n<\/ol>\n<p>In the next post, we will see a tracing technique that doesn&#8217;t block the caller process.<\/p>\n<p>What about you? What are the tools that you are using to debug your Elixir applications?<\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=elixir-radar&amp;utm_content=elixir-radar-cta-blog-post-bottom\"><br \/>\n<img decoding=\"async\" style=\"border: 0;\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\" \/><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>It&#8217;s common that our first experience with debugging in a new language is by printing values to the terminal. Elixir isn&#8217;t different: we can use IO.puts\/2 and IO.inspect\/2. However, Elixir also provides other approaches to debugging. In this blog post, we&#8217;ll show you other 2 options: IEx.pry\/0 and :debugger. IEx.pry The name &#8220;pry&#8221; is an &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2016\/04\/debugging-techniques-in-elixir-lang\/\">\u00bb<\/a><\/p>\n","protected":false},"author":18,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[247,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5280"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/18"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5280"}],"version-history":[{"count":13,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5280\/revisions"}],"predecessor-version":[{"id":5296,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5280\/revisions\/5296"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5280"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5280"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5280"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}