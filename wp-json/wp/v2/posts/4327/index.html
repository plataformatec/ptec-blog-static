{"id":4327,"date":"2014-12-02T09:00:34","date_gmt":"2014-12-02T11:00:34","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=4327"},"modified":"2015-06-01T12:25:25","modified_gmt":"2015-06-01T15:25:25","slug":"the-pros-and-cons-of-4-deployment-process-techniques","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2014\/12\/the-pros-and-cons-of-4-deployment-process-techniques\/","title":{"rendered":"The pros and cons of 4 deployment process techniques"},"content":{"rendered":"<p>The way of deliver your product code to your customer is commonly called &#8220;deployment&#8221;. It is an important matter because it will impact in how fast your product will respond to changes and the quality of each change.<\/p>\n<p>Depending on which deployment decision you take, it will impact your team and how you use your version control system.<\/p>\n<p>As a consultancy, we have worked in lots of projects, and together with our customers we have devised many ways to deliver their product to their customers. We have seen some patterns, advantages and challenges on each way, and today I would like to discuss some of them:<\/p>\n<ol>\n<li><a href=\"#open-source\">The open-source way<\/a><\/li>\n<li><a href=\"#pipeline\">The pipeline way<\/a><\/li>\n<li><a href=\"#support-branch\">The support branch way<\/a><\/li>\n<li><a href=\"#feature-toggle\">The feature toggle way<\/a><\/li>\n<\/ol>\n<h2 id=\"open-source\">The open-source way<\/h2>\n<p>In the open-source world most of the times we should maintain many versions of a same product. For example, Ruby on Rails has many versions released, like 2, 3.2, 4.0, 4.1. Bugs happens, new features are created, so news releases must be delivered, but in a set of supported released versions. Still on RoR example, the supported releases are 4.1, 4.0 and 3.2 (<a href=\"http:\/\/guides.rubyonrails.org\/maintenance_policy.html\">http:\/\/guides.rubyonrails.org\/maintenance_policy.html<\/a>). But how this releasing works?<\/p>\n<p>The most recent version of the product is maintained on the master branch, the previous major releases have their own branches. On RoR we have the master for the new 4.2 version release, and we still have 4-1-stable, 4-0-stable, 3-2-stable branches. By following this  organization we can easily apply changes on the desired versions.<\/p>\n<p>For each release a tag must be created. For example, there&#8217;s a tag for RoR 4.0.0, one for 4.1.0 and so on. With tags it is possible to navigate between the released versions and if the worst happens, like losing the &#8220;version-stable&#8221; branch, it&#8217;s easy to create another one from the last released version.<\/p>\n<p>Usually, a web product has just one version to be maintained, so usually we don&#8217;t need the &#8220;version-stable&#8221; branches. We can keep the new product releases on the master branch and generate a tag when we want to package and release a new product version.<\/p>\n<p>When we need a &#8220;hotfix&#8221; or an urgent feature and the master is not ready yet for production, we can easily create a branch from the latest tagged version, apply the desired changes, create a new tag and release a new version. By the way, using this way you can release any branch you want. All that manipulation of applying commits, merging and creating branches and tags, can be simplified with a powerful version control system like &#8220;Git&#8221;.<\/p>\n<h3>Strong points<\/h3>\n<ul>\n<li>The flexible package creation and release.<\/li>\n<li>It works for large teams, primarily when there are planned releases.<\/li>\n<\/ul>\n<h3>The challenges<\/h3>\n<ul>\n<li>It requires the infra to be flexible enough to support it.<\/li>\n<li>It requires time to control what can be merged on master before the package creation.<\/li>\n<li>It will require good ability with the version control system.<\/li>\n<li>Manage the release versions.<\/li>\n<\/ul>\n<h3>Common phrases with this approach<\/h3>\n<ul>\n<li>&#8220;Sorry pals, I forgot to apply that hot fix patch on master&#8221;. &#8211; A developer after releasing a new product version.<\/li>\n<\/ul>\n<h2 id=\"pipeline\">The pipeline way<\/h2>\n<p>Using a pipeline in your deployment process means you have well defined steps and all steps must be accomplished in order to do a deployment.<\/p>\n<p>Usually the steps are: run the automated tests, release on test\/qa environment, create the release tag, release on production. After the steps are defined, you need some software that allows the team to automate some steps and to add the option of requiring a approval for the next step. For example, you only want to release the package to production when your QA team and PO have approved the version on QA.<\/p>\n<p>Having a pipeline means your master branch is always production ready. Any new code inserted on master branch must pass the pipeline, then it is very important that the team and the pipeline to be able to quickly respond to changes.<\/p>\n<p>One important precaution is to be sure that only wanted features are on master, because all code on master will always be deployed on the next software release. I have seen some confusion in this aspect, because some companies are a bit more bureaucratic and have some strict deployment rules.<\/p>\n<p>Per example, a feature can only go to production when the QA team and PO approves. Placing the QA process on pipeline means you&#8217;ll put the feature on master that is not ready yet for production. It generates a problem I see regularly with this approach, I&#8217;ll call it for now the &#8220;release lock&#8221;.<\/p>\n<h3>Release lock<\/h3>\n<p>The release lock can be better understood with an example:<\/p>\n<ol>\n<li>The developers have released on master the Feature A and B.<\/li>\n<li>The QA team finds a BUG on Feature A.<\/li>\n<li>The developers release a Feature C on master<\/li>\n<li>The developers fix the BUG.<\/li>\n<li>PO approves Feature A and B and wants a deploy.<\/li>\n<\/ol>\n<p>Can we deploy a release with Feature C untested and unapproved by PO? Most of the time the companies answer is no.<\/p>\n<p>Some approaches we can do here are: revert Feature C commits, or simply lock code changes on master and the entire team focus on finishing the release with Feature C.<\/p>\n<p>Of course there are other approaches we can incorporate in the pipeline process, and we&#8217;ll see a further discussion about it later in this post.<\/p>\n<h3>Strong points<\/h3>\n<ul>\n<li>With the pipeline it is easier for everyone in the team to understand how the deployment works.<\/li>\n<li>The pipeline gives accessibility for anyone in the team to launch a release.<\/li>\n<li>Less time managing versioning.<\/li>\n<\/ul>\n<h3>The challenges<\/h3>\n<ul>\n<li>You lose the flexibility to deploy any branches.<\/li>\n<li>In large teams and some companies rules can produce release locks often.<\/li>\n<\/ul>\n<h3>Common phrases with this approach<\/h3>\n<ul>\n<li>&#8220;What? This feature is already in production?&#8221; &#8211; A member from QA team looking at the version in production.<\/li>\n<li>&#8220;Hey, stop merging on master! We need a release today!&#8221; &#8211; The product manager after receiving pressure from stakeholders.<\/li>\n<\/ul>\n<h2 id=\"support-branch\">The support branch way<\/h2>\n<p>You define a branch as QA or test branch. This branch is useful to test features which aren&#8217;t ready for production. For example, if your deployment process needs QA\/PO features approval.<\/p>\n<p>With this approach you&#8217;ll send the features to support branch. When the feature is approved you send them to the master branch and use the normal deployment process flow. It is important to do a regression test of the merged features on master. When a regression test finds a defect, it is easy to apply them on master, since the master is clear of unwanted features.<\/p>\n<p>While using this approach you should be aware that now you have two points of integration. Resolving the merging conflicts twice is a problem that can happen often, but the most troublesome issue is when the integration on the support branch breaks the application functionality.<\/p>\n<p>When the support branch integration is broken you need to analyze when and where the patch with the fix will be applied.<\/p>\n<p>If you apply the fix on support branch, you must remember to apply it on master again.<\/p>\n<p>The other option is to find out which changes made the features incompatible together. When you find that, you can apply those changes to the branch that doesn&#8217;t have those changes. Be aware that depending on the way you do this, you may end up needing to release both features together.<\/p>\n<h3>Strong points<\/h3>\n<ul>\n<li>You can easily apply the support branch in any deployment process you choose.<\/li>\n<li>You mitigate the release lock problem.<\/li>\n<\/ul>\n<h3>The challenges<\/h3>\n<ul>\n<li>Two points of features integration.<\/li>\n<li>Requires good abilities with version control system.<\/li>\n<li>The support branch maintenance.<\/li>\n<\/ul>\n<h3>Common phrases with this approach<\/h3>\n<ul>\n<li>&#8220;Gosh! I need to fix that merge conflict again.&#8221; &#8211; Developer merging on master the QA approved feature.<\/li>\n<\/ul>\n<h2 id=\"feature-toggle\">The feature toggle way<\/h2>\n<p>Sometimes you are using the feature toggle without knowing you are doing it. For example: when you enable some features only for beta users, or enable some application routes only for some network IPs, or create A\/B tests for the users. In general, you are using a feature toggle when your application is restricting in some way the access for some features.<\/p>\n<p>To solve the release lock problem, some teams apply the feature toggle in every feature that needs approval. In this way the team can send unapproved features to production. When the feature is approved, the feature can be turned on without a new deploy. Be aware that sending turned off features to production also means that unapproved feature code will be sended too.<\/p>\n<p>Creating toggles for your features means more code and tests to control what your software does with and without the toggles. Each feature toggle you add increases the complexity and the maintenance cost of your codebase.<\/p>\n<p>Thus, it is important to remove them after the feature approval before it starts damaging your software. I know what you&#8217;re thinking, yes, it is true, most of the times the QA\/PO team want to test the toggle removal and you might face the release lock problem again.<\/p>\n<h3>Strong points<\/h3>\n<ul>\n<li>You can use the pipeline with only one point of integration.<\/li>\n<li>You reduce the release lock problem.<\/li>\n<\/ul>\n<h3>The Challenges<\/h3>\n<ul>\n<li>You may increase the cost of development because of maintenance and removal of feature toggles.<\/li>\n<li>The feature toggle management.<\/li>\n<\/ul>\n<h3>Common phrases with this approach<\/h3>\n<ul>\n<li>&#8220;What this method does?&#8221; &#8211; A developer asking for his pal.<\/li>\n<li>&#8220;It depends, which toggles are on?&#8221; &#8211; The answer of the first question.<\/li>\n<\/ul>\n<h2>Conclusion<\/h2>\n<p>Most of the challenges of each deployment process requires team engagement and organization. It&#8217;s hard to decide which one is better, because it fully depends on how your team adapt to the process.<\/p>\n<p>Each person perceive problems in different ways. What is a huge matter for someone, for the other is just a small itch. But if you still want answers for &#8220;What is the best option?&#8221;, I would say it is the same answer for &#8220;Which challenge your team will endure more?&#8221;.<\/p>\n<p>Given that you prefer one deployment process over the others, I still think that no one should be attached totally with one process forever. Your problems can change, your team can change, your company rules can change, your application can change. Therefore, your deployment process should change together to deal with the new challenges. You can change your deployment in many ways, for example mixing ideas from each the of processes we discussed.<\/p>\n<p><em>I&#8217;m curious to know how your team deliver features. If you use one of these options, if you mix them or if you do something different. If you want share this knowledge, please leave a comment below.<\/em><\/p>\n<div style=\"padding:40px 0 20px;\">\n<a href=\"http:\/\/blog.plataformatec.com.br\/subscribe\/\"><img decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2014\/11\/subscribe-to-our-blog.png\" alt=\"Subscribe to our blog\" style=\"border:none;\" \/><\/a>\n<\/div>\n","protected":false},"excerpt":{"rendered":"<p>The way of deliver your product code to your customer is commonly called &#8220;deployment&#8221;. It is an important matter because it will impact in how fast your product will respond to changes and the quality of each change. Depending on which deployment decision you take, it will impact your team and how you use your &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2014\/12\/the-pros-and-cons-of-4-deployment-process-techniques\/\">\u00bb<\/a><\/p>\n","protected":false},"author":31,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[230],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4327"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/31"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=4327"}],"version-history":[{"count":15,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4327\/revisions"}],"predecessor-version":[{"id":4716,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4327\/revisions\/4716"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=4327"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=4327"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=4327"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}