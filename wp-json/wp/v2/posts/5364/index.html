{"id":5364,"date":"2016-05-04T17:14:32","date_gmt":"2016-05-04T20:14:32","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5364"},"modified":"2017-01-16T19:13:30","modified_gmt":"2017-01-16T21:13:30","slug":"ectos-insert_all-and-schemaless-queries","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/05\/ectos-insert_all-and-schemaless-queries\/","title":{"rendered":"Ecto&#8217;s insert_all and schemaless queries"},"content":{"rendered":"<p>One of the functions added to Ecto 2.0 is <a href=\"https:\/\/hexdocs.pm\/ecto\/2.0.0-rc.1\/Ecto.Repo.html#c:insert_all\/3\"><code>Ecto.Repo.insert_all\/3<\/code><\/a>. <code>insert_all<\/code> allows developers to insert multiple entries at once into a repository:<\/p>\n<pre><code class=\"elixir\">MyApp.Repo.insert_all(Post, [[title: \"hello\", body: \"world\"],\n                             [title: \"another\", body: \"post\"]])\n<\/code><\/pre>\n<p>Although <code>insert_all<\/code> is just a regular Elixir function, it plays an important role in Ecto 2.0 goals. To understand more about these goals, let&#8217;s talk about Ecto schemas.<\/p>\n<h2>The trouble with schemas<\/h2>\n<p>Conceptually speaking, Ecto 2.0 is quite different from Ecto 1.0 as it moves to a more data-oriented approach. We want developers to think of Ecto as a tool instead of their domain layer. One important decision in this direction was the removal of <code>Ecto.Model<\/code> in favor of <code>Ecto.Schema<\/code>.<\/p>\n<p>At this point, it is worth asking: what are schemas?<\/p>\n<p>Ecto schemas are used to map <em>any<\/em> data source into an Elixir struct. Schemas are useful because they give shape to external data and enforce its types:<\/p>\n<pre><code class=\"elixir\">defmodule Post do\n  use Ecto.Schema\n\n  schema \"posts\" do\n    field :title\n    field :body\n    field :votes, :integer, default: 0\n    timestamps\n  end\nend\n<\/code><\/pre>\n<p>One possible benefit of using schemas is that you define the shape of the data once and you can use this shape to retrieve data from the database as well as coordinate changes happening on the data. For example:<\/p>\n<pre><code class=\"elixir\">params = [title: \"new title\", votes: \"0\"]\n\nPost\n|&gt; MyApp.Repo.get!(13)\n|&gt; Ecto.Changeset.cast(params, [:title, :votes])\n|&gt; MyApp.Repo.update!\n<\/code><\/pre>\n<p>By relying on the schema information, Ecto knows the shape of the data when it reads from the database and know how to manage changes. In the example above, the &#8220;votes&#8221; field was automatically cast from string to an integer based on its schema type.<\/p>\n<p>While the benefits of schemas are known, we don&#8217;t talk as frequently about the downsides of schemas: which is exactly the coupling of the database representation to your application, leading developers to represent both reads and writes operations on top of the same structure.<\/p>\n<p>With schemaless queries, we get direct access to all underlying database operations, allowing us to perform both reads and writes operations without being coupled to a schema.<\/p>\n<h2>Schemaless queries<\/h2>\n<p>Ecto 2.0 allows read, create, update and delete operations to be done without a schema. <code>insert_all<\/code> was the last piece of the puzzle. Let&#8217;s see some examples.<\/p>\n<p>If you are writing a reporting view, it may be counter-productive to think how your existing application schemas relate to the report being generated. It is often simpler to write a query that returns only the data you need, without taking schemas into account:<\/p>\n<pre><code class=\"elixir\">import Ecto.Query\n\ndef running_activities(start_at, end_at)\n  MyApp.Repo.all(\n    from u in \"users\",\n      join: a in \"activities\",\n      on: a.user_id == u.id,\n      where: a.start_at &gt; type(^start_at, Ecto.DateTime) and\n             a.end_at &lt; type(^end_at, Ecto.DateTime),\n      group_by: a.user_id,\n      select: %{user_id: a.user_id, interval: a.start_at - a.end_at, count: count(u.id)}\n  )\nend\n<\/code><\/pre>\n<p>The function above does not care about your schemas. It returns only the data that matters for building the report. Notice how we use the <code>type\/2<\/code> function to specify what is the expected type of the argument we are interpolating, allowing us to benefit from the same type casting guarantees a schema would give.<\/p>\n<p>Inserts, updates and deletes can also be done without schemas via <code>insert_all<\/code>, <code>update_all<\/code> and <code>delete_all<\/code> respectively:<\/p>\n<pre><code class=\"elixir\"># Insert data into posts and return its ID\n[%{id: id}] =\n  MyApp.Repo.insert_all \"posts\", [[title: \"hello\"]], returning: [:id]\n\n# Use the ID to trigger updates\npost = from p in \"posts\", where: p.id == ^id\n{1, _} = MyApp.Repo.update_all post, set: [title: \"new title\"]\n\n# As well as for deletes\n{1, _} = MyApp.Repo.delete_all post\n<\/code><\/pre>\n<p>It is not hard to see how these operations directly map to their SQL variants, keeping the database at your fingertips without the need to intermediate all operations through schemas.<\/p>\n<h2>Schemas are mappers<\/h2>\n<p>When we defined schemas above, we said:<\/p>\n<blockquote><p>\n  Ecto schemas are used to map <em>any<\/em> data source into an Elixir struct.\n<\/p><\/blockquote>\n<p>We put emphasis on <em>any<\/em> because it is a common misconception to think Ecto schemas map only to your database tables.<\/p>\n<p>For instance, when you write a web application using Phoenix and you use Ecto to receive external changes and apply such changes to your database, we are actually mapping the schema to two different sources:<\/p>\n<pre><code>Database &lt;-&gt; Ecto schema &lt;-&gt; Forms \/ API\n<\/code><\/pre>\n<p>It is important to understand how the schema is sitting between your database and your API because in many situations it is better to break this mapping in two. Let&#8217;s see some practical examples.<\/p>\n<p>Imagine you are working with a client that wants the &#8220;Sign Up&#8221; form to contain the fields &#8220;First name&#8221;, &#8220;Last name&#8221; along side &#8220;E-mail&#8221; and other information. You know there are a couple problems with this approach.<\/p>\n<p>First of all, not everyone has a first and last name. Although your client is decided on presenting both fields, they are a UI concern, and you don&#8217;t want the UI to dictate the shape of your data. Furthermore, you know it would be useful to break the &#8220;Sign Up&#8221; information across two tables, the &#8220;accounts&#8221; and &#8220;profiles&#8221; tables.<\/p>\n<p>Given the requirements above, how would we implement the Sign Up feature in the backend?<\/p>\n<p>One approach would be to have two schemas, Account and Profile, with virtual fields such as <code>first_name<\/code> and <code>last_name<\/code>, and <a href=\"http:\/\/blog.plataformatec.com.br\/2015\/08\/working-with-ecto-associations-and-embeds\/\">use associations along side nested forms<\/a> to tie the schemas to your UI. One of such schemas would be:<\/p>\n<pre><code class=\"elixir\">defmodule Profile do\n  use Ecto.Schema\n\n  schema \"profiles\" do\n    field :name\n    field :first_name, :string, virtual: true\n    field :last_name, :string, virtual: true\n    ...\n  end\nend\n<\/code><\/pre>\n<p>It is not hard to see how we are polluting our Profile schema with UI requirements by adding fields such <code>first_name<\/code> and <code>last_name<\/code>. If the Profile schema is used for both reading and writing data, it may end-up in an awkward place where it is not useful for any, as it contains fields that map just to one or the other operation.<\/p>\n<p>One alternative solution is to break the &#8220;Database <-> Ecto schema <-> Forms \/ API&#8221; mapping in two parts. The first will cast and validate the external data with its own structure which you then transform and write to the database. For such, let&#8217;s define a schema named <code>Registration<\/code> that will take care of casting and validating the form data exclusively, mapping directly to the UI fields:<\/p>\n<pre><code class=\"elixir\">defmodule Registration do\n  use Ecto.Schema\n\n  embedded_schema do\n    field :first_name\n    field :last_name\n    field :email\n  end\nend\n<\/code><\/pre>\n<p>We used <code>embedded_schema<\/code> because it is not our intent to persist it anywhere. With the schema in hand, we can use Ecto changesets and validations to process the data:<\/p>\n<pre><code class=\"elixir\">fields = [:first_name, :last_name, :email]\n\nchangeset =\n  %Registration{}\n  |&gt; Ecto.Changeset.cast(params[\"sign_up\"], fields)\n  |&gt; validate_required(...)\n  |&gt; validate_length(...)\n<\/code><\/pre>\n<p>Now that the registration changes are mapped and validated, we can check if the resulting changeset is valid and act accordingly:<\/p>\n<pre><code class=\"elixir\">if changeset.valid? do\n  # Get the modified registration struct out of the changeset\n  registration = Ecto.Changeset.apply_changes(changeset)\n\n  MyApp.Repo.transaction fn -&gt;\n    MyApp.Repo.insert_all \"accounts\", Registration.to_account(registration)\n    MyApp.Repo.insert_all \"profiles\", Registration.to_profile(registration)\n  end\n\n  {:ok, registration}\nelse\n  # Annotate the action we tried to perform so the UI shows errors\n  changeset = %{changeset | action: :registration}\n  {:error, changeset}\nend\n<\/code><\/pre>\n<p>The <code>to_account\/1<\/code> and <code>to_profile\/1<\/code> functions in <code>Registration<\/code> would receive the registration struct and split the attributes apart accordingly:<\/p>\n<pre><code class=\"elixir\">def to_account(registration) do\n  Map.take(registration, [:email])\nend\n\ndef to_profile(%{first_name: first, last_name: last}) do\n  %{name: \"#{first} #{last}\"}\nend\n<\/code><\/pre>\n<p>In the example above, by breaking apart the mapping between the database and Elixir and between Elixir and the UI, our code becomes clearer and our data-structures simpler.<\/p>\n<p>Note we have used <code>MyApp.Repo.insert_all\/2<\/code> to add data to both &#8220;accounts&#8221; and &#8220;profiles&#8221; tables directly. We have chosen to bypass schemas altogether. However, there is nothing stopping you from also defining both <code>Account<\/code> and <code>Profile<\/code> schemas and changing <code>to_account\/1<\/code> and <code>to_profile\/1<\/code> to respectively return <code>%Account{}<\/code> and <code>%Profile{}<\/code> structs. Once structs are returned, they could be inserted through the usual <code>Repo.insert\/2<\/code> operation.<\/p>\n<p>Similarly, we chose to define a <code>Registration<\/code> schema to use in the changeset but Ecto 2.0 also allows developers to use changesets without schemas. We can dynamically define the data and their types. Let&#8217;s rewrite the registration changeset above to bypass schemas:<\/p>\n<pre><code class=\"elixir\">data  = %{}\ntypes = %{first_name: :string, last_name: :string, email: :string}\n\nchangeset =\n  {data, types} # The data+types tuple is equivalent to %Registration{}\n  |&gt; Ecto.Changeset.cast(params[\"sign_up\"], Map.keys(types))\n  |&gt; validate_required(...)\n  |&gt; validate_length(...)\n<\/code><\/pre>\n<p>You can use this technique to validate API endpoints, search forms, and other sources of data. The choice of using schemas depends mostly if you want to use the same mapping in different places and\/or if you desire the compile-time guarantees Elixir structs gives you. Otherwise, you can bypass schemas altogether, be it when using changesets or interacting with the repository.<\/p>\n<h2>Summary<\/h2>\n<p>Ecto 2.0 introduces <code>insert_all<\/code> that directly inserts data into a given table. <code>insert_all<\/code>, alongside <code>all<\/code>, <code>update_all<\/code> and <code>delete_all<\/code>, allows developers to work closer to the database without the need for using schemas.<\/p>\n<p>Such possibilities make Ecto 2.0 a substantial departure from earlier versions, as developers can focus more on how their data map to different domains, like the database and the UI, relying on Ecto as a tool to interact with each of those domains in the best possible way.<\/p>\n<hr style=\"margin-top:30px\" \/>\n<p><em>This article was extracted from an ebook <del datetime=\"2017-01-16T20:59:19+00:00\">we&#8217;re writing<\/del> we&#8217;ve written on What&#8217;s new in Ecto 2.0. <a href=\"http:\/\/pages.plataformatec.com.br\/ebook-whats-new-in-ecto-2-0?utm_source=our-blog&#038;utm_medium=referral&#038;utm_campaign=ebook-ecto-2-0&#038;utm_content=link-blog-post-text-bottom\">Click here<\/a> to receive a copy of the ebook now <del datetime=\"2017-01-16T20:59:19+00:00\">when it&#8217;s ready<\/del>.<\/em><\/p>\n<p><a href=\"http:\/\/pages.plataformatec.com.br\/ebook-whats-new-in-ecto-2-0?utm_source=our-blog&#038;utm_medium=referral&#038;utm_campaign=ebook-ecto-2-0&#038;utm_content=cta-blog-post-bottom\" target=\"_blank\"><br \/>\n<img loading=\"lazy\" decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0.jpg\" alt=\"What&#039;s new in Ecto 2.0 -- Download your copy\" width=\"831\" height=\"147\" class=\"aligncenter size-full wp-image-5997\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0.jpg 831w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0-300x53.jpg 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/12\/CTA-blog-ebook-ecto-2-0-768x136.jpg 768w\" sizes=\"(max-width: 831px) 100vw, 831px\" \/><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>One of the functions added to Ecto 2.0 is Ecto.Repo.insert_all\/3. insert_all allows developers to insert multiple entries at once into a repository: MyApp.Repo.insert_all(Post, [[title: &#8220;hello&#8221;, body: &#8220;world&#8221;], [title: &#8220;another&#8221;, body: &#8220;post&#8221;]]) Although insert_all is just a regular Elixir function, it plays an important role in Ecto 2.0 goals. To understand more about these goals, let&#8217;s &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/05\/ectos-insert_all-and-schemaless-queries\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5364"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5364"}],"version-history":[{"count":16,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5364\/revisions"}],"predecessor-version":[{"id":6027,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5364\/revisions\/6027"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5364"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5364"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5364"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}