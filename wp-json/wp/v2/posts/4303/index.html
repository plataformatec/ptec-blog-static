{"id":4303,"date":"2014-11-12T09:00:42","date_gmt":"2014-11-12T11:00:42","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=4303"},"modified":"2015-06-01T12:24:28","modified_gmt":"2015-06-01T15:24:28","slug":"converting-erlang-code-into-elixir","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2014\/11\/converting-erlang-code-into-elixir\/","title":{"rendered":"Converting Erlang code into Elixir"},"content":{"rendered":"<p>When you are new to any language, you probably want to run some existing code just to see how it works. <a href=\"https:\/\/www.youtube.com\/watch?v=Djv4C9H9yz4\">Achieving success<\/a> while trying new things is important, because it helps fueling your interest.<\/p>\n<p>The number of code examples in Elixir is increasing, but sometimes you will have to read some Erlang code. Recently, I wanted to play a little bit with Cowboy HTTP Server, which is written in Erlang. The Cowboy repo has a lot of <a href=\"https:\/\/github.com\/ninenines\/cowboy\/tree\/b57f94661f5fd186f55eb0fead49849e0b1399d1\/examples\">small examples<\/a> presenting the features which is provided by it. When I tried to convert one of them to Elixir, it wasn&#8217;t as simple as I expected, since I&#8217;m not so familiarized  with the language yet.<\/p>\n<p>When converting, you may get into some misleading code that will not work as you expected at first. So, I&#8217;m going to present a transcoding of  <a href=\"https:\/\/github.com\/ninenines\/cowboy\/tree\/b57f94661f5fd186f55eb0fead49849e0b1399d1\/examples\/websocket\">Cowboy WebSocket server example<\/a> from Erlang to Elixir, so that you can learn some of the details that exists in the process of porting Erlang code into Elixir code.<\/p>\n<p>This will not be a tutorial explaining how that Cowboy example works, it&#8217;s just about how to convert it to Elixir. Also, I&#8217;m not going to show how it could be done in idiomatic Elixir, the goal here is to translate Erlang code into Elixir the simplest way possible.<\/p>\n<p>So let&#8217;s start!<\/p>\n<h2>Creating the project<\/h2>\n<p>Create a project called <code>ws_cowboy<\/code> with the following command:<\/p>\n<pre lang=\"bash\">\nmix new ws_cowboy\ncd ws_cowboy\n<\/pre>\n<p>After that we are going to change\/create 4 files:<\/p>\n<ul>\n<li><code>mix.exs<\/code>: declares the dependencies in the project and the application module to run<\/li>\n<li><code>lib\/ws_cowboy.ex<\/code>: the application module that setups the cowboy routes and http server<\/li>\n<li><code>lib\/ws_handler.ex<\/code>: handles a WebSocket request connection<\/li>\n<li><code>lib\/ws_supervisor.ex<\/code>: supervisor for Cowboy server<\/li>\n<\/ul>\n<p>Also, copy the whole <a href=\"https:\/\/github.com\/ninenines\/cowboy\/tree\/b57f94661f5fd186f55eb0fead49849e0b1399d1\/examples\/websocket\/priv\"><code>priv<\/code><\/a> directory from the <a href=\"https:\/\/github.com\/ninenines\/cowboy\/tree\/b57f94661f5fd186f55eb0fead49849e0b1399d1\/examples\/websocket\">Cowboy example<\/a> to the project&#8217;s root dir.<\/p>\n<h2>The project definition<\/h2>\n<p>In the <code>mix.exs<\/code> file we are going to add the Cowboy dependency and also configure the module application, in this case <code>WsCowboy<\/code>.<\/p>\n<pre lang=\"elixir\">\ndefmodule WsCowboy.Mixfile do\n  use Mix.Project\n\n  def project do\n    [app: :ws_cowboy,\n     version: \"0.0.1\",\n     elixir: \"~> 1.0\",\n     deps: deps]\n  end\n\n  # Configuration for the OTP application\n  #\n  # Type `mix help compile.app` for more information\n  def application do\n    [applications: [:logger, :cowboy],\n     mod: {WsCowboy, []}]\n  end\n\n  # Dependencies can be Hex packages:\n  #\n  #   {:mydep, \"~> 0.3.0\"}\n  #\n  # Or git\/path repositories:\n  #\n  #   {:mydep, git: \"https:\/\/github.com\/elixir-lang\/mydep.git\", tag: \"0.1.0\"}\n  #\n  # Type `mix help deps` for more examples and options\n  defp deps do\n    [{:cowboy, \"~> 1.0.0\"}]\n  end\nend\n<\/pre>\n<h2>Configuring the HTTP application<\/h2>\n<p>Here is the transcode of <code>websocket_app.erl<\/code> file to the <code>ws_cowboy.ex<\/code> file:<\/p>\n<pre lang=\"elixir\">\ndefmodule WsCowboy do\n  @behaviour :application\n\n  def start(_type, _args) do\n    dispatch = :cowboy_router.compile([\n      {:_, [\n        {\"\/\", :cowboy_static, {:priv_file, :ws_cowboy, \"index.html\"}},\n        {\"\/websocket\", WsHandler, []},\n        {\"\/static\/[...]\", :cowboy_static, {:priv_dir, :ws_cowboy, \"static\"}}\n      ]}\n    ])\n    {:ok, _} = :cowboy.start_http(:http, 100, [{:port, 8080}],\n                                  [{:env, [{:dispatch, dispatch}]}])\n    WsSupervisor.start_link\n  end\n\n  def stop(_state) do\n    :ok\n  end\nend\n<\/pre>\n<p>If you never read any Erlang code and you came from a language like Ruby, you might get confused on basic things. So, let&#8217;s go through some of the details of porting <code>websocket_app.erl<\/code> to the <code>ws_cowboy.ex<\/code>.<\/p>\n<p>Erlang files represents a module, in Elixir it is the same thing, but in this case we use the <code>defmodule<\/code> macro. Erlang modules can be accessed using <code>:&lt;module_name&gt;<\/code>, so in this case we are defining that this module has the application behaviour.<\/p>\n<p>Different from other languages like Ruby, lowercase names aren&#8217;t variables in Erlang, but atoms, while in Elixir atoms look the same as Ruby symbols. So, we scanned every lowercase names and replaced them with <code>:&lt;name&gt;<\/code>.<\/p>\n<p>Upper case names in Erlang aren&#8217;t constant but variables, so we changed them to lowercase. It is good to do this in inverse order to avoid mixing variables and atoms.<\/p>\n<p>During the process of converting this file, there was a line making the application not work and I spent some time trying to figure out what was wrong. In Ruby, <code>'foo'<\/code> and <code>\"foo\"<\/code> are both strings, but in Elixir and Erlang they are different things. The single quote in Erlang is an atom (symbol), so the <code>'_'<\/code> line must be converted to <code>:_<\/code> in Elixir. If you miss this little detail, unfortunately it will compile and run, but Cowboy will always return a 400 status code.<\/p>\n<p>Except that, everything is pretty straightforward, the only detail is the <code>:cowboy_static<\/code> definition that you have to replace with your dir app name, in this case <code>:ws_cowboy<\/code>.<\/p>\n<p>To transcode function calls, you just have to replace the <code>:<\/code> with <code>.<\/code>, like in Ruby.<\/p>\n<h2>Handling the WebSocket connection<\/h2>\n<p>You can read more about how Cowboy handles WebSocket <a href=\"http:\/\/ninenines.eu\/docs\/en\/cowboy\/HEAD\/guide\/ws_handlers\/\">here<\/a>. Here&#8217;s the transcode of the file <code>ws_handler.erl<\/code> to <code>ws_handler.ex<\/code>:<\/p>\n<pre lang=\"elixir\">\ndefmodule WsHandler do\n  @behaviour :cowboy_websocket_handler\n\n  def init({:tcp, :http}, _req, _opts) do\n    {:upgrade, :protocol, :cowboy_websocket}\n  end\n\n  def websocket_init(_transport_name, req, _opts) do\n    :erlang.start_timer(1000, self(), \"Hello!\")\n    {:ok, req, :undefined_state}\n  end\n\n  def websocket_handle({:text, msg}, req, state) do\n    {:reply, {:text, \"That's what she said! #{msg}\"}, req, state}\n  end\n\n  def websocket_handle(_data, req, state) do\n    {:ok, req, state}\n  end\n\n  def websocket_info({:timeout, _ref, msg}, req, state) do\n    :erlang.start_timer(1000, self(), \"How' you doin'?\")\n    {:reply, {:text, msg}, req, state}\n  end\n\n  def websocket_info(_info, req, state) do\n    {:ok, req, state}\n  end\n\n  def websocket_terminate(_reason, _req, _state) do\n    :ok\n  end\nend\n<\/pre>\n<p>Following the steps done in the previous file, there is no secret on this one. The only detail is that the Erlang version used binary notation for strings, but in Elixir you can use just <code>\"string\"<\/code> normally. Also, you can use string interpolation <code>\"That's what she said! #{msg}\"<\/code>.<\/p>\n<h2>Writing the supervisor<\/h2>\n<p>Now there&#8217;s just one translation missing, from <code>websocket_sup.erl<\/code> to <code>ws_supervisor.ex<\/code>. Here we just used <code>__MODULE__<\/code> instead of the Erlang <code>?MODULE<\/code>:<\/p>\n<pre lang=\"elixir\">\ndefmodule WsSupervisor do\n  @behaviour :supervisor\n\n  def start_link do\n    :supervisor.start_link({:local, __MODULE__}, __MODULE__, [])\n  end\n\n  def init([]) do\n    procs = []\n    {:ok, {{:one_for_one, 10, 10}, procs}}\n  end\nend\n<\/pre>\n<h2>Running your server<\/h2>\n<p>Running your server is pretty easy, just run the <code>mix run --no-halt<\/code> command and check http:\/\/127.0.0.1:8080 in your browser.<\/p>\n<h2>Conclusion<\/h2>\n<p>The goal of this post was to show an example of how to port Erlang code into Elixir code. The result we got is the simplest translation possible, it was not my idea to write idiomatic Elixir here. For example, in Elixir you would not use Erlang&#8217;s supervisor module, but rather the Elixir&#8217;s supervisor.<\/p>\n<p>I hope you could get the picture of how it is to translate Erlang code into Elixir, how it&#8217;s not so hard and some of the details that you must pay attention while doing it.<\/p>\n<p>If you are interesting in learning more about Elixir, check out the <a href=\"http:\/\/elixir-lang.org\/getting_started\/1.html\">getting started page<\/a>.<\/p>\n<p><em>Do you had any issues when starting to play with Elixir that you cracked your head to figuring out why it didn&#8217;t work? Share your experience and doubts with us!<\/em><\/p>\n<div style=\"padding:40px 0 20px;\">\n<a href=\"http:\/\/blog.plataformatec.com.br\/subscribe\/\"><img decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2014\/11\/subscribe-to-our-blog.png\" alt=\"Subscribe to our blog\" style=\"border:none;\" \/><\/a>\n<\/div>\n","protected":false},"excerpt":{"rendered":"<p>When you are new to any language, you probably want to run some existing code just to see how it works. Achieving success while trying new things is important, because it helps fueling your interest. The number of code examples in Elixir is increasing, but sometimes you will have to read some Erlang code. Recently, &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2014\/11\/converting-erlang-code-into-elixir\/\">\u00bb<\/a><\/p>\n","protected":false},"author":9,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4303"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/9"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=4303"}],"version-history":[{"count":11,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4303\/revisions"}],"predecessor-version":[{"id":5491,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4303\/revisions\/5491"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=4303"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=4303"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=4303"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}