{"id":5007,"date":"2016-01-21T07:00:08","date_gmt":"2016-01-21T09:00:08","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5007"},"modified":"2016-01-28T12:34:10","modified_gmt":"2016-01-28T14:34:10","slug":"writing-acceptance-tests-in-phoenix","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/01\/writing-acceptance-tests-in-phoenix\/","title":{"rendered":"Writing Acceptance tests in Phoenix"},"content":{"rendered":"<p>Acceptance testing seems to be in its first steps in the Elixir ecosystem, but there are already some cool libs that can help us out to do it. I&#8217;m going to show you how we did it with <a href=\"https:\/\/github.com\/HashNuke\/hound\">Hound<\/a>.<\/p>\n<p>In this blog post, we&#8217;ll write a few acceptance tests for an expenses report listing page, where we&#8217;ll interact with the report and some form elements.<\/p>\n<p>To make possible to interact with the elements on the page, we&#8217;ll need a web browser driver. Hound accepts <code>chrome_driver<\/code>, <code>firefox<\/code>, <code>phantomjs<\/code> and <code>selenium<\/code>. My choice is <code>phantomjs<\/code> because I want to use a headless browser (I don&#8217;t want the driver to open a browser during the execution of the test suite).<\/p>\n<h2>Setup<\/h2>\n<p>First we&#8217;ll need to add Hound into our dependencies, so add the following line in your <code>mix.exs<\/code>:<\/p>\n<pre><code class=\"elixir\">{:hound, \"~&gt; 0.8\"}\n<\/code><\/pre>\n<p>Make sure it&#8217;ll start during the test suite runtime. To do this we&#8217;ll need to add <code>Application.ensure_all_started(:hound)<\/code> before <code>ExUnit.start<\/code> in our test helper:<\/p>\n<pre><code class=\"elixir\">Application.ensure_all_started(:hound)\nExUnit.start\n<\/code><\/pre>\n<p>We&#8217;ll be using <code>phantomjs<\/code> as our web driver. <a href=\"http:\/\/phantomjs.org\/download.html\">Make sure it&#8217;s properly installed and that you can start it<\/a> with <code>phantomjs --wd<\/code>. To configure it, add this to the <code>config.exs<\/code> file:<\/p>\n<pre><code class=\"elixir\">config :hound, driver: \"phantomjs\"\n<\/code><\/pre>\n<p>Take a look at <a href=\"https:\/\/github.com\/HashNuke\/hound\/blob\/master\/notes\/configuring-hound.md\">this doc from Hound resources<\/a> to check if you&#8217;d like different configs.<\/p>\n<p>We&#8217;ll also need to set the server config in our <code>config\/test.exs<\/code>to <code>true<\/code>.<\/p>\n<pre><code class=\"elixir\">config :my_app, MyApp.Endpoint,\n  http: [port: 4001]\n  server: true\n<\/code><\/pre>\n<p>That should do it! Before writing our first test, let&#8217;s define an <code>IntegrationCase<\/code> module, similar to the <code>ModelCase<\/code> and <code>ConnCase<\/code> provided by Phoenix, which will include all functionality we need to write our integration tests. Create the <code>test\/support\/integration_case.ex<\/code> file and add the following content:<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.IntegrationCase do\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      use Hound.Helpers\n\n      import Ecto.Model\n      import Ecto.Query, only: [from: 2]\n      import MyApp.Router.Helpers\n\n      alias MyApp.Repo\n\n      # The default endpoint for testing\n      @endpoint MyApp.Endpoint\n\n      hound_session\n    end\n  end\n\n  setup tags do\n    unless tags[:async] do\n      Ecto.Adapters.SQL.restart_test_transaction(MyApp.Repo, [])\n    end\n\n    :ok\n  end\nend\n<\/code><\/pre>\n<p>There are a few lines that are worth commenting:<\/p>\n<ul>\n<li><code>use Hound.Helpers<\/code> will include the helpers necessary for us to interact with our interface (<a href=\"http:\/\/hexdocs.pm\/hound\/readme.html\">take a look at the docs and explore them a little, they&#8217;ll be very helpful<\/a>);<\/li>\n<li><code>hound_session<\/code> will make sure that Hound will start and closes its session during the test execution;<\/li>\n<li><code>import MyApp.Router.Helpers<\/code> will include helpers so we can manipulate routes and URLs.<\/li>\n<\/ul>\n<h2>Exercise<\/h2>\n<p>Let&#8217;s test!<\/p>\n<p>We&#8217;re testing a simple list of expenses from a city (that example was extracted from an app we have been working on, but its scope was reduced so we can follow the steps more easily).<\/p>\n<p>Take a look at its template code:<\/p>\n<pre><code class=\"html\">&lt;div&gt;\n  &lt;%= form_for @conn, city_expense_path(@conn, :index, @city.id), [as: :q, method: :get], fn f -&gt; %&gt;\n    &lt;div&gt;\n      &lt;label for=&quot;q_status&quot;&gt;Status&lt;\/label&gt;\n      &lt;%=\n        select f, :status, [{&quot;Paid&quot;, &quot;paid&quot;}, {&quot;Cancelled&quot;, &quot;cancelled&quot;}], prompt: &quot;All&quot; %&gt;\n    &lt;\/div&gt;\n\n    &lt;div&gt;\n      &lt;label for=&quot;q_supplier&quot;&gt;Supplier&lt;\/label&gt;\n      &lt;%= text_input f, :supplier %&gt;\n    &lt;\/div&gt;\n\n    &lt;%= submit &quot;Submit&quot; %&gt;\n  &lt;% end %&gt;\n&lt;\/div&gt;\n\n&lt;table&gt;\n  &lt;thead&gt;\n    &lt;th&gt;ID&lt;\/th&gt;\n    &lt;th&gt;Status&lt;\/th&gt;\n    &lt;th&gt;Supplier&lt;\/th&gt;\n    &lt;th&gt;Value&lt;\/th&gt;\n    &lt;th&gt;Date&lt;\/th&gt;\n  &lt;\/thead&gt;\n  &lt;tbody&gt;\n    &lt;%= for expense &lt;- @expenses do %&gt;\n      &lt;tr&gt;\n        &lt;td&gt;&lt;%= expense.id %&gt;&lt;\/td&gt;\n        &lt;td&gt;&lt;%= expense.status %&gt;&lt;\/td&gt;\n        &lt;td&gt;&lt;%= expense.supplier.name %&gt;&lt;\/td&gt;\n        &lt;td&gt;&lt;%= expense.value %&gt;&lt;\/td&gt;\n        &lt;td&gt;&lt;%= expense.date %&gt;&lt;\/td&gt;\n      &lt;\/tr&gt;\n    &lt;% end %&gt;\n  &lt;\/tbody&gt;\n&lt;\/table&gt;\n<\/code><\/pre>\n<p>We&#8217;ll need a new test file, let&#8217;s put it at <code>test\/integration\/expenses_list_test.exs<\/code>. To use Hound\u2019s facilities, we&#8217;ll need to use the <code>IntegrationCase<\/code> module that we have previously created.<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.ExpenseListTest do\n  use MyApp.IntegrationCase\n\nend\n<\/code><\/pre>\n<p>We&#8217;ll be using three private functions to help us making assertions and interacting with elements in our test file. The first one, <code>expense_on_the_list<\/code>, will check if a given expense, that is represented by the Ecto model called <code>MyApp.Expense<\/code>, is in there. The second function is just a helper for getting the expenses list and the third will help us interact with a select input within a form.<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.ExpenseListTest do\n  use MyApp.IntegrationCase\n\n  # ...\n\n  defp expense_on_the_list(expense, list) do\n    list\n    |&gt; visible_text\n    |&gt; String.contains?(expense.id)\n  end\n\n  defp expense_list_items do\n    find_element(:tag, \"tbody\")\n    |&gt; find_all_within_element(:tag, \"tr\")\n  end\n\n  defp select_status(form, status) do\n    form\n    |&gt; find_within_element(:id, \"q_status\")\n    |&gt; input_into_field(status)\n  end\nend\n<\/code><\/pre>\n<p>To interact with an element, you&#8217;ll always need to find the element on the page and for this, you need to know Hound&#8217;s <a href=\"http:\/\/hexdocs.pm\/hound\/Hound.Helpers.Page.html\">page helpers<\/a>. I&#8217;ve noticed that we ended up using <code>find_element<\/code> and <code>find_all_within_element<\/code> most of the time to find the elements on the page or in a context (i.e inside a previously found element).<\/p>\n<p>Since this test is about the City resource, we&#8217;ve created just this city and navigated to it directly on the setup, since this would be a requirement for all the tests in this file, and shared it with all the tests through the setup context.<\/p>\n<pre><code class=\"elixir\">setup do\n  city = insert_city!(%{name: \"Winterfell\"})\n\n  navigate_to(\"\/cities\/#{city.id}\/expenses\")\n\n  {:ok, city: city}\nend\n<\/code><\/pre>\n<p><a href=\"http:\/\/hexdocs.pm\/hound\/Hound.Helpers.Navigation.html#content\">Navigation<\/a> is another important Hound module. It will help us go through our app easily and get info about the page, like the <code>current_path()<\/code> function that returns the path we&#8217;re navigating on that moment.<\/p>\n<p>Now that we&#8217;re on the page, we&#8217;ll be interacting with the form, by finding elements that are within it and filling or selecting values on them.<\/p>\n<pre><code class=\"elixir\">test \"filter by supplier\", %{city: city} do\n  supplier = insert_supplier!(%{name: \"Ned Stark\"})\n  supplier_b = insert_supplier!(%{name: \"Bell Tower Management\"})\n  expense = insert_expense!(%{supplier: supplier, city: city, status: \"paid\"})\n  insert_expense!(%{supplier: supplier_b, city: city, status: \"paid\"})\n\n  search_form = find_element(:tag, \"form\")\n  search_form\n  |&gt; find_within_element(:id, \"q_supplier\")\n  |&gt; fill_field(\"Ned\")\n\n  submit_element(search_form)\n\n\n  items = expense_list_items\n  assert length(items) == 1\n  assert expense_on_the_list(expense, items)\nend\n<\/code><\/pre>\n<p>The module responsible for these tasks is <a href=\"http:\/\/hexdocs.pm\/hound\/Hound.Helpers.Element.html\">Element<\/a>. It has very useful functions, like <code>fill_field<\/code> we used above. All of its functions require an element.<\/p>\n<p>In the previous example, the interactions with the form ended with <code>submit_element<\/code>, but if we need any other action on it after this, we would need to re-assign it (otherwise, we&#8217;ll get a <code>** (RuntimeError) Element does not exist in cache<\/code> error), like in the following example:<\/p>\n<pre><code class=\"elixir\">test \"filter by statuses\", %{city: city} do\n  supplier = insert_supplier!(%{name: \"Jon Snow\"})\n\n  cancelled_expense = insert_expense!(%{supplier: supplier, city: city, status: \"cancelled\"})\n  paid_expense = insert_expense!(%{supplier: supplier, city: city, status: \"paid\"})\n\n  search_form = find_element(:tag, \"form\")\n  select_status(search_form, \"Cancelled\")\n\n  submit_element(search_form)\n\n  items = expense_list_items\n  assert length(items) == 1\n  assert expense_on_the_list(cancelled_expense, items)\n\n  search_form = find_element(:tag, \"form\")\n  select_status(search_form, \"Paid\")\n  submit_element(search_form)\n\n  items = expense_list_items\n  assert length(items) == 1\n  assert expense_on_the_list(paid_expense, items)\nend\n<\/code><\/pre>\n<h2>Verify<\/h2>\n<h3>Runtime<\/h3>\n<p>One of the things I&#8217;ve paid a lot of attention during this experience was the test suite runtime. As expected, it can get slow with acceptance tests. The original app is still really tiny and before adding the acceptance tests, the runtime was:<\/p>\n<pre><code>Finished in 0.6 seconds (0.5s on load, 0.1s on tests)\n23 tests, 0 failures, 2 skipped\n<\/code><\/pre>\n<p>After including two tests (but with more interactions than the ones presented), it was noticeable the test suite became slower. It tripled the runtime.<\/p>\n<pre><code>Finished in 1.8 seconds (0.5s on load, 1.2s on tests)\n25 tests, 0 failures, 2 skipped\n<\/code><\/pre>\n<p>This effect is actually expected. We know that acceptance tests are expensive and that they should be a small portion of your <a href=\"http:\/\/martinfowler.com\/bliki\/TestPyramid.html\">test pyramid<\/a><\/p>\n<p>There are a few things that can make acceptance tests faster:<\/p>\n<ul>\n<li>Upcoming Ecto v2.0 will allow us to <a href=\"https:\/\/github.com\/elixir-lang\/ecto\/pull\/1198\">run tests that use database persistence asyncronously<\/a>;<\/p>\n<\/li>\n<li>\n<p>In my experience Phantom.js considerably faster than the other options, I recommend you to go with it.<\/p>\n<\/li>\n<\/ul>\n<p>You will definitely need to write some acceptance tests, but give preference to controller tests in most scenarios and use acceptance tests for important flows of your app (take a look at the <a href=\"https:\/\/www.techwell.com\/2012\/10\/performing-effective-automated-acceptance-testing\">user journey concept<\/a>, that can give you some good insights).<\/p>\n<h2>Web driver server execution<\/h2>\n<p>Currently, Hound doesn&#8217;t execute the browser automatically during tests. You&#8217;ll need to start it; otherwise, your tests will fail. There may be some workarounds to achieve it, if you&#8217;re on OS X, you can run <a href=\"http:\/\/blog.animascodelabs.com\/2015\/12\/31\/running-phantomjs-ghostdriver-as-an-osx-service\/\">Phantomjs as a service<\/a>.<\/p>\n<h2>Teardown<\/h2>\n<p>I really enjoyed playing with Hound, and I found very simple to work with it. Also, I see it as a potential project if you&#8217;re considering contributing to an Open Source Project.<\/p>\n<p>I hope this post was useful and gave you some ideas of how to write acceptance tests with Elixir and Phoenix. If you have any questions or suggestions, I&#8217;m all ears (or eyes).<\/p>\n<p><em>Which tool have you recently found to be useful when writing tests in Elixir?<\/em><\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&#038;utm_medium=referral&#038;utm_campaign=elixir-radar&#038;utm_content=elixir-radar-cta-blog-post-bottom\"><br \/>\n  <img decoding=\"async\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\" style=\"border:0\"><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Acceptance testing seems to be in its first steps in the Elixir ecosystem, but there are already some cool libs that can help us out to do it. I&#8217;m going to show you how we did it with Hound. In this blog post, we&#8217;ll write a few acceptance tests for an expenses report listing page, &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/01\/writing-acceptance-tests-in-phoenix\/\">\u00bb<\/a><\/p>\n","protected":false},"author":38,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[130,143,245,96],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5007"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/38"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5007"}],"version-history":[{"count":23,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5007\/revisions"}],"predecessor-version":[{"id":5046,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5007\/revisions\/5046"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5007"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5007"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5007"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}