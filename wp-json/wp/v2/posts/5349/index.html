{"id":5349,"date":"2016-04-28T15:50:27","date_gmt":"2016-04-28T18:50:27","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=5349"},"modified":"2016-10-31T16:56:56","modified_gmt":"2016-10-31T18:56:56","slug":"running-migration-in-an-exrm-release","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2016\/04\/running-migration-in-an-exrm-release\/","title":{"rendered":"Running migration in an Exrm release"},"content":{"rendered":"<p><a href=\"https:\/\/github.com\/bitwalker\/exrm\">Exrm<\/a> is a great tool for building releases for Elixir applications so you can deploy them on the web and even in an embedded hardware.<\/p>\n<p>We have been using Exrm here at Plataformatec. It is the chosen tool for deploying our projects and the contributors are doing a great job maintaining and developing new features. However, since Exrm is in its early days, it&#8217;s natural that there are some features that aren&#8217;t completely covered yet. One of these features was the possibility to run migration tasks on a release.<\/p>\n<p>An Exrm release is a package with binaries, dependencies and tools so you can run and manage it independently. All needed dependencies are compiled within the releases. Even Erlang and Elixir binaries are compiled within the release, so we don&#8217;t need to install it in the machine. It&#8217;s a self-contained package! As we don&#8217;t have the source code included in our release, we can&#8217;t run Mix tasks because it needs a <code>mix.exs<\/code> file.<\/p>\n<p>To run our migrations without Mix, an approach is using the Exrm console. There you can call <a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Migrator.html#up\/4\">Ecto Migrator<\/a>.<\/p>\n<p>However, since the 1.0.3 version, <a href=\"https:\/\/github.com\/bitwalker\/exrm\/pull\/295\">we have a <code>command<\/code> task available<\/a> for Exrm releases. With this interface, we can call a module defined within our Elixir application.<\/p>\n<p>Example:<\/p>\n<pre><code>rel\/my_app\/bin\/my_app command &lt;Module&gt; &lt;function&gt; &lt;args&gt;\n<\/code><\/pre>\n<h3>How does it work?<\/h3>\n<p>Well, under the hood, what this task does is basically the same we needed to do before. It opens a console and runs the code we&#8217;ve sent. Although, it runs an Erlang console (through the <code>erlexec<\/code> binary contained in the release).<\/p>\n<h3>To the migration!<\/h3>\n<p>We&#8217;ve defined an Elixir module in our app and a <code>migrate<\/code> function:<\/p>\n<pre><code class=\"elixir\">defmodule Release.Tasks do\n  def migrate do\n    {:ok, _} = Application.ensure_all_started(:my_app)\n\n    path = Application.app_dir(:my_app, \"priv\/repo\/migrations\")\n\n    Ecto.Migrator.run(MyApp.Repo, path, :up, all: true)\n\n    :init.stop()\n  end\nend\n<\/code><\/pre>\n<p>Notice that in order to run the migrations, we&#8217;ll need to ensure that our app or the supervisor tree that Ecto counts in. In this example, we&#8217;ve just ensured that the entire app has started, but you could get only <code>ecto<\/code>, <code>postgrex<\/code> and <code>logger<\/code>. Also, we need to call <code>:init.stop<\/code> in order to close the console, otherwise our buffer will remain opened, waiting for something.<\/p>\n<p>To call this function we&#8217;ll need to:<\/p>\n<pre><code>rel\/my_app\/bin\/my_app command Elixir.Release.Tasks migrate\n<\/code><\/pre>\n<p>We need to include the <code>Elixir<\/code> namespace because we&#8217;re running it in an Erlang console, as explained above. Otherwise, we can&#8217;t reach the module.<\/p>\n<p>Another possible approach is defining an Erlang module instead of Elixir&#8217;s:<\/p>\n<pre><code class=\"elixir\">defmodule :release_tasks do\n  def migrate do\n    {:ok, _} = Application.ensure_all_started(:my_app)\n\n    path = Application.app_dir(:my_app, \"priv\/repo\/migrations\")\n\n    Ecto.Migrator.run(MyApp.Repo, path, :up, all: true)\n\n    :init.stop()\n  end\nend\n<\/code><\/pre>\n<p>This way our call gets a bit prettier:<\/p>\n<pre><code>rel\/my_app\/bin\/my_app command release_tasks migrate\n<\/code><\/pre>\n<h3>Conclusion<\/h3>\n<p>Since Elixir&#8217;s early days, several people are contributing and developing great tools. We&#8217;re certain that this is one of the reasons that makes Elixir so attractive. And because of this, things are getting better for us in Elixir when dealing with releases and deployments.<\/p>\n<p>This blog post is highly inspired by an <a href=\"https:\/\/github.com\/bitwalker\/exrm\/issues\/67\">Exrm issue discussion<\/a>. Make sure to read or cooperate with it if you feel like it. There are plenty of great tips in it and they&#8217;ll probably have tons more as this idea grows.<\/p>\n<p>How are you currently dealing with these tasks? Are there any tips to share?<\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=elixir-radar&amp;utm_content=elixir-radar-cta-blog-post-bottom\"><br \/>\n<img decoding=\"async\" style=\"border: 0;\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\" \/><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Exrm is a great tool for building releases for Elixir applications so you can deploy them on the web and even in an embedded hardware. We have been using Exrm here at Plataformatec. It is the chosen tool for deploying our projects and the contributors are doing a great job maintaining and developing new features. &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2016\/04\/running-migration-in-an-exrm-release\/\">\u00bb<\/a><\/p>\n","protected":false},"author":38,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[230,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5349"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/38"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=5349"}],"version-history":[{"count":9,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5349\/revisions"}],"predecessor-version":[{"id":5775,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/5349\/revisions\/5775"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=5349"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=5349"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=5349"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}