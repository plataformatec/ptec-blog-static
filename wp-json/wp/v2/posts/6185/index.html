{"id":6185,"date":"2017-03-17T13:25:30","date_gmt":"2017-03-17T16:25:30","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=6185"},"modified":"2017-04-14T15:11:22","modified_gmt":"2017-04-14T18:11:22","slug":"small-data-with-elixir","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2017\/03\/small-data-with-elixir\/","title":{"rendered":"Small data with Elixir"},"content":{"rendered":"<p>This is the first article in a series of articles about &#8220;small data&#8221; (in contrast to &#8220;big data&#8221;) in Elixir. We will start by defining what is &#8220;small data&#8221;, why it matters and then briefly describe the <code>Flow<\/code> tool and what to expect in the next articles of the series.<\/p>\n<h2>How small is small?<\/h2>\n<p>We define small data as data that can be processed by a single machine in a desirable time interval. Such work may be done in batches, where all the data is known upfront, or on streaming data, where one or more machines can keep up with the incoming rate of events without a need for synchronization.<\/p>\n<p>Yanpei Chen, Sara Alspaugh, and Randy Katz, from University of California, have <a href=\"https:\/\/people.eecs.berkeley.edu\/~alspaugh\/papers\/mapred_workloads_vldb_2012.pdf\">characterized different MapReduce workloads<\/a>, and concluded that:<\/p>\n<blockquote style=\"border-left: solid 4px #bbb; padding-left: 15px; color: #888;\"><p>\nFor job-level scheduling and execution planning all workloads contain a range of job types, with the most common being small jobs. These jobs are small in all dimensions compared with other jobs in the same workload. They involve 10s of KB to GB of data, exhibit a range of data patterns between the map and reduce stages, and have durations of 10s of seconds to a few minutes.\n<\/p><\/blockquote>\n<p>Ionel Gog, Malte Schwarzkopf, Natacha Crooks, Matthew P. Grosvenor, Allen Clement, and Steven Hand, from University of Cambridge and Max Planck Institute for Software Systems, when <a href=\"http:\/\/www.cl.cam.ac.uk\/research\/srg\/netos\/camsas\/pubs\/eurosys15-musketeer.pdf\">developing Musketeer<\/a> compared different solutions and found that<\/p>\n<blockquote style=\"border-left: solid 4px #bbb; padding-left: 15px; color: #888;\"><p>\nFor small inputs (\u2264 0.5GB), the Metis single-machine MapReduce system performs best. This matters, as small inputs are common in practice: 40\u201380% of Cloudera customers\u2019 MapReduce jobs and 70% of jobs in a Facebook trace have \u2264 1GB of input.\n<\/p><\/blockquote>\n<p>Often the computation was not the bottleneck but reading the data from external sources. Being able to stream from and to external sources in parallel is paramount for the performance of such systems.<\/p>\n<p>Finally, Frank McSherry, Michael Isardm, and Derek G. Murray published <a href=\"http:\/\/www.frankmcsherry.org\/assets\/COST.pdf\">&#8220;Scalability! But at what COST?&#8221;<\/a>. The COST of a given platform for a given problem is the hardware configuration required before the platform outperforms a competent <strong>single-threaded implementation<\/strong>.<\/p>\n<blockquote style=\"border-left: solid 4px #bbb; padding-left: 15px; color: #888;\"><p>\nThe cluster computing environment is different from the environment of a laptop. The former often values high capacity and throughput over latency, with slower cores, storage, and memory. The laptop now embodies the personal computer, with lower capacity but faster cores, storage, and memory. While scalable systems are often a good match to cluster resources, it is important to consider alternative hardware for peak performance.\n<\/p><\/blockquote>\n<p>In other words, there is a large set of problems that are more efficiently solved on a single machine, as it avoids the costs in complexity, network communication and data checkpointing common to big data systems.<\/p>\n<p>What exactly constitutes small data depends on the problem, the data size (or its incoming rate) and the expected processing times. In this series of articles, we will explore solutions to different problems with <a href=\"https:\/\/github.com\/elixir-lang\/flow\">the <code>Flow<\/code> library<\/a>. Flow leverages concurrency on single-machines and may be a suitable option for small workloads, saving teams the need to resort to fully fledged big data solutions.<\/p>\n<h2>GenStage and Flow<\/h2>\n<p>Last year <a href=\"http:\/\/elixir-lang.org\/blog\/2016\/07\/14\/announcing-genstage\/\">we have introduced GenStage<\/a>, an abstraction for exchanging data between Elixir processes. GenStage was designed with back-pressure in mind so Elixir developers are able to consume data from external systems, such as Apache Kafka, RabbitMQ, databases, files and so on without overloading the system processing the data.<\/p>\n<p>Stages may be producers and\/or consumers of data. A single producer stage may have multiple consumers, which will receive events according to a chosen strategy. This means developers can create arbitrarily stage pipelines as a way to leverage concurrency.<\/p>\n<p>However, if developers are the ones responsible for building those pipelines, they may end-up with suboptimal workflows. That&#8217;s why we developed a tool called <code>Flow<\/code>, built on top of <code>GenStage<\/code>. Flow allows developers to express their data computations using functional operations, such as <code>map<\/code>, <code>reduce<\/code>, <code>filter<\/code>, and friends. Flow also provides conveniences for data partioning and windowing. Once such parameters are specified, <code>Flow<\/code> takes care of building a network of connected stages where the data flows through. Here is the classic (and clich\u00e9) example of using Flow for counting words on a file:<\/p>\n<pre><code class=\"elixir\">File.stream!(\"path\/to\/file\")\n|&gt; Flow.from_enumerable()\n|&gt; Flow.flat_map(&amp;String.split\/1)\n|&gt; Flow.partition()\n|&gt; Flow.reduce(fn -&gt; %{} end, fn word, map -&gt;\nMap.update(map, word, 1, &amp; &amp;1 + 1)\nend)\n|&gt; Enum.into(%{})\n<\/code><\/pre>\n<p>Don&#8217;t worry about the details of the example above for now. We will revisit it in future posts.<\/p>\n<h2>Next steps<\/h2>\n<p>In the next article, we will talk about lazy computations and async streams, which provide some useful background before jumping into <code>Flow<\/code>. If you would like to get a head start, <a href=\"https:\/\/www.youtube.com\/watch?v=srtMWzyqdp8\">watch my keynote about GenStage &amp; Flow at ElixirConf<\/a> and <a href=\"https:\/\/hexdocs.pm\/flow\/\">read the excellent documentation of the Flow project<\/a>.<\/p>\n<p><a href=\"http:\/\/plataformatec.com.br\/elixir-radar?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=elixir-radar&amp;utm_content=elixir-radar-cta-blog-post-bottom\"><br \/>\n<img decoding=\"async\" style=\"border: 0;\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2015\/05\/elixir-radar-subscribe.png\" alt=\"Subscribe to Elixir Radar\"><br \/>\n<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>This is the first article in a series of articles about &#8220;small data&#8221; (in contrast to &#8220;big data&#8221;) in Elixir. We will start by defining what is &#8220;small data&#8221;, why it matters and then briefly describe the Flow tool and what to expect in the next articles of the series. How small is small? We &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2017\/03\/small-data-with-elixir\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[143,256],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/6185"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=6185"}],"version-history":[{"count":11,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/6185\/revisions"}],"predecessor-version":[{"id":6271,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/6185\/revisions\/6271"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=6185"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=6185"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=6185"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}