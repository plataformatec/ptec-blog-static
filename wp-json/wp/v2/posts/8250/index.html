{"id":8250,"date":"2019-01-04T11:46:17","date_gmt":"2019-01-04T13:46:17","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=8250"},"modified":"2019-01-04T18:19:01","modified_gmt":"2019-01-04T20:19:01","slug":"building-a-new-mysql-adapter-for-ecto-part-iv-ecto-integration","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2019\/01\/building-a-new-mysql-adapter-for-ecto-part-iv-ecto-integration\/","title":{"rendered":"Building a new MySQL adapter for Ecto Part IV: Ecto Integration"},"content":{"rendered":"<p>Welcome to the &#8220;Building a new MySQL adapter for Ecto&#8221; series:<\/p>\n<ul>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/11\/building-a-new-mysql-adapter-for-ecto-part-i-hello-world\/\" target=\"_blank\" rel=\"noopener\">Part I: Hello World<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-ii-encoding-decoding\/\" target=\"_blank\" rel=\"noopener\">Part II: Encoding\/Decoding<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/12\/building-a-new-mysql-adapter-for-ecto-part-iii-dbconnection-integration\/\" target=\"_blank\" rel=\"noopener\">Part III: DBConnection Integration<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2019\/01\/building-a-new-mysql-adapter-for-ecto-part-iv-ecto-integration\/\" target=\"_blank\" rel=\"noopener\">Part IV: Ecto Integration<\/a> (you&#8217;re here!)<\/li>\n<\/ul>\n<p>After <a href=\"https:\/\/github.com\/elixir-ecto\/db_connection\" target=\"_blank\" rel=\"noopener\">DBConnection<\/a> integration we have a driver that should be usable on its own. The next step is to integrate it with Ecto so that we can:<\/p>\n<ul>\n<li>leverage Ecto (doh!) meaning, among other things, using <a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Changeset.html\" target=\"_blank\" rel=\"noopener\">changesets<\/a> to cast and validate data before inserting it into the DB, composing <a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Query.html\" target=\"_blank\" rel=\"noopener\">queries<\/a> instead of concatenating SQL strings, defining <a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Schema.html\" target=\"_blank\" rel=\"noopener\">schemas<\/a> that map DB data into Elixir structs, being able to run Mix tasks like <a href=\"https:\/\/hexdocs.pm\/ecto\/Mix.Tasks.Ecto.Create.html\" target=\"_blank\" rel=\"noopener\"><code>mix ecto.create<\/code><\/a> and <a href=\"https:\/\/hexdocs.pm\/ecto_sql\/Mix.Tasks.Ecto.Migrate.html\" target=\"_blank\" rel=\"noopener\"><code>mix ecto.migrate<\/code><\/a>, and finally using <a href=\"https:\/\/hexdocs.pm\/ecto_sql\/Ecto.Adapters.SQL.Sandbox.html\" target=\"_blank\" rel=\"noopener\">Ecto SQL Sandbox<\/a> to manage clean slate between tests<\/li>\n<li>tap into greater Ecto ecosystem: integration with the Phoenix Web framework, various pagination libraries, custom types, admin builders etc<\/li>\n<\/ul>\n<h2>Ecto Adapter<\/h2>\n<p>If you ever worked with Ecto, you&#8217;ve seen code like:<\/p>\n<pre><code class=\"elixir\">defmodule MyApp.Repo do\n  use Ecto.Repo,\n    adapter: Ecto.Adapters.MySQL,\n    otp_app: :my_app\nend\n<\/code><\/pre>\n<p>The <code>adapter<\/code> is a module that implements Ecto Adapter specifications:<\/p>\n<ul>\n<li><a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Adapter.html\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapter<\/code><\/a> &#8211; minimal API required from adapters<\/li>\n<li><a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Adapter.Queryable.html\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapter.Queryable<\/code><\/a> &#8211; plan, prepare, and execute queries leveraging query cache<\/li>\n<li><a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Adapter.Schema.html\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapter.Schema<\/code><\/a> &#8211; insert, update, and delete structs as well as autogenerate IDs<\/li>\n<li><a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Adapter.Storage.html\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapter.Storage<\/code><\/a> &#8211; storage API used by e.g. <code>mix ecto.create<\/code> and <code>mix ecto.drop<\/code><\/li>\n<li><a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Adapter.Transaction.html\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapter.Transaction<\/code><\/a> &#8211; transactions API<\/li>\n<\/ul>\n<p>Adapters are required to implement at least <code>Ecto.Adapter<\/code> behaviour. The remaining behaviours are optional as some data stores don&#8217;t support transactions or creating\/dropping the storage (e.g. some cloud services).<\/p>\n<p>There&#8217;s also a separate <a href=\"https:\/\/github.com\/elixir-ecto\/ecto_sql\" target=\"_blank\" rel=\"noopener\">Ecto SQL<\/a> project which ships with its own set of adapter specifications on top of the ones from Ecto. Conveniently, it also includes a <a href=\"https:\/\/hexdocs.pm\/ecto_sql\/Ecto.Adapters.SQL.html\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapters.SQL<\/code><\/a> module that we can <em>use<\/em>, which implements most of the callbacks and lets us worry mostly about generating appropriate SQL.<\/p>\n<h2>Ecto SQL Adapter<\/h2>\n<p>Let&#8217;s try using the <code>Ecto.Adapters.SQL<\/code> module:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.EctoAdapter do\n  use Ecto.Adapters.SQL,\n    driver: :myxql,\n    migration_lock: \"FOR UPDATE\"\nend\n<\/code><\/pre>\n<p>When we compile it, we&#8217;ll get a bunch of warnings as we haven&#8217;t implemented any of the callbacks yet.<\/p>\n<pre><code>warning: function supports_ddl_transaction?\/0 required by behaviour Ecto.Adapter.Migration is not implemented (in module MyXQL.EctoAdapter)\n  lib\/a.ex:1\n\nwarning: function MyXQL.EctoAdapter.Connection.all\/1 is undefined (module MyXQL.EctoAdapter.Connection is not available)\n  lib\/a.ex:2\n\nwarning: function MyXQL.EctoAdapter.Connection.delete\/4 is undefined (module MyXQL.EctoAdapter.Connection is not available)\n  lib\/a.ex:2\n\n(...)\n<\/code><\/pre>\n<p>Notably, we get a <code>module MyXQL.EctoAdapter.Connection is not available<\/code> warning. The SQL adapter specification requires us to implement a separate connection module (see <a href=\"https:\/\/hexdocs.pm\/ecto_sql\/Ecto.Adapters.SQL.Connection.html\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapters.SQL.Connection<\/code><\/a> behaviour) which will leverage, you guessed it, DBConnection. Let&#8217;s try that now and implement a couple of callbacks:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.EctoAdapter.Connection do\n  @moduledoc false\n  @behaviour Ecto.Adapters.SQL.Connection\n\n  @impl true\n  def child_spec(opts) do\n    MyXQL.child_spec(opts)\n  end\n\n  @impl true\n  def prepare_execute(conn, name, sql, params, opts) do\n    MyXQL.prepare_execute(conn, name, sql, params, opts)\n  end\nend\n<\/code><\/pre>\n<p>Since we&#8217;ve leveraged DBConnection in the MyXQL driver, these functions are simply delegating to driver. Let&#8217;s implement something a little bit more interesting.<\/p>\n<p>Did you ever wonder how <a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Changeset.html#unique_constraint\/3\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Changeset.unique_constraint\/3<\/code><\/a> is able to transform a SQL constraint violation failure into a changeset error? Turns out that <code>unique_constriant\/3<\/code> keeps a mapping between unique key constraint name and fields these errors should be reported on. The code that makes it work is executed in the repo and the adapter when the structs are persisted. In particular, the adapter should implement the <a href=\"https:\/\/hexdocs.pm\/ecto_sql\/Ecto.Adapters.SQL.Connection.html#c:to_constraints\/1\" target=\"_blank\" rel=\"noopener\"><code>Ecto.Adapters.SQL.Connection.to_constraints\/1<\/code><\/a> callback. Let&#8217;s take a look:<\/p>\n<pre><code>iex&gt; b Ecto.Adapters.SQL.Connection.to_constraints\n@callback to_constraints(exception :: Exception.t()) :: Keyword.t()\n\nReceives the exception returned by c:query\/4.\n\nThe constraints are in the keyword list and must return the constraint type,\nlike :unique, and the constraint name as a string, for example:\n\n    [unique: \"posts_title_index\"]\n\nMust return an empty list if the error does not come from any constraint.\n<\/code><\/pre>\n<p>Let&#8217;s see how the constraint violation error looks exactly:<\/p>\n<pre><code>$ mysql -u root myxql_test\nmysql&gt; CREATE TABLE uniques (x INTEGER UNIQUE);\nQuery OK, 0 rows affected (0.17 sec)\n\nmysql&gt; INSERT INTO uniques VALUES (1);\nQuery OK, 1 row affected (0.08 sec)\n\nmysql&gt; INSERT INTO uniques VALUES (1);\nERROR 1062 (23000): Duplicate entry '1' for key 'x'\n<\/code><\/pre>\n<p>MySQL responds with error code <code>1062<\/code>. We can further look into the error by using <code>perror<\/code><br \/>\ncommand-line utility that ships with MySQL installation:<\/p>\n<pre><code>% perror 1062\nMySQL error code 1062 (ER_DUP_ENTRY): Duplicate entry '%-.192s' for key %d\n<\/code><\/pre>\n<p>Ok, let&#8217;s finally implement the callback:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.EctoAdapter.Connection do\n  # ...\n\n  @impl true\n  def to_constraints(%MyXQL.Error{mysql: %{code: 1062}, message: message}) do\n    case :binary.split(message, \" for key \") do\n      [_, quoted] -&gt; [unique: strip_quotes(quoted)]\n      _ -&gt; []\n    end\n  end\nend\n<\/code><\/pre>\n<p>Let&#8217;s break this down. We expect that the driver raises an exception struct on constraint violation, we then match on the particular error code, extract the field name from the error message, and return that as keywords list.<\/p>\n<p>(To make this more understandable, in the <a href=\"https:\/\/github.com\/elixir-ecto\/myxql\" target=\"_blank\" rel=\"noopener\">MyXQL<\/a> project we&#8217;ve added error code\/name mapping so we pattern match like this instead: <code>mysql: %{code: :ER_DUP_ENTRY}<\/code>.)<\/p>\n<p>To get a feeling of what other subtle changes we may have between data stores, let&#8217;s implement one more callback, back in the <code>MyXQL.EctoAdapter<\/code> module.<\/p>\n<p>While MySQL has a <code>BOOLEAN<\/code> type, turns out it&#8217;s simply an alias to <code>TINYINT<\/code> and its possible values are <code>1<\/code> and <code>0<\/code>. These sort of discrepancies are handled by the <a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Adapter.html#c:dumpers\/2\" target=\"_blank\" rel=\"noopener\"><code>dumpers\/2<\/code><\/a> and <a href=\"https:\/\/hexdocs.pm\/ecto\/Ecto.Adapter.html#c:loaders\/2\" target=\"_blank\" rel=\"noopener\"><code>loaders\/2<\/code><\/a> callbacks, let&#8217;s implement the latter:<\/p>\n<pre><code class=\"elixir\">defmodule MyXQL.EctoAdapter do\n  # ...\n\n  @impl true\n  def loaders(:boolean, type), do: [&amp;bool_decode\/1, type]\n  # ...\n  def loaders(_, type),        do: [type]\n\n  defp bool_decode(&lt;&lt;0&gt;&gt;), do: {:ok, false}\n  defp bool_decode(&lt;&lt;1&gt;&gt;), do: {:ok, true}\n  defp bool_decode(0), do: {:ok, false}\n  defp bool_decode(1), do: {:ok, true}\n  defp bool_decode(other), do: {:ok, other}\nend\n<\/code><\/pre>\n<h2>Integration Tests<\/h2>\n<p>As you can see there might be quite a bit of discrepancies between adapters and data stores. For this reason, besides providing adapter specifications, Ecto ships with integration tests that can be re-used by adapter libraries.<\/p>\n<p>Here&#8217;s a set of basic integration test cases and support files in Ecto, see: <a href=\"https:\/\/github.com\/elixir-ecto\/ecto\/blob\/v3.0.6\/integration_test\" target=\"_blank\" rel=\"noopener\"><code>.\/integration_test\/<\/code><\/a> directory.<\/p>\n<p>And here&#8217;s an example how a separate package might leverage these. Turns out that <code>ecto_sql<\/code> uses <code>ecto<\/code> integration tests:<\/p>\n<pre><code class=\"elixir\"># ecto_sql\/integration_test\/mysql\/all_test.exs\necto = Mix.Project.deps_paths[:ecto]\nCode.require_file \"#{ecto}\/integration_test\/cases\/assoc.exs\", __DIR__\nCode.require_file \"#{ecto}\/integration_test\/cases\/interval.exs\", __DIR__\n# ...\n<\/code><\/pre>\n<p>and has <a href=\"https:\/\/github.com\/elixir-ecto\/ecto_sql\/tree\/v3.0.4\/integration_test\/sql\" target=\"_blank\" rel=\"noopener\">a few of its own<\/a>.<\/p>\n<p>When implementing a 3rd-party SQL adapter for Ecto we already have a lot of integration tests to run against!<\/p>\n<h2>Conclusion<\/h2>\n<p>In this article we have briefly looked at integrating our driver with Ecto and Ecto SQL.<\/p>\n<p>Ecto helps with the integration by providing:<\/p>\n<ul>\n<li>adapter specifications<\/li>\n<li>a <code>Ecto.Adapters.SQL<\/code> module that we can <em>use<\/em> to build adapters for relational databases even faster<\/li>\n<li>integration tests<\/li>\n<\/ul>\n<p>We&#8217;re also concluding our adapter series. Some of the overarching themes were:<\/p>\n<ul>\n<li>separation of concerns: we&#8217;ve built our protocol packet encoding\/decoding layer stateless and separate from a process model which in turn made DBConnection integration more straight-forward and resulting codebase easier to understand. Ecto also exhibits a separation of concerns: not only we have separate changeset, repo, adapter etc, within adapter we have different aspects of talking to data stores like storage, transactions, connection etc.<\/li>\n<li>behaviours, behaviours, behaviours! Not only behaviours provide a thought-through way of organizing the code as contracts, as long as we adhere to those contracts, features like e.g. DBConnection resilience and access to Ecto tooling and greater ecosystem becomes avaialble.<\/li>\n<\/ul>\n<p>As this article is being published, we&#8217;re getting closer to shipping MyXQL&#8217;s first release as well as making it the default MySQL adapter in upcoming Ecto v3.1. You can see the progress on <a href=\"https:\/\/github.com\/elixir-ecto\/ecto_sql\/pull\/66\" target=\"_blank\" rel=\"noopener\">elixir-ecto\/ecto_sql#66<\/a>.<\/p>\n<p>Happy coding!<\/p>\n<p><a href=\"https:\/\/pages.plataformatec.com.br\/elixir-development-subscription\" target=\"_blank\" rel=\"noopener\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-8124 size-full\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1.png\" alt=\"\" width=\"1024\" height=\"213\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1.png 1024w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1-300x62.png 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2016\/05\/admin-ajax-1-768x160.png 768w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Welcome to the &#8220;Building a new MySQL adapter for Ecto&#8221; series: Part I: Hello World Part II: Encoding\/Decoding Part III: DBConnection Integration Part IV: Ecto Integration (you&#8217;re here!) After DBConnection integration we have a driver that should be usable on its own. The next step is to integrate it with Ecto so that we can: &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2019\/01\/building-a-new-mysql-adapter-for-ecto-part-iv-ecto-integration\/\">\u00bb<\/a><\/p>\n","protected":false},"author":70,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8250"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/70"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=8250"}],"version-history":[{"count":31,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8250\/revisions"}],"predecessor-version":[{"id":8338,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/8250\/revisions\/8338"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=8250"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=8250"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=8250"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}