{"id":4228,"date":"2014-09-24T09:00:01","date_gmt":"2014-09-24T12:00:01","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=4228"},"modified":"2014-09-23T18:28:02","modified_gmt":"2014-09-23T21:28:02","slug":"writing-assertive-code-with-elixir","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2014\/09\/writing-assertive-code-with-elixir\/","title":{"rendered":"Writing assertive code with Elixir"},"content":{"rendered":"<p>Functional languages are typically great languages for writing assertive code and Elixir is no exception. In this blog post, I would like to discuss some anti-patterns I have seen in Elixir code and how to rewrite them in a way to make the best of Elixir.<\/p>\n<h3>Pattern matching<\/h3>\n<p>Imagine you have a string with format <code>foo=bar&amp;token=value&amp;bar=baz<\/code> where you want to extract the value for the key <code>token<\/code> which may appear anywhere or not at all in the string.<\/p>\n<p>Here is one solution a developer not very-acquainted with pattern matching would try:<\/p>\n<pre lang=\"ruby\">\ndef get_token(string) do\n  parts = String.split(string, \"&\")\n  Enum.find_value(parts, fn pair ->\n    key_value = String.split(pair, \"=\")\n    Enum.at(key_value, 0) == \"token\" && Enum.at(key_value, 1)\n  end)\nend\n<\/pre>\n<p>At first the code seems to work fine but once we go deeper we can see it makes many assumptions we have not really planned for!<\/p>\n<p>For example, what happens if someone passes <code>\"foo=bar&amp;token=some=value&amp;bar=baz\"<\/code> as argument? The code will work and will return the string <code>\"some\"<\/code>. But is that what we really want? Maybe we wanted <code>\"some=value\"<\/code> instead? Or maybe we wanted to reject it all together?<\/p>\n<p>There are other examples where the code above would work by accident, possibly adding complexity to the codebase as other users may start to rely on such behaviour.<\/p>\n<p>The most idiomatic way of writing the code above in Elixir is by using pattern matching:<\/p>\n<pre lang=\"ruby\">\ndef get_token(string) do\n  parts = String.split(string, \"&\")\n  Enum.find_value(parts, fn pair ->\n    [key, value] = String.split(pair, \"=\")\n    key == \"token\" && value\n  end)\nend\n<\/pre>\n<p>With pattern matching, we are asserting that <code>String.split\/2<\/code> is going to return a list with two elements. If someone passes <code>\"foo=bar&amp;token&amp;bar=baz\"<\/code>, it will crash as the list will have only one element. If someone passes <code>\"token=some=value\"<\/code>, it will crash too as it contains 3 items.<\/p>\n<p>Our new code does not contain any of the accidental complexity of the previous one and it will also be faster. Any input that does not match the given pattern will lead to a crash, giving us the perfect opportunity to discuss and decide how to handle those corner cases.<\/p>\n<h3>Polymorphism is opt-in<\/h3>\n<p>Elixir provides protocols as a mechanism for polymorphism. A protocol allows developers to express they are willing to work with any data type, as long as it implements the protocols X, Y and Z.<\/p>\n<p>I have previously <a href=\"http:\/\/blog.plataformatec.com.br\/2014\/06\/comparing-protocols-and-extensions-in-swift-and-elixir\/\">compared Elixir protocols to alternatives in languages like Swift and Ruby<\/a>. One nice aspect of Elixir protocols is that they are explicit, you need to explicitly outline and define a protocol for data structures to implement.<\/p>\n<p>For example, one protocol in Elixir is the <code>String.Chars<\/code> protocol, which converts any data type to a string, if that data type can be converted to a human-readable string. The <code>to_string<\/code> function uses such protocol for conversions:<\/p>\n<pre lang=\"ruby\">\niex> to_string(\"hello\")\n\"hello\"\niex> to_string(1)\n\"1\"\niex> to_string URI.parse(\"http:\/\/blog.plataformatec.com.br\")\n\"http:\/\/blog.plataformatec.com.br\"\niex> to_string %{hello: :world}\n** (Protocol.UndefinedError) protocol String.Chars not implemented for %{hello: :world}\n<\/pre>\n<p>Imagine you have a function that converts underscores to dashes in a string:<\/p>\n<pre lang=\"ruby\">\ndef dasherize(string), do: String.replace(string, \"_\", \"-\")\n<\/pre>\n<p>Now imagine that at some point you decide to call <code>to_string\/1<\/code> before calling <code>replace\/3<\/code>:<\/p>\n<pre lang=\"ruby\">\ndef dasherize(data), do: String.replace(to_string(data), \"_\", \"-\")\n<\/pre>\n<p>Albeit small, this is a drastic change to our code. Our dasherize function went from supporting only strings as argument to support a large number of data types. In other words, our code became less assertive and more generic.<\/p>\n<p>That said, before adding protocols to our code, we should ask if we really intend to open our function to all types. Maybe we want dasherize to support only atoms and strings? If so, we should rather write:<\/p>\n<pre lang=\"ruby\">\ndef dasherize(data) when is_atom(data), do: dasherize(Atom.to_string(data))\ndef dasherize(data), do: String.replace(data, \"_\", \"-\")\n<\/pre>\n<p>However, if we are confident we want a protocol, then we should indeed use the protocol and write a test case that guarantees our function works for at least a couple types that implement such protocol. Such tests are extremely important to guarantee we don&#8217;t make a different assumption somewhere in the same function.<\/p>\n<p>Note this trade-off does not only happen in protocols, but in any polymorphic API, like the <code>Dict<\/code> module. In practice, one should rather use specific dict implementations, like the <code>Keyword<\/code> and <code>Map<\/code> modules, and rely on the <code>Dict<\/code> module only when polymorphism is desired.<\/p>\n<h3>Map\/struct access<\/h3>\n<p>Elixir provides maps, known as dictionaries in other languages, as a key-value data structure. Maps are created as follows:<\/p>\n<pre lang=\"ruby\">\nmap = %{name: \"john\", age: 42}\n<\/pre>\n<p>Maps allow two types of access. A strict access, that requires the field name to exist in the map, and a dynamic access, that returns nil if the field does not exist in the map:<\/p>\n<pre lang=\"ruby\">\n# Strict access\niex> map.name\n\"john\"\niex> map.address\n** (KeyError) key :address not found in: %{age: 42, name: \"john\"}\n\n# Dynamic access\niex> map[:name]\n\"john\"\niex> map[:address]\nnil\n<\/pre>\n<p>Both syntaxes have their use cases but we should prefer the strict syntax when possible as it helps us find bugs early on. The same applies to structs, which are named maps:<\/p>\n<pre lang=\"ruby\">\ndefmodule User do\n  defstruct [:first_name, :last_name, :age]\n\n  def name(user) do\n    \"#{user.first_name} #{user.last_name}\"\n  end\nend\n\nUser.name %User{first_name: \"John\", last_name: \"Doe\"}\n#=> \"John Doe\"\n<\/pre>\n<p>In the example above, we have defined a User struct and a <code>name\/1<\/code> function that receives the struct and returns its name. Since we are using <code>user.first_name<\/code>, if we accidentally pass a struct that does not contain such a field, it will crash immediately, with a nice error message!<\/p>\n<p>In fact, the strict aspect of the <code>user.first_name<\/code> syntax is one of the reasons why structs do not support the dynamic syntax out of the box:<\/p>\n<pre lang=\"ruby\">\nuser = %User{first_name: \"John\", last_name: \"Doe\"}\nuser[:first_name]\n** (Protocol.UndefinedError) protocol Access not implemented for %User{...}\n<\/pre>\n<p>In case you want to use the dynamic syntax, you need to derive the Access protocol for the User struct:<\/p>\n<pre lang=\"ruby\">\ndefmodule User do\n  @derive [Access]\n  defstruct [:first_name, :last_name, :age]\n\n  def name(user) do\n    \"#{user.first_name} #{user.last_name}\"\n  end\nend\n<\/pre>\n<p>However, only derive Access when you truly need to do so, as it is much better to push yourself to rely more on the strict syntax. I would even say relying on Access for structured data is an anti-pattern itself!<\/p>\n<h3>Wrapping up<\/h3>\n<p>The most interesting aspect of all examples above is that writing in the assertive style leads to faster, more concise and maintainable code. Even more, it allows us to focus on specific scenarios, postponing any complexity (incidental or accidental) to <em>only when we need them, if we need them<\/em>.<\/p>\n<p style=\"text-align: center;\">\n<p><span id=\"hs-cta-wrapper-2aeae558-5b72-4df3-bf32-e1119f34d85e\" class=\"hs-cta-wrapper\"><span id=\"hs-cta-2aeae558-5b72-4df3-bf32-e1119f34d85e\" class=\"hs-cta-node hs-cta-2aeae558-5b72-4df3-bf32-e1119f34d85e\"> <a href=\"http:\/\/cta-redirect.hubspot.com\/cta\/redirect\/378213\/2aeae558-5b72-4df3-bf32-e1119f34d85e\"><img decoding=\"async\" id=\"hs-cta-img-2aeae558-5b72-4df3-bf32-e1119f34d85e\" class=\"hs-cta-img aligncenter\" style=\"border-width: 0px;\" src=\"https:\/\/no-cache.hubspot.com\/cta\/default\/378213\/2aeae558-5b72-4df3-bf32-e1119f34d85e.png\" alt=\"\" \/><\/a><\/span><\/span><br \/>\n<!-- end HubSpot Call-to-Action Code --><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Functional languages are typically great languages for writing assertive code and Elixir is no exception. In this blog post, I would like to discuss some anti-patterns I have seen in Elixir code and how to rewrite them in a way to make the best of Elixir. Pattern matching Imagine you have a string with format &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2014\/09\/writing-assertive-code-with-elixir\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[224,143,225,215],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4228"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=4228"}],"version-history":[{"count":4,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4228\/revisions"}],"predecessor-version":[{"id":4234,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/4228\/revisions\/4234"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=4228"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=4228"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=4228"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}