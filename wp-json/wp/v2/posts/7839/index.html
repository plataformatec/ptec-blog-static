{"id":7839,"date":"2018-10-11T16:35:14","date_gmt":"2018-10-11T19:35:14","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=7839"},"modified":"2018-10-22T19:23:57","modified_gmt":"2018-10-22T21:23:57","slug":"a-sneak-peek-at-ecto-3-0-query-improvements-part-2","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-2\/","title":{"rendered":"A sneak peek at Ecto 3.0: query improvements (part 2)"},"content":{"rendered":"<p>Welcome to the &#8220;A sneak peek at Ecto 3.0&#8221; series:<\/p>\n<ol>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-breaking-changes\/\">Breaking changes<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-1\/\">Query improvements part 1<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-2\/\">Query improvements part 2<\/a> (you are here!)<\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-performance-migrations-and-more\/\">Performance, migrations and more<\/a><\/li>\n<\/ol>\n<p>This time we are back to cover other improvements coming to <code>Ecto.Query<\/code> in Ecto 3.0.<\/p>\n<h2>UNION, EXCEPT and INTERSECT<\/h2>\n<p>With Ecto 3.0, it is now possible to add unions\/excepts\/intersects to queries. For example, to get all cities for both customers and suppliers, you can now do:<\/p>\n<pre><code>customer_city_query = Customer |&gt; select([c], c.city)\nSupplier |&gt; select([s], s.city) |&gt; union(customer_city_query)\n<\/code><\/pre>\n<p>Keep in mind that <code>union<\/code> will attempt to remove any duplicates and that can be expensive. In many cases, especially when you know duplicates cannot happen or you don&#8217;t care about returning duplicates, you should use <code>union_all<\/code> instead.<\/p>\n<p>Adding support for unions has been a frequently requested feature in Ecto for quite some time. However, all previous approaches to implement this feature were misguided because all of them assumed that we would need to introduce a new data-type that holds the union of two queries.<\/p>\n<p>In other words, in the approaches we had in mind, <code>union(query1, query2)<\/code> would return a new construct similar to <code>Ecto.UnionQuery{left: query1, right: query2}<\/code>. We were skeptical about this as it could push accidental complexity to users of Ecto that would now have to handle different types of queries.<\/p>\n<p>All of this changed when <a href=\"https:\/\/github.com\/feymartynov\">Timofey Martynov<\/a> sent a <a href=\"https:\/\/github.com\/elixir-ecto\/ecto\/pull\/2678\">pull request<\/a> that adds UNION \/ UNION ALL support by simply treating the UNION \/ UNION ALL as a field in the <code>Ecto.Query<\/code>, in the same way we store <code>ORDER BY<\/code>s, <code>LIMIT<\/code>s, <code>WHERE<\/code>s and so on. While this direction seemed misguided at first, once we re-read the SQL specification, it became clear that this is the correct way to model UNION \/ UNION ALL.<\/p>\n<p>Let&#8217;s see an example. Consider this SQL query:<\/p>\n<pre><code>SELECT city FROM suppliers UNION SELECT city FROM customers LIMIT 10\n<\/code><\/pre>\n<p>Which of the queries below is equivalent to the one above?<\/p>\n<p>a) <code>(SELECT city FROM suppliers) UNION (SELECT city FROM customers LIMIT 10)<\/code><br \/>\nb) <code>SELECT city FROM suppliers UNION (SELECT city FROM customers) LIMIT 10<\/code><\/p>\n<p>After an informal poll, many chose <code>a)<\/code> because they expected UNION to work like some top-level, low-precedence operator, but the correct answer is <code>b)<\/code>. The <a href=\"https:\/\/www.postgresql.org\/docs\/9.5\/static\/sql-select.html#SQL-UNION\">PostgreSQL documentation<\/a> also discusses this:<\/p>\n<blockquote><p>\n  The UNION clause has this general form:<\/p>\n<p>  select_statement UNION [ ALL | DISTINCT ] select_statement<\/p>\n<p>  select_statement is any SELECT statement without an ORDER BY, LIMIT, FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, or FOR KEY SHARE clause. (ORDER BY and LIMIT can be attached to a subexpression if it is enclosed in parentheses. Without parentheses, these clauses will be taken to apply to the result of the UNION, not to its right-hand input expression.)\n<\/p><\/blockquote>\n<p>In other words, UNION\/INTERSECT\/EXCEPTs should be modelled as <code>WHERE<\/code> as they are both considered clauses of a given query and not a top-level operation. This is precisely how it has been implemented in Ecto. The more you know!<\/p>\n<h2>WINDOW and OVER support<\/h2>\n<p>Ecto 3.0 finally gets support for windows. I mean WINDOWs, not Windows. We have always supported Windows. Ok. This is confusing. Let&#8217;s try again.<\/p>\n<p>Ecto 3.0 finally gets support for <a href=\"https:\/\/www.postgresql.org\/docs\/9.5\/static\/sql-select.html#SQL-WINDOW\">WINDOW clauses<\/a>, the OVER operator, as well as many WINDOW functions. For example, to compare each employee&#8217;s salary with the average salary in their department:<\/p>\n<pre><code>from e in Employee,\nselect: {e.depname, e.empno, e.salary, avg(e.salary) |&gt; over(:department)},\nwindows: [department: [partition_by: e.depname]]\n<\/code><\/pre>\n<p>The <code>over\/2<\/code> operator expects either a window name or a window expression as second argument. The query below would return the same results:<\/p>\n<pre><code>from e in Employee,\nselect: {e.depname, e.empno, e.salary, avg(e.salary) |&gt; over(partition_by: e.depname)}\n<\/code><\/pre>\n<p>The first argument should have an aggregator or <a href=\"https:\/\/www.postgresql.org\/docs\/9.5\/static\/functions-window.html\">any of the WINDOW functions<\/a>. By default we support all of the built-in functions found in PostgreSQL and MySQL. They can be found <a href=\"https:\/\/github.com\/elixir-ecto\/ecto\/blob\/master\/lib\/ecto\/query\/window_api.ex\">in the <code>Ecto.Query.WindowAPI<\/code> module<\/a> (we are linking to the source as the docs haven&#8217;t been released yet).<\/p>\n<p>This work was contributed by <a href=\"https:\/\/github.com\/Anber\">Anton<\/a>. You can read the original discussion in the <a href=\"https:\/\/github.com\/elixir-ecto\/ecto\/pull\/2618\">issues tracker<\/a>.<\/p>\n<h2>Other changes<\/h2>\n<p>There are many other exciting changes in <code>Ecto.Query<\/code>. For example, it now has built-in support for <code>coalesce<\/code>, such as <code>select: coalesce(p.title, p.old_title)<\/code>, or even better with the pipe operator: <code>p.field1 |&gt; coalesce(p.field2) |&gt; coalesce(p.field3)<\/code>.<\/p>\n<p>We also support FILTER expressions, allowing you filter the value of aggregators: <code>select: filter(count(), p.public == true)<\/code><\/p>\n<p>Finally, <code>order_by<\/code> now supports <code>:asc_nulls_last<\/code>, <code>:asc_nulls_first<\/code>, <code>:desc_nulls_last<\/code>, and <code>:desc_nulls_first<\/code>, allowing you to configure exactly when NULLs are returned when ordering: <code>order_by: [desc_nulls_first: p.title]<\/code>. If you are using <code>:desc<\/code> and <code>:asc<\/code>, then the behaviour is the same as in Ecto 2.0, which is database dependent (and surprise, surprise! they won&#8217;t agree with each other).<\/p>\n<p>This finishes the third article on our series about Ecto 3.0. There are many other things we would like to share with you, such as performance improvements, safer migrations and more. We are not quite sure how many articles we still have to write but we are certainly not done. See you soon!<\/p>\n<p><a href=\"https:\/\/pages.plataformatec.com.br\/elixir-development-subscription\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-large wp-image-7816\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png\" alt=\"banner-elixir development subscription\" width=\"1024\" height=\"213\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png 1024w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-300x63.png 300w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-768x160.png 768w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1.png 1200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Welcome to the &#8220;A sneak peek at Ecto 3.0&#8221; series: Breaking changes Query improvements part 1 Query improvements part 2 (you are here!) Performance, migrations and more This time we are back to cover other improvements coming to Ecto.Query in Ecto 3.0. UNION, EXCEPT and INTERSECT With Ecto 3.0, it is now possible to add &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-2\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7839"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=7839"}],"version-history":[{"count":15,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7839\/revisions"}],"predecessor-version":[{"id":7880,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7839\/revisions\/7880"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=7839"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=7839"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=7839"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}