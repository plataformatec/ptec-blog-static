{"id":7870,"date":"2018-10-22T15:41:40","date_gmt":"2018-10-22T17:41:40","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=7870"},"modified":"2018-10-22T17:14:06","modified_gmt":"2018-10-22T19:14:06","slug":"a-sneak-peek-at-ecto-3-0-performance-migrations-and-more","status":"publish","type":"post","link":"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-performance-migrations-and-more\/","title":{"rendered":"A sneak peek at Ecto 3.0: performance, migrations and more"},"content":{"rendered":"<p>Welcome to the &#8220;A sneak peek at Ecto 3.0&#8221; series:<\/p>\n<ol>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-breaking-changes\/\">Breaking changes<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-1\/\">Query improvements part 1<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-query-improvements-part-2\/\">Query improvements part 2<\/a><\/li>\n<li><a href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-performance-migrations-and-more\/\">Performance, migrations and more<\/a> (you are here!)<\/li>\n<\/ol>\n<p>We are back for one last round! This time we are going to cover improvements on three main areas: performance, upserts and migrations. If you would like to give Ecto a try right now, note <a href=\"https:\/\/elixirforum.com\/t\/ecto-3-0-rc-is-out-and-stable-api\/17306\">Ecto v3.0.0-rc.0 has been released<\/a> and we are looking forward to your feedback.<\/p>\n<h2>Better memory usage<\/h2>\n<p>One of the most notable performance improvements in Ecto 3.0 is that schemas loaded from an Ecto repository now uses less memory.<\/p>\n<p>A big part of the memory improvements seen in Ecto 3.0 comes from better management of schema metadata. Every instance you have of an <code>Ecto.Schema<\/code>, such as a <code>%User{}<\/code>, has a metadata field with life-cycle information about that entry, such as the database prefix or its state (was it just built or was it loaded from the database?). This metadata field takes exactly 16 words:<\/p>\n<pre><code>iex&gt; :erts_debug.size %Ecto.Schema.Metadata{}\n16\n<\/code><\/pre>\n<p>16 words for a 64-bits machine is equivalent to 128 bytes. This means that, if you were using Ecto 2.0 and you loaded 1000 entries, 128 kbytes of memory would be used only for storing this metadata. The good news is that all of those 1000 entries could use the exact same metadata! <a href=\"https:\/\/github.com\/elixir-ecto\/ecto\/commit\/c34046be0317903785d5f7f3ece35ac6e0f64008\">That&#8217;s what we did in this commit<\/a>. This means that, if you load 1000 or 1000000 entries, the cost is always the same, only 128 bytes!<\/p>\n<p>After we announced Ecto 3.0-rc, we started to hear some teams already upgraded to Ecto 3.0-rc. Some of those repos are quite big and it took them less than a day to upgrade, which is exactly how upgrading to major software versions should be.<\/p>\n<p>Ben Wilson, Principal Engineer at CargoSense, upgraded one of their apps to Ecto 3.0-rc and pushed it to production. Here is the result:<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-7872\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/memory.png\" alt=\"\" width=\"1226\" height=\"412\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/memory.png 1226w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/memory-300x101.png 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/memory-768x258.png 768w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/memory-1024x344.png 1024w\" sizes=\"(max-width: 1226px) 100vw, 1226px\" \/><\/p>\n<p>You can see the drop in memory usage from Ecto 2 to Ecto 3 at the moment of the deployment. This particular app loads a bunch of data during boot and we can clearly see the impact those improvements have in the memory usage. Once the system stabilized, the average memory use is 15% less altogether.<\/p>\n<p>But that&#8217;s not all!<\/p>\n<p>We also changed Ecto 3.0 to make use of the Erlang VM literal pool, which allows us to share the metadata across queries. For example, if you have two queries, each returning 1000 posts, all 2000 posts will point to the same metadata. These improvements alongside <a href=\"https:\/\/github.com\/elixir-ecto\/ecto\/commit\/415ba3df0b3810e5b3393d32a208745e28bd5c20\">other changes to reduce struct allocation<\/a> should reduce Ecto&#8217;s memory usage as a whole.<\/p>\n<h2>Statement cache for INSERT\/UPDATE\/DELETE<\/h2>\n<p>Another notable performance improvement in Ecto 3.0 comes from the fact Ecto now automatically caches statements emitted by <code>Ecto.Repo.insert\/update\/delete<\/code>.<\/p>\n<p>Consider this code:<\/p>\n<pre><code>for i &lt;- 1..1000 do\n  Repo.insert!(%Post{visits: i})\nend\n<\/code><\/pre>\n<p>where Post is a schema with 13 fields. When running this code on my machine against a Postgres database with a pool of 10 connections, it takes 900ms to insert all 1000 posts. While Ecto has always cached select queries, once we also added the statement cache to <code>Ecto.Repo.insert\/update\/delete<\/code>, the total operation time is reduced 610ms!<\/p>\n<p>But that&#8217;s not all!<\/p>\n<p>Part of the issue here is that every time we call <code>Repo.insert!<\/code>, Ecto needs to get a new connection out of the connection pool, perform the insert, and give the connection back. For a pool with 10 connections, there is a chance the next connection we pick up is not &#8220;warm&#8221; and we may not hit the statement cache. While it is important to not hold connections for long, so we can best utilize the database resources, in this scenario we know we will perform many operations in a row.<\/p>\n<p>For this reason, Ecto 3.0 includes a <code>Repo.checkout<\/code> operation, which allows you to tell the Ecto repository you want to use the same connection, skipping the connection pool and always using a &#8220;warm&#8221; connection:<\/p>\n<pre><code>Repo.checkout(fn -&gt;\n  for i &lt;- 1..1000 do\n    Repo.insert!(%Post{visits: i})\n  end\nend)\n<\/code><\/pre>\n<p>With the change above, all of the inserts take 420ms on average.<\/p>\n<p>There is one final trick we could use. Since we are performing multiple inserts, we could simply replace <code>Repo.checkout<\/code> by <code>Repo.transaction<\/code>. The transaction also checks out a single connection but it also allows the database itself to be more efficient. With this final change, the total time falls down to 320ms. And if you really need to go faster, you can always use <code>Ecto.Repo.insert_all<\/code>. Hooray!<\/p>\n<h2>More options around upserts<\/h2>\n<p>Ecto 2 added <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/12\/many-to-many-and-upserts\/\">support for upserts<\/a>. Ecto 3 brings many improvements to the upsert API, such as the ability to tell Ecto to <code>:replace_all_except_primary_key<\/code> in case of conflicts or to replace only certain fields by passing <code>on_conflict: {:replace, [:foo, :bar, baz]}<\/code>. This new version of Ecto also allow custom expressions to be given as <code>:conflict_target<\/code> by passing <code>{:unsafe_fragment, \"be careful with what goes here\"}<\/code> as a value.<\/p>\n<p>There are many other improvements to the <code>Ecto.Repo<\/code> API, such as <code>Ecto.Repo.checkout<\/code>, introduced in the previous section, and the new <code>Ecto.Repo.exists?<\/code>.<\/p>\n<h2>Migrations<\/h2>\n<p>Another area in Ecto (or to be more precise, Ecto.SQL) that saw major improvements is migrations.<\/p>\n<p>The most important change was a contribution by Allen Madsen that locks the migration table, allowing multiple machines to run migrations at the same time. In previous Ecto versions, if you had multiple machines attempting to run migrations, they could race each other, leading to failures, but now it is guaranteed such can&#8217;t happen. The type of lock can be configured via the <code>:migration_lock<\/code> repository configuration and defaults to &#8220;FOR UPDATE&#8221; or disabled if set to <code>nil<\/code>.<\/p>\n<p>Another improvement is that Ecto is now capable of logging notices\/alerts\/warnings emitted by the database when running migrations. In previous Ecto versions, if you had a long index name, the database would truncate and emit an alert through the TCP connection, but this alert was never extracted and printed in the terminal. This is no longer the case in Ecto 3.0.<\/p>\n<p>Similarly, Ecto will now warn if you attempt to run a migration and there is a higher version number already migrated in the database. Imagine you have been working on a feature for a long period of time and you were finally able to merge it to master. Since you started working on this feature, other features and migrations were already shipped to production. This may create an issue on deployment: in case something goes wrong when deploying this new feature and you have to rollback the database, the latest migrations by timestamp does not match the migrations that have just been executed.<\/p>\n<p>By emitting warnings, we help developers and production teams alike to be aware of such pitfalls.<\/p>\n<h2>Summing up<\/h2>\n<p>We are very excited with the many improvements in Ecto 3.0. This short series of articles shares the most notable changes but there is much more. But perhaps the most important feature is that we have announced <a href=\"https:\/\/elixirforum.com\/t\/ecto-3-0-rc-is-out-and-stable-api\/17306\">Ecto to be stable API<\/a> and this is only possible due to the work that Plataformatec and the community has put into Ecto throughout the years. Enjoy!<\/p>\n<p><a href=\"https:\/\/pages.plataformatec.com.br\/elixir-development-subscription\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-large wp-image-7816\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png\" alt=\"banner-elixir development subscription\" width=\"1024\" height=\"213\" srcset=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-1024x213.png 1024w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-300x63.png 300w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1-768x160.png 768w, http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2018\/10\/Elixir_2-1.png 1200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Welcome to the &#8220;A sneak peek at Ecto 3.0&#8221; series: Breaking changes Query improvements part 1 Query improvements part 2 Performance, migrations and more (you are here!) We are back for one last round! This time we are going to cover improvements on three main areas: performance, upserts and migrations. If you would like to &#8230; <a class=\"read-more-link\" href=\"http:\/\/blog.plataformatec.com.br\/2018\/10\/a-sneak-peek-at-ecto-3-0-performance-migrations-and-more\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[238,143],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7870"}],"collection":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=7870"}],"version-history":[{"count":7,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7870\/revisions"}],"predecessor-version":[{"id":7879,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/7870\/revisions\/7879"}],"wp:attachment":[{"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=7870"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=7870"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=7870"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}