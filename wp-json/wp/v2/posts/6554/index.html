{"id":6554,"date":"2017-07-26T16:00:03","date_gmt":"2017-07-26T19:00:03","guid":{"rendered":"http:\/\/blog.plataformatec.com.br\/?p=6554"},"modified":"2017-08-06T05:04:22","modified_gmt":"2017-08-06T08:04:22","slug":"the-fallacies-of-web-application-performance","status":"publish","type":"post","link":"https:\/\/blog.plataformatec.com.br\/2017\/07\/the-fallacies-of-web-application-performance\/","title":{"rendered":"The fallacies of web application performance"},"content":{"rendered":"<p>Web application performance has always been a hot topic, especially in regards to the role frameworks play in it. It is common to run into fallacies when those discussions arise and the goal of this article is to highlight some of those.<\/p>\n<p>While I am obviously biased towards Elixir and the role it plays in the performance of web applications, I will do my best to explore fallacies that overplay and underplay the role of performance in web applications. I will also focus exclusively on the server-side of things (which, in many cases, is a fallacy in itself).<\/p>\n<h2>Fallacy 1: Performance is only a production concern<\/h2>\n<p>In my opinion, the most worrisome aspect of performance discussions is that they tend to focus exclusively on production numbers. However, performance drastically affects development and can have a large impact on developers. The most obvious examples I give in my presentations are compilation times and\/or application boot times: an application that takes 2 seconds to boot compared to one that takes 10 seconds has very different effects on the developer experience.<\/p>\n<p>Even response times have direct impact on developers. Imagine web application A takes 10ms on average per request. Web application B takes 50ms. If you have 100 tests that exercise your application, which is not a large number by any measure, the test suite in one application will take 1s, the other will take 5s. Add more tests and you can easily see how this difference grows. A slow feedback cycle during development hurts your team&#8217;s productivity and affects their morale. With Elixir and Phoenix, it is common to get sub-millisecond response times and the benefits are noticeable.<\/p>\n<p>When discussing performance, it is also worth talking about concurrency. Everything you do in your computer should be using all cores. Booting your application, compiling code, fetching dependencies, running tests, etc. Even <a href=\"https:\/\/www.apple.com\/lae\/apple-watch-series-2\/\">your wrist watch has 2 cores<\/a>. Concurrency is no longer the special case.<\/p>\n<p>However, you don&#8217;t even need multiple cores to start reaping the benefits of concurrency. Imagine that in the test suite above, 30% of the test time is spent on the database. <strong>While one test is waiting on the database, another test should be running<\/strong>. There is no reason to block your test suite while a single test waits on the database and this change in itself already improves build times.<\/p>\n<p>If multiple cores are available, you should demand even more gains in terms of performance throughout your development and test experiences. The Elixir compiler and built-in tools will use multiple cores whenever possible. The next time a library, tool or framework is taking too long to do something, ask how many cores it is using and what you can do about it.<\/p>\n<h2>Fallacy 2: Threads are enough for multi-core concurrency<\/h2>\n<p>Once we start to venture into concurrency, a common fallacy is that &#8220;if a programming language has threads, it will be equally good at concurrency as any other language&#8221;. To understand why this is not true, let&#8217;s look at <a href=\"https:\/\/en.wikipedia.org\/wiki\/Amdahl%27s_law\">Amdahl&#8217;s law<\/a>.<\/p>\n<p>To quote Wikipedia, Amdahl&#8217;s law is a formula which gives the theoretical speedup in latency of the execution of a task at fixed workload that can be expected of a system whose resources are improved:<\/p>\n<div id=\"attachment_6556\" style=\"width: 650px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" decoding=\"async\" aria-describedby=\"caption-attachment-6556\" src=\"http:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2017\/07\/AmdahlsLaw.svg_.png\" alt=\"\" width=\"640\" height=\"500\" class=\"size-full wp-image-6556\" srcset=\"https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2017\/07\/AmdahlsLaw.svg_.png 640w, https:\/\/blog.plataformatec.com.br\/wp-content\/uploads\/2017\/07\/AmdahlsLaw.svg_-300x234.png 300w\" sizes=\"(max-width: 640px) 100vw, 640px\" \/><p id=\"caption-attachment-6556\" class=\"wp-caption-text\">Amdahl&#8217;s law applied to number of processors. <a href=\"https:\/\/en.wikipedia.org\/wiki\/Amdahl%27s_law#\/media\/File:AmdahlsLaw.svg\">From Wikipedia, CC BY-SA 3.0.<\/a><\/p><\/div>\n<p>The graph above shows that the speedup of a program is limited by its serial part. If only 50% of the software is parallelizable, the theoretical maximum speedup is 2 times, regardless of how many cores you have in your system.<\/p>\n<p>If 50% of your software is parallelizable, going from 4 to 8 cores gives you only a 11% speed up. If 75% of the software is parallelizable, going from 4 to 8 cores gives you a 27% increase.<\/p>\n<p>In other words, threads are not enough for most web application developers if they still have to explicitly reach out for them. Instead we need abstractions that are used as building blocks. We need good programming models, efficient data structures, and tools. If only a limited part of the software is parallelizable, you will be quickly constrained by Amdahl&#8217;s law. Threads are necessary but not sufficient. Writing maintainable and effective concurrent software takes much more.<\/p>\n<h2>Fallacy 3: Conclusions drawn from average response times<\/h2>\n<p>Another common fallacy in such discussions is when conclusions are drawn based on average data: &#8220;Company X handles Y req\/second with an average of Zms, therefore you should be fine&#8221;.<\/p>\n<p>Here is why conclusions on this data is not enough. First of all, <a href=\"http:\/\/latencytipoftheday.blogspot.com\/2014\/06\/latencytipoftheday-most-page-loads.html\">most page loads will experience the 99% server response<\/a> (also see <a href=\"http:\/\/bravenewgeek.com\/everything-you-know-about-latency-is-wrong\/\">Everything you know about latency is wrong<\/a> for more discussion). Whenever you measure averages, also measure the 90%, 95% and 99% percentiles.<\/p>\n<p>Furthermore, in our experience, clients rarely have performance issues during average load, but rather when there are spikes in traffic. It is easy to plan for your average load. The challenge is in measuring how your system behaves when there is a surge in access. When discussing and comparing response times, also ask for the high percentiles, delays and error rates in case of overloads.<\/p>\n<p>Finally, the server response time as a metric is inherently limited. For instance, a fast server means nothing if the client-side is a mess and takes seconds to load. Instead of measuring a single request, consider also measuring how the user interacts with the website within certain goals. Let&#8217;s see an example.<\/p>\n<p>Imagine that your application requires the user to confirm their account in order to access part of its functionality (or all of it). Now, preparing for a spike in traffic, you cached your home page as well as your sign-up form. Requests start to pour in and you can see your website is responding fairly well, with low averages and even low 95% percentiles. You consider it a success.<\/p>\n<p>The next day, you are measuring how users interacted with your application and you could notice a unusually high bounce rate when the servers were on high load. Further analysis reveal that, even though the response times were excellent, the messaging system was clogged and instead of waiting 30 seconds to receive a message with instructions to confirm their account, users had to wait 10 minutes. It is safe to say many of those users left and never came back.<\/p>\n<p>Response times are not enough. For queues\/jobs, you want to at least measure arrival rates, departure rates and sojourn time. For this particular sign-up feature, you should measure the user engagement: from signing up, to scheduling the message, to delivering the message and the final user interaction with it.<\/p>\n<h2>Fallacy 4: Cost-free solutions<\/h2>\n<p>This is probably the most common fallacy of all.<\/p>\n<p>If you complain a certain library or framework takes a long time to boot, someone may quickly point out that there is a tool that solves the booting problem by having a runtime always running on the background.<\/p>\n<p>If your web application takes long to render certain views, you will be told to cache it.<\/p>\n<p>The trouble is that those solutions are not cost-free and their cost are often left unsaid. When the tool that runs your application in the background fails, your developers will be the ones debugging it. Between having a solution that addresses a certain problem and not having the problem at all, I prefer the second.<\/p>\n<p>Sometimes the lack of performance or proper tools will affect how your team designs and implements a feature. Time spent on caching and cache expiration is time that could be spent developing features. It is often joked that &#8220;cache invalidation and naming things are the two hard things in computer science&#8221;. We have <a href=\"http:\/\/blog.plataformatec.com.br\/2016\/02\/stateless-vs-stateful-web-apps\/\">discussed similar trade-offs in a previous article about stateful and stateless applications<\/a> &#8211; where a performant solution leads to benefits from development to deployment.<\/p>\n<p>This fallacy also happens when arguing in favor of technologies that are seen as performance centric. For example, if you want to use Elixir or Go, you will have to learn the underlying abstractions for concurrency, namely processes and goroutines, which is a time investment. If you want your tests to run concurrently when talking to the database in your Phoenix applications, you need to learn the pros, cons and pitfalls of doing so, a topic we covered in depth in the <a href=\"http:\/\/pages.plataformatec.com.br\/ebook-whats-new-in-ecto-2-0?utm_source=our-blog&amp;utm_medium=referral&amp;utm_campaign=ebook-ecto-2-1&amp;utm_content=link\">&#8220;What&#8217;s new in Ecto 2.0&#8221; free ebook<\/a>.<\/p>\n<p>It is important to make those costs explicit and part of the discussions.<\/p>\n<h2>Fallacy 5: Performance is all that matters<\/h2>\n<p>For the majority of companies and teams, that&#8217;s simply not the case. Therefore, if you are planning to move to another technology exclusively because of performance, you should have numbers that back up your decision.<\/p>\n<p>Similarly, we often see new languages being dismissed exclusively as &#8220;performance fallbacks&#8221;, while in many of those languages performance is typically a side-effect. For example, Elixir builds on the Erlang VM and focuses on developer productivity and code maintenance &#8211; and that&#8217;s why all of us at Plataformatec are proud of it. If you can get extra performance in production from it, that&#8217;s a nice bonus.<\/p>\n<p>At the end of the day, the discussion about performance is quite nuanced. It is important to know what to measure and how to interpret the data collected. We have learned that performance and concurrency models matter way beyond your production environment and have a large impact in development and testing. And there are no cost-free solutions, be it adding and maintaining a caching layer or picking up a new programming language.<\/p>\n<div style=\"background-color: #fffdf9; border: 1px solid #e9af35; border-radius: 6px; margin: 32px 0; padding: 22px 24px; font-family: sans-serif;\">\n<h3 style=\"font-size: 1.4em; line-height: 1.3em; margin-top: 0em !important;\">What&#8217;s new in Ecto 2.1<\/h3>\n<p style=\"margin-top: 0.5em !important;\">In 11 chapters, this <strong>free ebook<\/strong> explains how to use Ecto as a data-centric tool and its new features.<\/p>\n<p><a style=\"background: #e9af35; border: none; border-radius: 3px; color: #fff; display: inline-block; font-size: 12px; line-height: 1.5; margin-top: 5px; padding: 8px 16px; text-align: center; text-decoration: none; letter-spacing: 0.1em;\" href=\"http:\/\/pages.plataformatec.com.br\/ebook-whats-new-in-ecto-2-0?utm_source=our-blog&#038;utm_medium=referral&#038;utm_campaign=ebook-ecto-2-1&#038;utm_content=cta-blog-post-bottom\" target=\"_blank\">DOWNLOAD FOR FREE<\/a>\n<\/div>\n","protected":false},"excerpt":{"rendered":"<p>Web application performance has always been a hot topic, especially in regards to the role frameworks play in it. It is common to run into fallacies when those discussions arise and the goal of this article is to highlight some of those. While I am obviously biased towards Elixir and the role it plays in &#8230; <a class=\"read-more-link\" href=\"https:\/\/blog.plataformatec.com.br\/2017\/07\/the-fallacies-of-web-application-performance\/\">\u00bb<\/a><\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"ngg_post_thumbnail":0,"footnotes":""},"categories":[1],"tags":[143,59],"aioseo_notices":[],"jetpack_sharing_enabled":true,"jetpack_featured_media_url":"","_links":{"self":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/6554"}],"collection":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/comments?post=6554"}],"version-history":[{"count":14,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/6554\/revisions"}],"predecessor-version":[{"id":6605,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/posts\/6554\/revisions\/6605"}],"wp:attachment":[{"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/media?parent=6554"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/categories?post=6554"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.plataformatec.com.br\/wp-json\/wp\/v2\/tags?post=6554"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}